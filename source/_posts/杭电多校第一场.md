---
title: 杭电多校第一场
mathjax: true
categories:
  - ACM
  - 多校
  - 杭电多校
tags:
  - 题解
abbrlink: 9d88cf0e
---

![header](杭电多校第一场/header.jpg)

<!-- less -->

## A: Blank

### 题意

有 $n (n \leq 100)$ 个格子，向其中填入 $0、1、2、3 $这$4$个数，但是有 $m ( m ≤ 100)$ 个限制

限制 $l$   $ r$    $x$ ：表示 $l ~ r$ 的格子内不同的数的个数为$x$

要求满足所有限制的方案有多少种？

### 思路

我们首先设$dp[i][j][k][r]$为这$0，1，2，3$四个数字的最后一次出现的位置,$dp$值为方案数

那么转移可以这样写一下:

$dp[cur][j][k][r] += dp[i][j][k][r], dp[i][cur][k][r] += dp[i][j][k][r]$

$dp[i][j][cur][r] += dp[i][j][k][r], dp[i][j][k][cur] += dp[i][j][k][r]$

因为$i,j,k,r$互不相同, 且当位一定为一个数字并且相互之间有大小顺序，那么我们把$dp$按照大小来转移的话

还是$dp[cur][i][j][k]$ 其中$cur \geq i \geq j \geq k$

那么转移就变成

$dp[cur+1][i][j][k]+=dp[cur][i][j][k], dp[cur+1][cur][j][k] += dp[cur][i][j][k]$

$dp[cur+1][cur][i][k] += dp[cur][i][j][k], dp[cur+1][cur][i][j] += dp[cur][i][j]$

我们不必要区分$0,1,2,3$对应的是哪一个，因为这对结果没影响

这样的$dp$数组太大，我们可以用滚动数组来优化一下空间

### AC代码

实测$dp$数组降序会$T$，可能是因为$dp$过程中地址变换太大造成超时.

```c
#include<bits/stdc++.h>
using namespace std;

#define ll long long
const int maxn = 1e2 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;
typedef pair<int, int> pis;

vector<pis> lo[maxn];

ll dp[maxn][maxn][maxn][2];
//dp[i][j][k][cur] 升序
void add(ll &a, ll b) {
    a = a + b;
    if(a > mod) a -= mod;
    if(a < 0) a += mod;
}
int main() { 
    int t;
    scanf("%d", &t);
    while(t --) {
        int n, m;
        scanf("%d %d", &n, &m);
        for (int i = 1; i <= n; i ++) {
            lo[i].clear();
            lo[i].push_back(pis{i, 1});
        }
        for (int i = 1; i <= m; i ++) {
            int l, r, x;
            scanf("%d %d %d", &l, &r, &x);
            lo[r].push_back(pis{l, x});
        }
        memset(dp, 0, sizeof(dp));
        dp[0][0][0][0] = 1;
        for (int cur = 1; cur <= n; cur ++) {
            int np = cur & 1;
            for (int i = 0; i <= cur; i ++) 
                for (int j = i; j <= cur; j ++) 
                    for (int k = j; k <= cur; k ++) 
                        dp[i][j][k][np] = 0;
        
            for (int i = 0; i <= cur; i ++) 
                for (int j = i; j <= cur; j ++) 
                    for (int k = j; k <= cur; k ++) {
                        /*add(dp[i][k][cur-1][np], dp[i][j][k][np^1]);
                        地址跨越比add(dp[np][cur-1][k][i], dp[np^1][k][j][i]);
                        要大，可能是造成超时的原因
                        */
                        add(dp[j][k][cur-1][np], dp[i][j][k][np^1]);
                        add(dp[i][k][cur-1][np], dp[i][j][k][np^1]);
                        add(dp[i][j][cur-1][np], dp[i][j][k][np^1]);
                        add(dp[i][j][k][np], dp[i][j][k][np^1]);
                    }

            for (int i = 0; i <= cur; i ++) 
                for (int j = i; j <= cur; j ++) 
                    for (int k = j; k <= cur; k ++) 
                        for (pis it: lo[cur]) {
                            int l = it.first, r = cur, x = it.second;
                            int cnt = (i >= l) + (j >= l) + (k >= l) + 1;
                            if(cnt != x) dp[i][j][k][np] = 0;
                        }
                        
        }
        ll ans = 0;
        for (int i = 0; i <= n; i ++) 
            for (int j = i; j <= n; j ++) 
                for (int k = j; k <= n; k ++) add(ans, dp[i][j][k][n&1]);
        printf("%lld\n", ans);
    }
    return 0;
}
```



$dp[cur+1][i][j][k] += dp[cur][i][j][k], dp[cur+1][cur][j][k] += dp[cur][i][]$