---
title: 牛客多校第七场
mathjax: true
abbrlink: '68238393'
date: 2019-08-15 09:12:19
categories:
  - ACM
  - 多校
  - 牛客多校
tags:
  - 题解
---

![header](牛客多校第七场/header.jpg)

<!--less-->

## H:Pair

### 题意

给你3个数字$A,B,C$,让你计算$1\leq x\leq A,1\leq y\leq B$,并且$(x$ $and$ $y)>C$或者$(x$ $xor$ $y)<C$ 这样的

$<x,y>$有多少对

### 思路

很像数位dp，枚举二进制的每一位，4种状态分别是（A临界，B临界，A$and$B临界，A$xor$B临界）

这样直接数位dp可以算出有多少对不满足条件，然后用总数减去

因为$x,y>1$,所有要在数位dp算出的结果中减去x为0时和y为0时的数量

### AC代码

```c
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll dp[35][2][2][2][2];
int num_a[35], num_b[35], num_c[35];

void GetNum(ll a, ll b, ll c) {
    memset(num_a, 0, sizeof(num_a));
    memset(num_b, 0, sizeof(num_b));
    memset(num_c, 0, sizeof(num_c));
    num_a[0] = 0;
    while(a) {
        num_a[++num_a[0]] = a % 2;
        a /= 2;
    }
    num_b[0] = 0;
    while(b) {
        num_b[++num_b[0]] = b % 2;
        b /= 2;
    }
    num_c[0] = 0;
    while(c) {
        num_c[++num_c[0]] = c % 2;
        c /= 2;
    }
}

ll dfs(int pos, int a, int b, int an, int xo) {
    if(!pos) return 1;
    if(dp[pos][a][b][an][xo] != -1) return dp[pos][a][b][an][xo];
    int ua = a ? num_a[pos] : 1;
    int ub = b ? num_b[pos] : 1;
    int uan = an ? num_c[pos] : 1;
    int uxo = xo ? num_c[pos] : 0;
    ll ret = 0;
    for (int i = 0; i <= ua; i ++) 
        for (int j = 0; j <= ub; j ++) 
            if((i&j) <= uan && (i^j) >= uxo) 
                ret += dfs(pos-1, a&&(i==ua), b&&(j==ub), an&&((i&j)==uan), xo&&((i^j)==uxo));
    return dp[pos][a][b][an][xo] = ret;
}

int main() {
    int t;
    scanf("%d", &t);
    while(t --) {
        ll a, b, c;
        scanf("%lld %lld %lld", &a, &b, &c);
        GetNum(a, b, c);
        memset(dp, -1, sizeof(dp));
        ll ans = dfs(32, 1, 1, 1, 1) - max(0ll, a-c+1) - max(0ll, b-c+1);
        cout << a*b-ans << endl;
    }
    return 0;
}
```



## I:Chessboard

### 题意

给你一个N，M，然后你可以任意构造一个 k * k的矩阵，使得矩阵内每个元素最少是M，且任意不同行不同列的 k 个元素总和不超过N且都相同，问有多少种构造方法。

### 思路

![img1](牛客多校第七场/I-img1.png)

我们枚举$k$，我们可以把每个元素减去$M$，那么就相当于$N$减去$ k \times M$,简化问题并且不影响答案

![img2](牛客多校第七场/I-img2.png)

构造两个矩阵$Ai,Bi $对于这两个矩阵，我们可知他们前面的系数和为$T$则满足结果  等价于将$T$ 分成$2\times k$份($a$，$b$各有$k$个)采用隔板法 （将$T$ 转换成$1$排，每两个$1$之间有一个隔间，那么$k \times 2 + T$有$k \times 2 - 1 +T$个​隔间，我们选择$k \times 2 - 1$个隔间就可以把这些$1$分成$k \times 2$份

![img3](牛客多校第七场/I-img3.png)

为什么会算重，我们拿$T=3,k=2$来举个例子，比如$a_1=1,a_2=2,b_1=0,b_2=0$

那这个矩阵就是长这个样子

$\begin{bmatrix} a_1+b_1 &a_1+b_2 \\\ a_2+b_1 &a_2+b_2 \end{bmatrix}$ $==>$ $\begin{bmatrix} 1 & 1\\ 2 &2 \end{bmatrix}$

跟$\begin{bmatrix} a_1-1+b_1+1 &a_1-1+b_2+1\\ a_2-1+b_1+1 &a_2-1+b_2+1 \end{bmatrix}$ $==>$ $\begin{bmatrix} 1 & 1\\ 2 &2 \end{bmatrix}$

是相同的，也就是当$a_i$全部减1，而$b_i$全部加1时，跟原来的矩阵相同，所以这就重复了,那去重也就是这样去

PS:这篇博客其实是我扒[CM大佬](https://blog.csdn.net/henucm/article/details/99730917)的=^=

### AC代码

```c
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;

ll fac[maxn], inv[maxn];

ll Ksm(ll a, ll b, ll p) {
    ll res = 1;
    while(b) {
        if(b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

void Fac() {
    fac[0] = 1;
    for (int i = 1; i < maxn; i ++) 
        fac[i] = (fac[i-1] * i) % mod;
    inv[maxn-1] = Ksm(fac[maxn-1], mod-2, mod);
    for (int i = maxn-2; i >= 0; i --)
        inv[i] = inv[i+1] * (i+1) % mod;
}

ll C(int n, int m) {
    if(n < 0 || m < 0 || n < m) return 0;
    return fac[n] * inv[m] % mod * inv[n-m] % mod;
}

int main() {
    Fac();
    int T;
    scanf("%d", &T);
    while(T --) {
        int n, m;
        scanf("%d %d", &n, &m);
        ll ans = 0;
        for (int k = 1; k * m <= n; k ++) {
            int tt = n - k*m;
            for (int t = 0; t <= tt; t ++) {
                ans += C(t+k+k-1, k+k-1);
                if(t >= k) ans -= C(t+k-1, k+k-1);
                ans = (ans % mod + mod) % mod;
            }
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

