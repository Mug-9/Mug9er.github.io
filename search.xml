<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>吴恩达机器学习2</title>
    <url>//e0295d92/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>525-连续数组</title>
    <url>//f303f9cc/</url>
    <content><![CDATA[<h4 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a><a href="https://leetcode-cn.com/problems/contiguous-array/" target="_blank" rel="noopener">525. 连续数组</a></h4><p>跟523类似，只不过将0的数量减去1的数量的值做前缀和，再用哈希表存储下标。</p>
<pre><code class="lang-cpp">int findMaxLength(vector&lt;int&gt;&amp; nums) {
  unordered_map&lt;int, int&gt; m;
  int dis = 0, ans = 0, pre = 0;
  m[0] = -1;
  for (int i = 0; i &lt; nums.size(); ++ i) {
    pre += nums[i] == 0 ? 1 : -1;
    if(m.count(pre)) {
      ans = max(ans, i - m[pre]);
    }else m[pre] = i;
  }
  return ans;
}
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>523-连续的字数组和</title>
    <url>//51b0a147/</url>
    <content><![CDATA[<h4 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. 连续的子数组和</a></h4><p>直接用前缀和和$k$取余来记录前面k的余数的位置，判断是否大于2即可</p>
<pre><code class="lang-cpp">bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) {
  unordered_map&lt;int, int&gt; m;
  int n = nums.size();
  int pre = 0;
  m[0] = -1;
  for (int i; i &lt; n; ++i) {
    int x = nums[i];
    pre = (x + pre) % k;
    if(m.count(pre)) {
      if(i - m[pre] &gt;= 2) return true;
    }else m[pre] = i;
  }
  return false;
}
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>杭电多校第一场</title>
    <url>//9d88cf0e/</url>
    <content><![CDATA[<h2 id="A-Blank"><a href="#A-Blank" class="headerlink" title="A: Blank"></a>A: Blank</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n (n \leq 100)$ 个格子，向其中填入 $0、1、2、3 $这$4$个数，但是有 $m ( m ≤ 100)$ 个限制</p>
<p>限制 $l$   $ r$    $x$ ：表示 $l ~ r$ 的格子内不同的数的个数为$x$</p>
<p>要求满足所有限制的方案有多少种？</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们首先设$dp[i][j][k][r]$为这$0，1，2，3$四个数字的最后一次出现的位置,$dp$值为方案数</p>
<p>那么转移可以这样写一下:</p>
<p>$dp[cur][j][k][r] += dp[i][j][k][r], dp[i][cur][k][r] += dp[i][j][k][r]$</p>
<p>$dp[i][j][cur][r] += dp[i][j][k][r], dp[i][j][k][cur] += dp[i][j][k][r]$</p>
<p>因为$i,j,k,r$互不相同, 且当位一定为一个数字并且相互之间有大小顺序，那么我们把$dp$按照大小来转移的话</p>
<p>还是$dp[cur][i][j][k]$ 其中$cur \geq i \geq j \geq k$</p>
<p>那么转移就变成</p>
<p>$dp[cur+1][i][j][k]+=dp[cur][i][j][k], dp[cur+1][cur][j][k] += dp[cur][i][j][k]$</p>
<p>$dp[cur+1][cur][i][k] += dp[cur][i][j][k], dp[cur+1][cur][i][j] += dp[cur][i][j]$</p>
<p>我们不必要区分$0,1,2,3$对应的是哪一个，因为这对结果没影响</p>
<p>这样的$dp$数组太大，我们可以用滚动数组来优化一下空间</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><p>实测$dp$数组降序会$T$，可能是因为$dp$过程中地址变换太大造成超时.</p>
<pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e2 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;
typedef pair&lt;int, int&gt; pis;

vector&lt;pis&gt; lo[maxn];

ll dp[maxn][maxn][maxn][2];
//dp[i][j][k][cur] 升序
void add(ll &amp;a, ll b) {
    a = a + b;
    if(a &gt; mod) a -= mod;
    if(a &lt; 0) a += mod;
}
int main() { 
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --) {
        int n, m;
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        for (int i = 1; i &lt;= n; i ++) {
            lo[i].clear();
            lo[i].push_back(pis{i, 1});
        }
        for (int i = 1; i &lt;= m; i ++) {
            int l, r, x;
            scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;x);
            lo[r].push_back(pis{l, x});
        }
        memset(dp, 0, sizeof(dp));
        dp[0][0][0][0] = 1;
        for (int cur = 1; cur &lt;= n; cur ++) {
            int np = cur &amp; 1;
            for (int i = 0; i &lt;= cur; i ++) 
                for (int j = i; j &lt;= cur; j ++) 
                    for (int k = j; k &lt;= cur; k ++) 
                        dp[i][j][k][np] = 0;

            for (int i = 0; i &lt;= cur; i ++) 
                for (int j = i; j &lt;= cur; j ++) 
                    for (int k = j; k &lt;= cur; k ++) {
                        /*add(dp[i][k][cur-1][np], dp[i][j][k][np^1]);
                        地址跨越比add(dp[np][cur-1][k][i], dp[np^1][k][j][i]);
                        要大，可能是造成超时的原因
                        */
                        add(dp[j][k][cur-1][np], dp[i][j][k][np^1]);
                        add(dp[i][k][cur-1][np], dp[i][j][k][np^1]);
                        add(dp[i][j][cur-1][np], dp[i][j][k][np^1]);
                        add(dp[i][j][k][np], dp[i][j][k][np^1]);
                    }

            for (int i = 0; i &lt;= cur; i ++) 
                for (int j = i; j &lt;= cur; j ++) 
                    for (int k = j; k &lt;= cur; k ++) 
                        for (pis it: lo[cur]) {
                            int l = it.first, r = cur, x = it.second;
                            int cnt = (i &gt;= l) + (j &gt;= l) + (k &gt;= l) + 1;
                            if(cnt != x) dp[i][j][k][np] = 0;
                        }

        }
        ll ans = 0;
        for (int i = 0; i &lt;= n; i ++) 
            for (int j = i; j &lt;= n; j ++) 
                for (int k = j; k &lt;= n; k ++) add(ans, dp[i][j][k][n&amp;1]);
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<h2 id="L-Sequence"><a href="#L-Sequence" class="headerlink" title="L: Sequence"></a>L: Sequence</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给一个长度为n的数组，有m次操作，操作有3种，给一个x，每次改变序列的值$b<em>i=\sum\limits</em>{j=i-k*x}a_j$</p>
<p>求改变完了的序列的$(i\times a[i])$值的异或和</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>通过打表观察可以发现，一种操作多次操作就是把序列$a$和组合数序列进行卷积，然后就直接用ntt就行了</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 5e5 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;
typedef pair&lt;int, int&gt; pis;
#define g 3
#define Mod(x) ((x)&gt;=mod?(x)-mod:(x))

ll rnk[maxn];
ll a[maxn], b[maxn];

ll Ksm(ll a, ll b) {
    ll res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}

ll Fac[1000005], inv[1000005];

void FacPre() {
    inv[0] = Fac[0] = 1;
    for (int i = 1; i &lt;= 1000000; i ++)
        Fac[i] = 1ll * Fac[i-1] * i % mod;
    inv[1000000] = Ksm(Fac[1000000], mod-2);
    for (int i = 999999; i &gt;= 1; i --)
        inv[i] = 1ll * inv[i+1] * (i+1) % mod;
}

ll C(int n, int m) {
    if(m &gt; n) return 0;
    return 1ll * Fac[n] * inv[m] % mod * inv[n-m] % mod;
}

void ntt(long long *a, int op, int n) {
    for (int i = 0; i &lt; n; i ++) 
        if(i &lt; rnk[i]) swap(a[i], a[rnk[i]]);
        for (int i = 2; i &lt;= n; i &lt;&lt;= 1) {
            int nw = Ksm(g, (mod-1)/i);
            if(op == -1) nw = Ksm(nw, mod-2);
            for (int j = 0, m = i &gt;&gt; 1; j &lt; n; j += i) 
                for (int k = 0, w = 1; k &lt; m; k ++) {
                    int t = 1ll * a[j+k+m] * w % mod;
                    a[j+k+m] = Mod(a[j+k]-t+mod);
                    a[j+k] = Mod(a[j+k]+t);
                    w = 1ll * w * nw % mod;
                }
        }
        if(op == -1) 
            for (int i = 0, inv = Ksm(n, mod-2); i &lt; n; i ++)
                a[i] = 1ll * a[i] * inv % mod;
}

void solve(ll *a, ll *b, int len) {
    int n = 1, lim = 0;
    while(n &lt;= len + len) n &lt;&lt;= 1, lim++;
    for (int i = 0; i &lt; n; i ++)
        rnk[i] = (rnk[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1) &lt;&lt; (lim-1));
    ntt(a, 1, n); ntt(b, 1, n);
    for (int i = 0; i &lt; n; i ++)
        a[i] = (1ll * a[i] * b[i]) % mod;
    ntt(a, -1, n);
    for (int i = len; i &lt; n; i ++) a[i] = 0;
} 

int cnt[5];

int main() { 
    FacPre();
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --) {
        memset(cnt, 0, sizeof(cnt));
        int n, m;
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        for (int i = 0; i &lt; n; i ++)
            scanf(&quot;%lld&quot;, &amp;a[i]);
        for (int i = 1, op; i &lt;= m; i ++) {
            scanf(&quot;%d&quot;, &amp;op);
            cnt[op] ++;
        }
        for (int i = 1; i &lt;= 3; i ++) {
            memset(b, 0, sizeof(b));
            for (int j = 0; j * i &lt; n; j ++) 
                b[j*i] = C(cnt[i]-1+j, j);
            if(cnt[i] == 0) b[0] = 1;
            solve(a, b, n);
        }
        ll ans = 0;
        for (int i = 0; i &lt; n; i ++) ans = ans ^ (1ll * (i+1) * a[i]);
        printf(&quot;%lld\n&quot;, ans);
    } 
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>合并排序链表+指针指向问题</title>
    <url>//f9d7dd15/</url>
    <content><![CDATA[<h4 id="LeetCode-题目连接：https-leetcode-cn-com-problems-he-bing-liang-ge-pai-xu-de-lian-biao-lcof"><a href="#LeetCode-题目连接：https-leetcode-cn-com-problems-he-bing-liang-ge-pai-xu-de-lian-biao-lcof" class="headerlink" title="LeetCode 题目连接：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/"></a>LeetCode 题目连接：<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</a></h4><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>限制：</p>
<p>0 &lt;= 链表长度 &lt;= 1000</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>很简单的题，直接定义一个头，然后两个指针相互比较即可。</p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>再最初版本出现了问题，最开始的想法很简单，定义一个头<code>pre</code> 用他去遍历两个链表，再用一个<code>ans</code>来记录<code>pre</code>的头部，然后问题出现了，使用<code>pre=pre-&gt;next, pre=l2</code>时，发现<code>ans</code>并不能完全表达<code>pre</code>的值</p>
<pre><code class="lang-c++">ListNode *pre = NULL;
if(l1-&gt;val &lt;= l2-&gt;val) {
    pre = l1;
    l1 = l1-&gt;next;

}else {
    pre = l2;
    l2 = l2-&gt;next;
}
ListNode* ans = pre;
pre = pre-&gt;next;
while(l1 != NULL &amp;&amp; l2 != NULL) {
    if(l1-&gt;val &lt;= l2-&gt;val) {
        pre = l1;
        l1 = l1-&gt;next;
    }else {
        pre = l2;
        l2 = l2-&gt;next;
    }
    pre = pre-&gt;next;
}
</code></pre>
<p>类似如此，<code>ans</code>返回的时第一次的<code>pre</code>值</p>
<h5 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h5><p>第一次<code>ans=pre</code>，此时<code>ans</code>与<code>pre</code>指向同一个地址，类似如此</p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gh8tv20gyfj318z0fsk80.jpg" alt="img1"></p>
<p>当执行<code>pre=pre-&gt;next</code>时</p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gh8uasmxrlj31f90kptym.jpg" alt></p>
<p>当这时执行到<code>pre=l2</code>时，</p>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gh8utv4338j31df0mbx5l.jpg" alt></p>
<p>会发现<code>pre</code>指针直接指向<code>l2</code>,而不会带着next指针一起指向<code>l2</code>，这就造成了<code>pre</code>自己走完了一整个链表而<code>ans</code>却一直指向开始的位置。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>指的时候带上<code>next</code>就可以了</p>
<pre><code class="lang-c++">ListNode* pre = new ListNode(0);
ListNode* cur = pre;
while(l1 != NULL &amp;&amp; l2 != NULL) {
    if(l1-&gt;val &lt;= l2-&gt;val) {
        cur-&gt;next = l1;
        l1 = l1-&gt;next;
    }else {
        cur-&gt;next = l2;
        l2 = l2-&gt;next;
    }
    cur = cur-&gt;next;
}
</code></pre>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* pre = new ListNode(0);
        ListNode* cur = pre;
        while(l1 != NULL &amp;&amp; l2 != NULL) {
            if(l1-&gt;val &lt;= l2-&gt;val) {
                cur-&gt;next = l1;
                l1 = l1-&gt;next;
            }else {
                cur-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            cur = cur-&gt;next;
        }
        if(l1 != NULL) cur-&gt;next = l1;
        if(l2 != NULL) cur-&gt;next = l2;
        return pre-&gt;next;
    }
};
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Deepin安装NVIDIA以及refind</title>
    <url>//81fa645f/</url>
    <content><![CDATA[<h1 id="Deepin安装NVIDIA驱动"><a href="#Deepin安装NVIDIA驱动" class="headerlink" title="Deepin安装NVIDIA驱动"></a>Deepin安装NVIDIA驱动</h1><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><h3 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h3><p>首先根据自己电脑独显的型号去NVIDIA<a href="https://www.nvidia.cn/geforce/drivers/" target="_blank" rel="noopener">官网</a>选择对应驱动</p>
<p>如果不确定自己电脑显卡型号，可以用<code>sudo lshw -numeric -C display</code>来查看</p>
<h3 id="卸载以前的驱动"><a href="#卸载以前的驱动" class="headerlink" title="卸载以前的驱动"></a>卸载以前的驱动</h3><p>如果之前在Linux中安装过NVIDIA驱动的话，请将其全部删除</p>
<pre><code class="lang-bash">sudo apt autoremove nvidia
</code></pre>
<h3 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h3><p>nouveau是通过逆向“Nvidia的Linux驱动”创造的一个开源第三方Nvidia显卡驱动程序，因此其效果差，性能低。在手动安装NVIDIA时需要禁用nouveau驱动。</p>
<p>终端执行以下命令修改文件。</p>
<pre><code>sudo vi /etc/modprobe.d/blacklist.conf
</code></pre><p>以下内容复制到文件中</p>
<pre><code>blacklist nouveau   
blacklist lbm-nouveau   
options nouveau modeset=0 
alias nouveau off   
alias lbm-nouveau off
</code></pre><p>保存退出。<br>其中，blacklist nouveau是禁用nouveau第三方驱动，之后不需要改回来<br>由于nouveau是构建在内核中的，所以要执行下面命令生效:</p>
<pre><code>sudo update-initramfs -u
</code></pre><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><pre><code>reboot
</code></pre><p>重启后查看nouveau有没有运行,没输出代表禁用生效</p>
<pre><code>lsmod | grep nouveau
</code></pre><h3 id="关闭图形界面"><a href="#关闭图形界面" class="headerlink" title="关闭图形界面"></a>关闭图形界面</h3><p>安装Nvidia驱动程序时，需要停止当前的图形界面。<br>使用快捷键CTRL+ALT+F2进入超级终端，登录账号，并关闭图形界面：</p>
<pre><code>sudo service lightdm stop
</code></pre><h3 id="给驱动文件添加执行权限"><a href="#给驱动文件添加执行权限" class="headerlink" title="给驱动文件添加执行权限"></a>给驱动文件添加执行权限</h3><p>下载好的nvidia驱动文件是.run，需要添加执行权限。<br>使用cd指令进入下载好的驱动文件路径，如果没有改浏览器的下载路径，路径一般是/home/（你的用户名）/Downloads 。</p>
<pre><code>sudo chmod +x NVIDIA***.run  #记得文件名改成自己下载的文件。
</code></pre><h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><pre><code>sudo ./NVIDI**.run  #记得文件名改成自己下载的文件。
</code></pre><p>这个时候会出现一个页面，一系列yes，还有一个界面选择install and cover，意为安装和覆盖。然后等待几分钟。</p>
<h3 id="重启-1"><a href="#重启-1" class="headerlink" title="重启"></a>重启</h3><pre><code>reboot
</code></pre><p>这样NVIDIA驱动就装好了。</p>
<h2 id="检测NVIDIA驱动是否成功安装"><a href="#检测NVIDIA驱动是否成功安装" class="headerlink" title="检测NVIDIA驱动是否成功安装"></a>检测NVIDIA驱动是否成功安装</h2><h3 id="使用nvidia-settings命令"><a href="#使用nvidia-settings命令" class="headerlink" title="使用nvidia-settings命令"></a>使用<strong>nvidia-settings</strong>命令</h3><pre><code class="lang-bash">nvidia-settings
</code></pre>
<p>可以看到显卡数据</p>
<h3 id="使用nvidia-smi命令"><a href="#使用nvidia-smi命令" class="headerlink" title="使用nvidia-smi命令"></a>使用nvidia-smi命令</h3><p>英伟达系统管理接口（NVIDIA System Management Interface, 简称 nvidia-smi）是基于NVIDIA Management Library 的命令行管理组件,旨在帮助管理和监控NVIDIA GPU设备。</p>
<pre><code>nvidia-smi
</code></pre><p>执行这条命令将会打印出当前系统安装的NVIDIA驱动信息</p>
<h3 id="命令行搜索集显和独显"><a href="#命令行搜索集显和独显" class="headerlink" title="命令行搜索集显和独显"></a>命令行搜索集显和独显</h3><pre><code class="lang-bash">lspci | grep VGA     # 查看集成显卡
lspci | grep NVIDIA
</code></pre>
<h3 id="查看nouveau是否运行"><a href="#查看nouveau是否运行" class="headerlink" title="查看nouveau是否运行"></a>查看nouveau是否运行</h3><pre><code class="lang-bash">lsmod | grep nouveau
</code></pre>
<h2 id="集显与独显切换"><a href="#集显与独显切换" class="headerlink" title="集显与独显切换"></a>集显与独显切换</h2><p>笔记本外出时使用集显可以节省电量，增长待机时间。<br>可以使用插件：dde-dock-switch_graphics_card<br>Github：<a href="https://github.com/zty199/dde-dock-switch_graphics_card" target="_blank" rel="noopener">https://github.com/zty199/dde-dock-switch_graphics_card</a><br>安装后可以方便地在dock栏切换显卡</p>
<h1 id="使用refind引导win10和deepin"><a href="#使用refind引导win10和deepin" class="headerlink" title="使用refind引导win10和deepin"></a>使用refind引导win10和deepin</h1><h2 id="安装refind"><a href="#安装refind" class="headerlink" title="安装refind"></a>安装refind</h2><p>最好在deepin环境下安装refind，因为这样比较简单。</p>
<p>在deepin环境下安装refind有两种方法，使用终端命令行或者下载安装包。</p>
<pre><code>sudo apt-add-repository ppa:rodsmith/refind
sudo apt-get update
sudo apt-get install refind
</code></pre><p>安装好refind后重启，你会发现电脑默认引导已经变成了refind，EFI 分区也出现了refind文件夹。但此时的引导界面有两个问题：</p>
<p>1、选项很多，而且界面很丑；<br>2、选择deepin系统后还是会进入grub引导界面，浪费时间。</p>
<p>因此接下来我们需要修改一些东西。</p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><h3 id="设置grub等待时间为0"><a href="#设置grub等待时间为0" class="headerlink" title="设置grub等待时间为0"></a>设置grub等待时间为0</h3><p>在deepin中，通用&gt;启动&gt;启动延时关闭</p>
<h3 id="下载好看的refind主题"><a href="#下载好看的refind主题" class="headerlink" title="下载好看的refind主题"></a>下载好看的refind主题</h3><p>首先下载主题压缩包，特别推荐我自己使用的这款极简主题（自带凤凰系统的图标），下载地址：</p>
<p>github：<a href="https://github.com/EvanPurkhiser/rEFInd-minimal" target="_blank" rel="noopener">https://github.com/EvanPurkhiser/rEFInd-minimal</a></p>
<p>将解压后的文件放入refind文件夹下的themes文件夹（没有的话可以自行创建）内，可以在deepin环境下使用终端命令操作，也可以切换到win10系统用diskgenius软件进行操作。</p>
<h3 id="修改refind配置文件"><a href="#修改refind配置文件" class="headerlink" title="修改refind配置文件"></a>修改refind配置文件</h3><p>使用deepin终端修改/EFI/refind/refind.conf文件，需要使用的基本命令如下：</p>
<pre><code>su root    #获取root权限
vim 你的目录/refind.conf    #使用vim修改文件
i    #进入修改模式
ESC按键    #退出修改模式
:wq    #保存并退出
</code></pre><p>进入vim编辑模式后，可以看到配置文件有大量的注释，需要修改的命令行其实只有如下几处：</p>
<pre><code>timeout 3
resolution 1920 1080
dont_scan_files /EFI/ubuntu/grubx64.efi,/EFI/UOS/fbx64.efi,/EFI/UOS/mmx64.efi,/EFI/UOS/shimx64.efi,/EFI/boot/bootx64.efi,/EFI/boot/grubx64.efi
scan_all_linux_kernels false
include  themes/rEFInd-minimal/theme.conf
</code></pre><p>这样就可以用refind引导deepin和win10了</p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Deepin</tag>
        <tag>NVIDA驱动</tag>
        <tag>refind</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记（三）</title>
    <url>//a8ec0156/</url>
    <content><![CDATA[<h1 id="C-学习笔记-三"><a href="#C-学习笔记-三" class="headerlink" title="C++ 学习笔记(三)"></a>C++ 学习笔记(三)</h1><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>​        在一个类中，若将一个成员变量声明为<code>static</code>，这种成员成为静态变量，与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝，静态成员变量，属于某个类，所有对象共享。</p>
<p>​        静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。</p>
<ul>
<li>静态成员变量必须在类中声明，在类外定义</li>
<li>静态数据成员 不属于某个对象，在为对象分配空间中不包括静态对象成员所占空间</li>
<li>静态数据成员可以通过类名或者对象名来引用</li>
<li>静态成员变量在类内声明，在类外初始化</li>
<li>静态成员变量也有权限</li>
</ul>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul>
<li>静态成员函数不可以访问普通的成员变量，可以访问静态成员变量</li>
<li>静态成员函数也是有权限的</li>
<li>普通成员函数可以访问普通成员变量，也可以访问静态成员变量    </li>
</ul>
<h2 id="面向对象模型初探"><a href="#面向对象模型初探" class="headerlink" title="面向对象模型初探"></a>面向对象模型初探</h2><h3 id="成员变量和函数的存储"><a href="#成员变量和函数的存储" class="headerlink" title="成员变量和函数的存储"></a>成员变量和函数的存储</h3><p>数据 和 处理数据的操作是分开存储的</p>
<ul>
<li><code>C++</code>中的非静态数据成员直接内含在类对象中，就像<code>C struct</code>一样</li>
<li>成员函数虽然内含在<code>class</code>声明之内，却不出现在对象中</li>
<li>每一个非内联成员函数只会诞生一份函数实例</li>
</ul>
<p>空类的大小为1,每一个实例的对象，都有独一无二的地址，<code>char</code>维护这个地址</p>
<pre><code class="lang-cpp">class Person{
public:
    int m_A; // 非静态成员变量，属于对象身上
    void func() {}; //非静态成员函数，不属于对象身上
       static int m_B; // 静态成员变量，不属于对象身上
    static void func2() {}; //静态成员函数，不属于对象身上
}
// 结论： 非静态成员变量，才属于对象身上
</code></pre>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a><code>this</code>指针</h3><p><code>this</code>指针称为“永远指向本对象的指针”，<code>this</code>指针并不是对象的一部分,<code>*this</code>是对象本体</p>
<p><code>this</code>指针是一种隐含指针，它隐含于每个类的非静态成员函数中，静态成员函数不能访问<code>this</code>指针</p>
<p><code>this</code>指针指向被调用的成员函数所属的对象</p>
<pre><code class="lang-cpp">Person p1;
p1.func(Person*this);// 编译器会偷偷加上一个p1的this指针
</code></pre>
<h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><p>空指针可以访问成员函数，但是如果成员函数中用到了<code>this</code>指针，那么就会执行失败</p>
<h4 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a><code>const</code> 修饰成员函数</h4><p><code>this</code>永远指向本体，类似<code>Person * const this</code>,<code>this</code>的指向不能修改，但指针指向的值可以修改</p>
<pre><code class="lang-cpp">void showInfo() const { // const加后面代表常函数，意味着不允许修改指针指向的值
    this-&gt;m_B = 100; // 如果在常函数中修改，那么就在成员变量前面加mutable
}
mutable int m_B;
</code></pre>
<h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><p>常对象不允许修改属性</p>
<pre><code class="lang-cpp">const Person p2;
</code></pre>
<p>常对象不可以调用普通的成员函数，可以调用常函数</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元函数可以访问类的私有成员属性</p>
<h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><p>全局函数可以作为类的友元函数，在类中声明全局函数，并加上<code>friend</code>关键字</p>
<pre><code class="lang-cpp">class A{
    public:
    friend void test();
};
void test() {
    // ...
}
</code></pre>
<h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><pre><code class="lang-cpp">class A{
    friend class B;
    // B作为A的友元类，可以访问A的私有成员属性
}
</code></pre>
<h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><pre><code class="lang-cpp">class A{
    firend void B::test();
    // B的成员函数作为A的友元，可以访问A的私有成员属性
}
</code></pre>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>如果想让自定义数据类型进行运算符运算，那么就需要重载运算符。</p>
<p>在成员函数或者在全局函数中，重写一个运算符重载，运算符重载也可以进行重载</p>
<p><strong>对于内置数据类型的表达式运算符是不可以改变的（例如int类型的+号）</strong></p>
<h3 id="号重载"><a href="#号重载" class="headerlink" title="+号重载"></a><code>+</code>号重载</h3><pre><code class="lang-cpp">class A {
    // 类内重载
    A operator + (A &amp; b) {
        A tmp;
        // ...
        return tmp;
    }
}
// 全局重载
A operator + (A &amp;a, A &amp;b) {
    A tmp;
    // ...
    return tmp;
}
</code></pre>
<h3 id="lt-左移运算符"><a href="#lt-左移运算符" class="headerlink" title="&lt;左移运算符"></a><code>&lt;</code>左移运算符</h3><p>不要随意使用符号重载，<code>cout &lt;&lt;</code>可以对自定义数据类型进行输出</p>
<pre><code class="lang-cpp">ostream&amp; operator &lt;&lt; (ostream &amp;cout, A &amp;a) { // 第一个参数cout，第一个参数A    
    cout &lt;&lt; &quot;A: &quot; &lt;&lt; a &lt;&lt; endl;
}//全局重载可以在类中添加friend，访问类的私有成员属性
</code></pre>
<h3 id="前置后置递增运算符重载"><a href="#前置后置递增运算符重载" class="headerlink" title="前置后置递增运算符重载"></a>前置后置递增运算符重载</h3><pre><code class="lang-cpp">class MyInt{  // 前置++重载
    MyInt&amp; operator++(){    this-&gt;num ++;    return *this;}// 后置++重载，使用int来区分
    MyInt operator++(int) {    MyInt tmp = *this;    this-&gt;num ++;    return tmp;}private:   int  num;}
</code></pre>
<h3 id="指针运算符重载"><a href="#指针运算符重载" class="headerlink" title="指针运算符重载"></a>指针运算符重载</h3><p>智能指针，用来托管自定义类型对象，让对象进行自动的释放</p>
<p>智能指针就是一个包含对象类型的类，重载<code>-&gt;</code>可以使得智能指针调用类内指针的成员函数以及成员变量</p>
<pre><code class="lang-cpp">A * operator -&gt; () { // 加上*代表返回指针    
    return this-&gt;a;
}
A &amp; operator * () {    
    return *this-&gt;a;
}
</code></pre>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>一个类默认创建，默认构造、析构、拷贝构造 、<code>operator=</code>赋值元算符</p>
<pre><code class="lang-cpp">class Person {    // 重载=    
    Person&amp; operator = (const Person&amp; p) {       
        //先判断堆区是否有内容       
        if (this-&gt;pName != NULL) {            
            delete[] this-&gt;pName;            
            this-&gt;pName = NULL;        
        }        
        this-&gt;pName = new char[strlen(p.pName)+1];        
        strcpy(this-&gt;pName, p.pName);        
        return *this;   
    }    
    private:    char* pName;
}
</code></pre>
<h3 id="重载"><a href="#重载" class="headerlink" title="[]重载"></a>[]重载</h3><pre><code class="lang-cpp">class MyArray{ 
    public:    
              // []重载    
              int&amp; operator[] (int   idx) {        
                  return *this-&gt;pAddress[idx];   
              }   private:    
    int *pAddress;    
    int m_Size;   
    int m_Capacity;
};
</code></pre>
<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><pre><code class="lang-cpp">class Person{    
    bool operator == (Person &amp;p) {        
        if(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) {     
            return true;     
        }       
        return false;   
    }   
    bool operator != (Person &amp;p) {    
        if(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) {   
            return false; 
        }      
        return true;   
    }public:      
    string name; 
    int age;   
}
</code></pre>
<h3 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h3><p>()重载</p>
<pre><code class="lang-cpp">class MyPrint{
    public: 
    void operator() (string s) {   
        cout &lt;&lt; s &lt;&lt; endl; 
    }
}
MyPrint mp;//仿函数
MyPrint()(&quot;你好&quot;) 
mp(&quot;你好&quot;);// 匿名对象
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>=， []，-&gt; 操作符只能通过成员函数进行重载</li>
<li>&lt;&lt;，&gt;&gt;只能通过全局函数配合友元函数重载</li>
<li>不要重载&amp;&amp;，||操作符，因为无法实现短路规则</li>
</ul>]]></content>
      <categories>
        <category>C++ 学习</category>
      </categories>
      <tags>
        <tag>C++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达机器学习1</title>
    <url>//79200c28/</url>
    <content><![CDATA[<h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><blockquote>
<p>$A\ computer\ program\ is\ said\ to\ learn\ from\  experience\ E\ with\ respect\ to\ some\ class\ of\ tasks\ T\ and\ performance\ measure\ P\ ,$</p>
<p>$\ if\ its\ performance\ at\ tasks\ in\ T,\ as\ measured\ by\ P,\ improves\ with\ experience\ E.$ </p>
</blockquote>
<p>一个计算机程序可以从经验$E$中学习，执行任务$T$，由$P$做性能评估，并且他在$T$任务中的表现(由$P$衡量)随着经验$E$的提高而提高。</p>
<p>以下跳棋为例:</p>
<blockquote>
<p>$E:$  下过很多跳棋的经验</p>
<p>$T：$下跳棋的任务</p>
<p>$P ：$下一局赢下跳棋的可能性</p>
</blockquote>
<p>一般的任何机器学习都可以分类两类：监督学习和非监督学习</p>
<h3 id="什么是监督学习"><a href="#什么是监督学习" class="headerlink" title="什么是监督学习"></a>什么是监督学习</h3><blockquote>
<p>$In\ supervised\ learning,\ we\ are\ given\ a data\ set\ and\ already\ know\ what\ our\ correct\ output\ should\ look\ like,$</p>
<p>$having\ the\ idea\ that\ there\ is\ a\ relationship\ between\ the\ input\ and\ the\ output.$</p>
</blockquote>
<p>在监督学习中，我们已知一个数据集，并且已经知道正确的输出应该是什么样的，我们知道输入与输出之间存在着一种关系。</p>
<p>在监督学习中，我们已经知道数据集的含义、分布，根据已知的信息来预测。</p>
<blockquote>
<p>$Supervised\ learning\ problems\ are\ categorized\ into\ “regression”\ and\ “classification”\ problems.\ $</p>
<p>$In\ a\ regression\ problem,\ we\ are\ trying\ to\ predict\ results\ within\ a\ continuous\ output,\ meaning\ that \ $</p>
<p>$we\ are\ trying\ to\ map\ input\ variables\ to\ some\ continuous\ function.\ In\ a\ classification\ problem,\ we\ $</p>
<p>$ are\  instead\ trying\ to\ predict\ results\ in\ a\ discrete\ output.\ In\ other\ words,\ we\ are\ trying\ to\ map\ input\ $</p>
<p>$variables\ into\ discrete\ categories.\ $</p>
</blockquote>
<p>监督学习问题分为“回归”问题和“分类”问题。在回归问题中，我们试图预测连续输出中的结果，这意味着我们试图将输入变量映射到某个连续函数。在分类问题中，我们试图预测离散输出中的结果。换句话说，我们试图将输入变量映射到离散的类别中。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>回归问题：给一张照片，去预测照片中人的年龄</p>
<p>分类问题：对于患有肿瘤的病人，去预测肿瘤是良性还是恶性</p>
<h3 id="什么是无监督学习"><a href="#什么是无监督学习" class="headerlink" title="什么是无监督学习"></a>什么是无监督学习</h3><blockquote>
<p>$Unsupervised\ learning\ allows\ us\ to\ approach\ problems\ with\ little\ or\ no\ idea\ what\ our\ results\ should\  $</p>
<p>$look\ like.\ We\ can\ derive\ structure\ from\ data\ where\ we\ don’t\ necessarily\ know\ the\ effect\ of\ the\ variables.\ $</p>
<p>$We\ can\ derive\ this\ structure\ by\ clustering\ the\ data\ based\ on\ relationships\ among\ the\ variables\ in\ the\ data.$</p>
<p>$With\ unsupervised\ learning\ there\ is\ no\ feedback\ based\ on\ the\ prediction\ results.$</p>
</blockquote>
<p>无监督学习让我们在几乎不知道结果是什么的情况下处理问题。我们可以从数据中得出结构，而我们并不一定知道变量的影响。</p>
<p>我们可以根据数据中变量之间的关系对数据进行聚类，从而得到这种结构。</p>
<p>在无监督学习中，没有基于预测结果的反馈。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>收集100万个不同的基因，然后找到一种方法将这些基因分组，这些分组在某种程度上是相似的，或者由不同的变量(如寿命、位置、角色等)相关的。</p>
<h2 id="建立符号规则"><a href="#建立符号规则" class="headerlink" title="建立符号规则"></a>建立符号规则</h2><p>$m$ 表示训练集数量，对于训练集中的每一项，我们使用$x^{(i)}$表示训练集中的第$i$行输入的变量，使用$y^{(i)}$表示训练集中第$i$行输出的变量 。</p>
<p>一对$(x^{(i)},y^{(i)})$成为一个训练样例，$(i)$只是表示训练集中的索引，而不是次幂。还使用$X$来表示输入值的空间，$Y$表示输出值的空间。</p>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><blockquote>
<p>$To\ describe\ the\ supervised\ learning\ problem\ slightly\ more\ formally,\ our\ goal\ is,\ given\ a\ training\ set,\ $</p>
<p>$to\ learn\ a\ function\ h\ :\ X\ →\ Y\ so\ that\ h(x)\ is\ a\ “good”\ predictor\ for\ the\ corresponding\ value\ of\ y.\ $</p>
<p>$For\ historical\ reasons,\ this\ function\ h\ is\ called\ a\ hypothesis.\ Seen\ pictorially,\ the\ process\ is\ $</p>
<p>$therefore\ like\ this:\ $</p>
</blockquote>
<p>为了更正式地描述监督学习问题，我们的目标是，给定一个训练集，学习一个函数$h: X → Y$，使$h(X)$是对应的$Y$值的一个很好的预测器。由于历史原因，这个函数$h$被称为一个假设。从图片上看，这个过程是这样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/Mug-9/imge-stroage@master/Andrew-ML/supervised learning process.3tlcgn2ah0o0.png" alt="supervised learning process"></p>
<h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>假设的$h$函数由$h_{\theta}(x)=\theta_0 + \theta_1x$拟合而来，$\theta_0$和$\theta_1$是两个未知参数</p>
<p>我们的目的是选择最适合的$\theta<em>0,\theta_1$以便于$h</em>{\theta}(x)$最接近与真正的训练集对应$Y$值的分布</p>
<p>代价函数$J(\theta<em>0,\theta_1)=\frac{1}{2m}\sum\limits</em>{i=1}^m(\hat y<em>i -y_i)^2=\frac{1}{2m}\sum\limits</em>{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^2$表示$h$函数与$Y$值之间的误差</p>
<p>$Goal:\ \min\limits_{\theta_0,\theta_1}J(\theta_0, \theta_1)$</p>
<p>把$\theta_0$设成0,不同的$\theta_1$对应的$h$函数所形成的误差在$J(\theta_1)$的图像上呈现一个二次函数的图像，寻找$J(\theta_1)$的最小值，就是寻找最适合，最拟合与$Y$的$h(\theta_1)$函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/Mug-9/imge-stroage@master/Andrew-ML/Cost Function.x637adlj7nk.png" alt="Cost Function"></p>]]></content>
      <categories>
        <category>机器学习</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记(一)</title>
    <url>//deefd94b/</url>
    <content><![CDATA[<h3 id="机器学习三大步骤"><a href="#机器学习三大步骤" class="headerlink" title="机器学习三大步骤"></a>机器学习三大步骤</h3><h3 id="先写出一个带有未知参数的数学式"><a href="#先写出一个带有未知参数的数学式" class="headerlink" title="先写出一个带有未知参数的数学式"></a>先写出一个带有未知参数的数学式</h3><p>$Function \ with \ Unknown \ Parameters$</p>
<p>$y = b + w x_1$ </p>
<p>带有未知参数$b, w$的公式，叫做<code>model</code>(带有未知的参数的数学式)</p>
<p>$x_1:$ 公式中已知的东西叫做<code>feature</code></p>
<p>$w:$ 不知道的参数叫做<code>weight</code>（权重）</p>
<p>$b:$ 不知道的参数叫做<code>bias</code> （偏移）</p>
<h3 id="根据训练集定义-Loss"><a href="#根据训练集定义-Loss" class="headerlink" title="根据训练集定义$Loss$"></a>根据训练集定义$Loss$</h3><p>$Loss(b,w)$是一个函数，输入是$b,w$</p>
<p>Loss代表训练出来的函数对于训练集的拟合程度</p>
<p>$Loss: L = \frac{1}{N}\sum\limits_n{e_n} (e = |y - y’|)$ 每项$e$是$model$对于训练集的误差</p>
<h3 id="最佳化"><a href="#最佳化" class="headerlink" title="最佳化"></a>最佳化</h3><p>$w^<em>, b^</em> = arg \  \min\limits_{w,b}L$</p>
<h4 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="$Gradient\ Descent$"></a>$Gradient\ Descent$</h4><ul>
<li>随机选取一个初始点$w^0$</li>
<li>计算微分 $\frac{\partial L}{\partial w}|_{w= w^0}$</li>
<li>根据微分的正负选择向前或向后移动$\eta\frac{\partial L}{\partial w}|_{w= w^0}$, $\eta$学习速率，自己设置</li>
<li>迭代的更新$w$值</li>
</ul>
<h2 id="model-的限制"><a href="#model-的限制" class="headerlink" title="$model$ 的限制"></a>$model$ 的限制</h2><p>对于一次项的$model$是一条单纯的斜线，可能无法很好的拟合数据集，这叫做$Model$的$bias$，解决方法，写一个更复杂的，有更多未知参数的$model$</p>
<p>例如需要拟合一个复杂的函数（红色线段）， 可以在每次的转折点添加一个蓝色线段，斜率保持相同即可，按理说，越是复杂的红色线段所需要的蓝色线段越多</p>
<p><img src="https://cdn.jsdelivr.net/gh/Mug-9/imge-stroage@master/LearnML/models.5chioa0bzcc0.png" alt="models"></p>
<p>对于连续的曲线可以选择足够多的点，就可以来使用蓝色线段拟合</p>
<p><img src="https://cdn.jsdelivr.net/gh/Mug-9/imge-stroage@master/LearnML/piecewise linear.4388gdf4y3c0.png" alt="piecewise linear"></p>
<h3 id="如何来表达蓝色线段"><a href="#如何来表达蓝色线段" class="headerlink" title="如何来表达蓝色线段"></a>如何来表达蓝色线段</h3><p>通过一个函数来逼近蓝色线段 $y = c \frac{1}{1 + e ^{-(b+wx_1)}}$ 即 $y = c \ sigmoid (b + wx_1)$</p>
<p><img src="https://cdn.jsdelivr.net/gh/Mug-9/imge-stroage@master/LearnML/signoid Function1.71wq3fsce580.png" alt="signoid Function1"></p>
<p>调整$b, w, c$就可以得到各种各样的蓝色线段，改变$w$可以改变斜率，改变$b$会改变偏移，改变$c$会改变高</p>
<p><img src="https://cdn.jsdelivr.net/gh/Mug-9/imge-stroage@master/LearnML/change bwc.jhv85766gds.png" alt="change bwc"></p>
<p>对于不同的蓝色线段使用不同的$b,w,c$来通过$sigmoid$逼近，那么红色线段的函数式就为$y = b + \sum\limits_{i}c_i\ sigmoid(b_i  + w_ix_1)$</p>
<h3 id="线性代数表达"><a href="#线性代数表达" class="headerlink" title="线性代数表达"></a>线性代数表达</h3><p>对于数据$x_1, x_2, x_3$</p>
<p>$\sum\limits_{i}c_i\ sigmoid(b_i + w_ix_1)$可以表示为</p>
<script type="math/tex; mode=display">r_1 = b_1 + w_1x_1\\ r_2 = b_2 + w_2x_2 \\ r_3 = b_3 + w_3 x_3</script><p>矩阵写法</p>
<script type="math/tex; mode=display">\begin {bmatrix} r_1\\r_2\\r_3 \end {bmatrix} = \begin {bmatrix} b_1\\b_2\\b_3 \end {bmatrix} + \begin {bmatrix} w_1 \ 0 \ 0\\0\ w_2\ 0\\0 \ 0\ w_3 \end {bmatrix}\begin {bmatrix} x_1\\x_2\\x_3 \end {bmatrix}</script><p>$r = b + Wx$</p>
<p>在对每一个$r$做$sigmoid$运算 $a = \partial(r)$</p>
<p>红色线段函数: $y = b + \sum\limits_{i}c_i \ a$</p>
<p>使用线性代数表达方式: $y = b + c^T a$</p>
<p>使用$\theta $ 来包含所有的未知参数$\theta = \begin{bmatrix} \theta_1\ \theta_2 \ \theta_3 \ \dots \ \end{bmatrix}$</p>
<h4 id="Loss-使用-theta-参数"><a href="#Loss-使用-theta-参数" class="headerlink" title="$Loss$ 使用$\theta $参数"></a>$Loss$ 使用$\theta $参数</h4><p><strong>$Loss$现在使用写成$L(\theta)$</strong></p>
<p>新的$Loss$表示为：$Loss: \ L = \frac{1}{N}\sum\limits_ne_n$</p>
<h4 id="迭代最好的-model"><a href="#迭代最好的-model" class="headerlink" title="迭代最好的$model$"></a>迭代最好的$model$</h4><p>$\theta^* = arg \ \min\limits_{\theta}L$</p>
<p>随机选择一个初始的$\theta^0$， 对$\theta$的每一项进行微分得到一个向量$g$ ,</p>
<p>$g = \begin{bmatrix} \frac{\partial L}{\partial \theta<em>1}|</em>{\theta = \theta^0} \ \frac{\partial L}{\partial \theta<em>2}|</em>{\theta = \theta^0} \ \frac{\partial L}{\partial \theta<em>3}|</em>{\theta = \theta^0} \ \dots \end{bmatrix}=  \nabla L (\theta ^0)$</p>
<p>在$\theta = \theta^0$的位置把所有的参数都对$L$做微分</p>
<p>更新$\theta$的值</p>
<p>$\begin{bmatrix} \theta<em>1^1 \ \theta_2^1\ \dots \end{bmatrix} \longleftarrow \begin{bmatrix} \theta_1^0 \ \theta_2^0\ \dots \end{bmatrix} - \begin{bmatrix} \eta \frac{\partial L}{\partial \theta_1}|</em>{\theta = \theta^0} \ \eta \frac{\partial L}{\partial \theta<em>2}|</em>{\theta = \theta^0} \ \dots \end{bmatrix}$</p>
<p>新的$\theta$由原先的$\theta^0$ 减去 微分的向量 × $\eta$</p>
<p>$\theta^1 \longleftarrow  \theta^0 - \eta g$</p>
<p>步骤： 先随机选取$\theta^0$，通过计算$gradient$ 得到 $ g = \nabla L (\theta ^0)$,在如此迭代得到$\theta^1, \theta^2,…$直到无法在计算$gradient$时结束</p>
<p>实际操作时，将数据集分为多组，利用每一组来计算$gradient$更新$\theta$</p>
<p><img src="https://cdn.jsdelivr.net/gh/Mug-9/imge-stroage@master/LearnML/compute gradient.lz1l4r37lu.png" alt="compute gradient"></p>
<h3 id="从-sigmoid-到-RELU"><a href="#从-sigmoid-到-RELU" class="headerlink" title="从 $sigmoid$到$RELU$"></a>从 $sigmoid$到$RELU$</h3><p>利用$RELU$来拟合函数 $c\ max(0, b+wx_1)$</p>
<p>$ y = b + \sum\limits<em>i c_i \ sigmoid(b_i + \sum\limits_jw</em>{ij}x_j)$</p>
<p>$y = b + \sum\limits<em>{2i}c_i max(0, b_i+\sum\limits_jw</em>{ij}x_j)$</p>
<p>$sigmoid$ 和 $RELU$ 统称为$activation\ function$, $RELU$更好一些</p>
<h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><p>当拟合的函数次数过多时，对于训练数据会出现拟合效果好，但是对于测试数据拟合率爆炸的情况。</p>]]></content>
      <categories>
        <category>ML 学习</category>
      </categories>
      <tags>
        <tag>ML 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记(五)</title>
    <url>//2c61a387/</url>
    <content><![CDATA[<h1 id="C-学习笔记（五）"><a href="#C-学习笔记（五）" class="headerlink" title="C++ 学习笔记（五）"></a>C++ 学习笔记（五）</h1><h2 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h2><p>尽量少使用类型转换，除非用来解决特殊问题</p>
<h3 id="静态转换static-cast"><a href="#静态转换static-cast" class="headerlink" title="静态转换static_cast"></a>静态转换<code>static_cast</code></h3><pre><code class="lang-cpp">目标类型 目标对象 = static_cast&lt;目标类型&gt;(原对象);
</code></pre>
<ul>
<li><p>用于类层次结构中的基类和派生类之间指针或引用的转换，没有父子关系的不能转换</p>
<ul>
<li>进行上行转换（派生类的指针或引用转换成基类）是安全的</li>
<li>进行下行转换（基类指针或引用转换成派生类）时，由于没有动态类型检查，所以时不安全的</li>
</ul>
</li>
<li><p>用于基本数据类型之间的转换，如将<code>int</code>转换成<code>char</code>，把<code>char</code>转换成<code>int</code>，这种转换的安全性也要开发人员来保证</p>
</li>
</ul>
<h3 id="动态转换dynamic-cast"><a href="#动态转换dynamic-cast" class="headerlink" title="动态转换dynamic_cast"></a>动态转换<code>dynamic_cast</code></h3><p><code>dynamic_cast</code>非常严格，失去精度或者不安全都不可以转换</p>
<pre><code class="lang-cpp">目标类型 目标对象 = dynamic_cast&lt;目标类型&gt;(原对象);
</code></pre>
<ul>
<li><p>基础类型之间不能转换</p>
</li>
<li><p><code>dynamic_cast</code>如果发生了多态，那么可以让基类转为派生类，向下转换</p>
</li>
</ul>
<h3 id="常量转换const-cast"><a href="#常量转换const-cast" class="headerlink" title="常量转换const_cast"></a>常量转换<code>const_cast</code></h3><p>用来修改<code>const</code>属性</p>
<ul>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象</li>
</ul>
<p><strong>注意</strong>:不能直接对非指针和非引用的变量使用<code>const_cast</code>操作符去直接移除它的<code>const</code></p>
<pre><code class="lang-cpp">const int * p = NULL;
int *newp = const_cast&lt;int *&gt; (p);
int * p1 = NULL;
const int *newp1 = const_cast&lt;const int *&gt; (p1);
</code></pre>
<h3 id="重新解释转换reinterpert-cast"><a href="#重新解释转换reinterpert-cast" class="headerlink" title="重新解释转换reinterpert_cast"></a>重新解释转换<code>reinterpert_cast</code></h3><p>最不安全，不推荐使用</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><pre><code class="lang-cpp">try{
    // 试图执行的内容
    // 在可能出现异常的地方抛出异常throw
}
catch() {
     // try下面catch捕获异常   
    // catch(捕获类型) ... 代表所有其他类型
    // 如果不想处理异常，继续向上抛出throw
}
</code></pre>
<h3 id="跳级"><a href="#跳级" class="headerlink" title="跳级"></a>跳级</h3><p><img src="https://cdn.jsdelivr.net/gh/Mug-9/imge-stroage@master/LearnCFive/image-20210510100605400.1wh5scq2w1c0.png" alt="image-20210510100605400"></p>
<h3 id="异常基本处理"><a href="#异常基本处理" class="headerlink" title="异常基本处理"></a>异常基本处理</h3><pre><code class="lang-cpp">int myd(int a, int b){
    if(b == 0) {
        // return -1; 早期处理方式，返回-1
        throw -1; // 抛出int类型异常，异常必须处理，如果不处理就挂掉
    }
    return a/b;
}
void test() {
    int a = 10, b = -10;
    int ret =  myd(a, b); // 早期如果返回-1， 无法区分到底是结果还是异常
    try{
        myd(a, b);
    }
    catch(int) {// 捕获int类型异常
        // 如果不想在这处理，就抛出，返回上一层处理,类型不变
        throw;
        //. 异常处理
    }
    catch(...) { //其他类型异常捕获

    }
}
void test2() {
    try{
        test();
    }catch(int) { // 如果异常都没有处理，那么成员terminate函数是程序中断
        // ...
    }
}
</code></pre>
<h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><pre><code class="lang-cpp">class MyException{
    public :
      void printError();
}
// try{ 抛出异常
//    throw MyException();
// }
// 捕获异常
catch(MyException e) {
    e.printError();
}
</code></pre>
<h3 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h3><ul>
<li>从try开始到throw抛出异常之前，所有栈上的对象，都会被释放，这个过程称为栈解旋</li>
<li>栈上对象构造和析构顺序相反</li>
</ul>
<h3 id="异常的接口声明"><a href="#异常的接口声明" class="headerlink" title="异常的接口声明"></a>异常的接口声明</h3><pre><code class="lang-cpp">void func() throw(int) { //thrwo(int) 只能抛出int类型异常
    throw 3.14;
    // 抛出double类型直接挂掉
}
void func() throw() { //thrwo() 不跑出任何类型异常
    throw 3.14;
}
</code></pre>
<h3 id="异常变量声明周期"><a href="#异常变量声明周期" class="headerlink" title="异常变量声明周期"></a>异常变量声明周期</h3><p>异常变量的构造是在<code>throw</code>抛出异常时构造，析构实在<code>catch</code>处理完以后析构</p>
<pre><code class="lang-cpp">class MyException{
    public :
      void printError();
}
void dowork() {
    throw MyException();
}
void test() {
    try {
        dowork();
    }catch(MyException e) { // catch时通过拷贝构造又会有一份数据，所以建议使用&amp; 
        // catch(MyException &amp;e)

    }
}
// 返回指针，使用new，在堆区开辟内存，然后手动delete
void dowork() {
    throw new MyException();
}
void test() {
    try {
        dowork();
    }catch(MyException * e) { // catch时通过拷贝构造又会有一份数据，所以建议使用&amp; 
        // catch(MyException &amp;e)
        delete e;
    }
}
</code></pre>
<h3 id="异常的多态"><a href="#异常的多态" class="headerlink" title="异常的多态"></a>异常的多态</h3><p>利用多态来实现<code>printError</code>同一个接口的使用</p>
<h3 id="系统的异常库"><a href="#系统的异常库" class="headerlink" title="系统的异常库"></a>系统的异常库</h3><pre><code class="lang-cpp">#include &lt;stdexcept&gt;
</code></pre>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><pre><code class="lang-cpp">#include &lt;fstream&gt;
</code></pre>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><pre><code class="lang-cpp">void test() {    ofstream ofs(path， ios::out|ios::trunc);    if(!ofs.is_open) {        //... 打开失败    }    ofs &lt;&lt; &quot;content&quot; &lt;&lt; endl;}
</code></pre>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><pre><code class="lang-cpp">void test() {    ifstream ifs(path, ios::in);    if(!ifs.is_open) {        //... 打开失败    }    // 第一种方式    char buf[1024];    while(ifs &gt;&gt; buf) { // 按行读取        cout &lt;&lt; buf &lt;&lt; endl;    }    // 第二种方式    while(!ifs.enf()) { // enf读到文件尾        ifs.getline(buf, sizeof(buf));        cout &lt;&lt; buf  &lt;&lt; endl;    }    // 第三种方式 不推荐 按单个字符读取    char c;    while((c = ifs.get()) != EOF) {        cout &lt;&lt; c &lt;&lt; endl;    }    }
</code></pre>]]></content>
      <categories>
        <category>C++ 学习</category>
      </categories>
      <tags>
        <tag>C++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记(四)</title>
    <url>//2acaf4fa/</url>
    <content><![CDATA[<h1 id="C-学习笔记（四）"><a href="#C-学习笔记（四）" class="headerlink" title="C++学习笔记（四）"></a>C++学习笔记（四）</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code class="lang-cpp">class 子类 : 继承方式 父类
</code></pre>
<h3 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">继承方式</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">父类私有属性能不能访问</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>public</code></td>
<td style="text-align:center">父类的属性权限不变</td>
<td style="text-align:center">不能</td>
</tr>
<tr>
<td style="text-align:center"><code>protect</code></td>
<td style="text-align:center">父类的属性全变为<code>protect</code></td>
<td style="text-align:center">不能</td>
</tr>
<tr>
<td style="text-align:center"><code>private</code></td>
<td style="text-align:center">父类的属性全变为<code>private</code></td>
<td style="text-align:center">不能</td>
</tr>
</tbody>
</table>
</div>
<p>子类中会继承父类的私有成员，但是被编译器隐藏了起来</p>
<h3 id="继承中的构造与析构"><a href="#继承中的构造与析构" class="headerlink" title="继承中的构造与析构"></a>继承中的构造与析构</h3><pre><code class="lang-cpp">构造： 先执行父类的构造函数，在调用子类的构造函数

析构：先执行子类的析构，在执行父类的析构
</code></pre>
<p>子类并不能继承父类的构造和析构函数，只有父类自己知道自己构造和析构的属性</p>
<p>如果父类没有默认构造，那么子类在构造时可以通过初始化列表的方式显示调用父类的有参构造</p>
<pre><code class="lang-###">class Base{
    Base(int a) ;
}
class Son : public Base{
    Son(int a): Base(a) {
} 
}
</code></pre>
<h3 id="继承中的同名处理"><a href="#继承中的同名处理" class="headerlink" title="继承中的同名处理"></a>继承中的同名处理</h3><p>子类与父类属性或函数同名时，根据就近原则，属性为子类的值，如果想使用父类的值，那么就在调用时加上作用域</p>
<pre><code class="lang-cpp">class Base{
    public:
int m_a;
}
class Son : punlic Base{
    public;
    Son(int a) {
        this-&gt;m_a = 200;
    }
    int m_a;
}
void test() {
    Son s;
    cout &lt;&lt; s.m_a &lt;&lt; endl; // 子类的m_a
    cout &lt;&lt; s.Base::m_a &lt;&lt; endl;// 父类的m_a
}
</code></pre>
<p>如果子类与父类的成员函数名称相同，子类会把父类的所有同名版本全隐藏，像调用父类的方法，必须加作用域</p>
<h3 id="继承中的静态成员处理"><a href="#继承中的静态成员处理" class="headerlink" title="继承中的静态成员处理"></a>继承中的静态成员处理</h3><p>静态成员属性，子类可以继承下来，使用时直接在静态成员属性前加作用域即可</p>
<p>静态成员函数，子类也可以继承下来，使用时</p>
<pre><code class="lang-cpp">Son::func() // 子类的func
Son::Base::func() // 父类的func
</code></pre>
<h3 id="非自动继承的函数"><a href="#非自动继承的函数" class="headerlink" title="非自动继承的函数"></a>非自动继承的函数</h3><p>不是所有的函数都能继承到子类，构造和析构函数不能继承，<code>operator=</code>也不能继承，因为它完成类似构造函数的行为</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>一个类可以继承多个类</p>
<pre><code class="lang-cpp">class A: public B, public C
</code></pre>
<h4 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h4><p>多继承中如果多继承的多个类有相同的成员属性，那么子类在调用父类相同的属性时会引发二义性</p>
<pre><code class="lang-cpp">class A: public B, public C
A a;
cout &lt;&lt; a.m_a &lt;&lt; endl; // 如果B和C中都有m_a会引发二义性
cout &lt;&lt; a.B::m_a &lt;&lt; a.C::m_a &lt;&lt; endl;// 使用时在前面加上作用域
</code></pre>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>子类继承的父类继承自同一个基类，会导致二义性的产生</p>
<pre><code class="lang-cpp">class A;
class B: public A;
class C: public A;
class D: public B, public C;
</code></pre>
<h3 id="菱形继承解决方案"><a href="#菱形继承解决方案" class="headerlink" title="菱形继承解决方案"></a>菱形继承解决方案</h3><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><pre><code class="lang-cpp">class A;
class B: virtual public A; //虚基类B
class C: virtual public A; // 虚基类C
class D: public B, public C;
</code></pre>
<p>虚继承后，子类中会有一个虚指针，指向一张虚基类表，通过表找到偏移量可以找到共有数据</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为编译时多态（静态多态）和运行时多态（动态多态），运算符重载和函数重载是编译时多态，派生类和虚函数是运行时多态</p>
<ul>
<li>静态联编： 地址早绑定，编译阶段绑定好地址</li>
<li>动态联编： 地址晚绑定，运行时绑定号地址</li>
<li>多态： 父类的引用或指针 指向子类对象</li>
</ul>
<pre><code class="lang-cpp">class Animal {
public:
    virtual void speak() {
        cout &lt;&lt; &quot;animal speak&quot; &lt;&lt; endl;
    }
};

class Cat : public Animal {
public:
    void speak() {
        cout &lt;&lt; &quot;cat speak&quot; &lt;&lt; endl;
    }
};

// 调用dospeak，没有使用virtual时 speak函数的地址早就绑定好了，静态联编， 编译阶段确定好了地址
// 如果想使用cat的speak，那么就不能提前绑定函数的地址，所以需要运行时确定函数地址
// 动态联编，写法 dospeak 改为虚函数，在父类上声明虚函数，发生了多态
// 父类的引用或指针 指向子类对象
void doSpeak(Animal&amp; animal) { // 使用虚函数时 Animal &amp; animal = cat    
    animal.speak();
}

void test() {
    Cat cat;
    //如果发生了继承，编译器允许进行类型转换
    doSpeak(cat);
}
</code></pre>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gqb74bih29j30tx0hu43x.jpg" alt="image-20210508173802580"></p>
<p>当<code>Animal</code>有了虚函数后，内部结构发生了改变， 内部多了一个虚指针，指向<code>Animal</code>的虚函数表 ,<code>Cat</code>内部也有一个虚指针，继承自<code>Animal</code>的虚指针，指向自己内部的虚函数表，父类和子类的虚函数表相同但是地址不同。如果<code>Cat</code>没有重写<code>Animal</code>的<code>speak</code>函数，那么虚函数表中的函数就是<code>Animal</code>的<code>speak</code>，如果重写了，那么就是<code>Cat</code>自身的<code>speak</code></p>
<pre><code class="lang-cpp">Animal * animal = new Cat;
animal-&gt;spead()；
// 调用的是cat的speak，因为父类指针指向子类对象，指向时，子类已经发生多态，调用的也是多态后的函数
</code></pre>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><pre><code class="lang-cpp">virtual int abc() = 0; // 告诉编译器在vtable中保留一个位置
</code></pre>
<p>如果父类有纯虚函数，那么子类必须实现纯虚函数</p>
<p>如果父类有了纯虚函数，那么父类就无法实例化对象，变成抽象类</p>
<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>普通析构函数是不会调用子类的析构的，所以可能导致释放不干净，虚析构可以解决这个问题</p>
<p>纯虚析构需要声明并且实现，在类内声明，在类外实现，只声明不实现会报错，如果类出现了纯析构函数，那么这个类也算抽象类</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><p>基类转派生类，向下转换，不安全</p>
<pre><code class="lang-cpp">Animal * animal = new Animal;
Cat *cat = (Cat*)animal;
</code></pre>
</li>
<li><p>派生类转基类，向上转换，安全</p>
<pre><code class="lang-cpp">Cat * cat = new Cat;
Animal *animal = (Animal*)cat;
</code></pre>
</li>
<li><p>如果发生了多态，总是安全的</p>
</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code class="lang-cpp">int swap(int &amp;a, int &amp;b) {
    int tmp = a;
    a = b;
    b = tmp;
}
double swap(double &amp;a, double &amp;b) {
    int tmp = a;
    a = b;
    b = tmp;
}
</code></pre>
<p>对于逻辑相似类型不同的函数，可以使用泛型编程—模板技术</p>
<pre><code class="lang-cpp">template&lt;class T&gt; // 告诉编译器下面如果出现T，不要报错， T是一个通用类型
    //template &lt;typename T&gt; class与typename 作用相同
void swap(T &amp;a, T &amp;b) {
    T tmp = a;
    a = b;
    b = tmp;
}
</code></pre>
<p>模板特点：</p>
<ul>
<li>自动类型推导，自动推导传参的数据类型到模板</li>
</ul>
<pre><code class="lang-cpp">swap(a, b) // 自动类型推导，按照a，b的类型来替换T
</code></pre>
<ul>
<li>显示指定类型</li>
</ul>
<pre><code class="lang-cpp">swap&lt;int&gt; (a, b)
</code></pre>
<ul>
<li>模板必须指定出<code>T</code>才可以使用</li>
<li>函数模板必须紧跟着<code>template&lt;class T&gt;</code></li>
</ul>
<h3 id="函数模板与普通函数的区别以及调用规则"><a href="#函数模板与普通函数的区别以及调用规则" class="headerlink" title="函数模板与普通函数的区别以及调用规则"></a>函数模板与普通函数的区别以及调用规则</h3><ul>
<li>普通函数可以进行隐式类型转换，函数模板不可以进行隐式类型转换</li>
<li>如果函数模板与普通函数出现了重载，那么优先使用普通函数，如果没有实现，出现错误。如果想强制调用模板，可以使用空参数列表</li>
</ul>
<pre><code class="lang-cpp">swap&lt;&gt;(a, b);
</code></pre>
<ul>
<li>函数模板可以发生重载</li>
</ul>
<pre><code class="lang-cpp">template&lt;class T&gt;
swap(T a, T b, T c);
</code></pre>
<ul>
<li>如果函数模板可以产生更好的匹配，那么调用函数模板</li>
</ul>
<pre><code class="lang-cpp">char a, b;
swap(a, b);
//调用函数模板
</code></pre>
<h3 id="模板机制"><a href="#模板机制" class="headerlink" title="模板机制"></a>模板机制</h3><ul>
<li>编译器并不是把函数模板处理成能够处理任何类型的函数</li>
<li>函数模板通过具体类型产生不同的函数</li>
<li>编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译</li>
</ul>
<h3 id="模板局限性"><a href="#模板局限性" class="headerlink" title="模板局限性"></a>模板局限性</h3><p>对于自定义的数据类型，使用具体化自定义数据类型解决</p>
<pre><code class="lang-cpp">class Person{
    int m_age;
    int m_name;
};
template&lt;class T&gt;
bool Compare(T &amp;a, T &amp;b) {
    if(a == b) return true;
    return false;
}
template&lt;&gt; bool Compare&lt;Person&gt;(Person &amp;a, Person&amp;b) {
    if(a.m_age == b.m_age) return true;
    return false;
}
</code></pre>
<p>如果具体化能够优先匹配，那么就选择具体化</p>
<pre><code class="lang-cpp">template&lt;&gt; 返回值 函数名&lt;具体类型&gt; (参数)
</code></pre>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><pre><code class="lang-cpp">template&lt;class NameType, class AgeType=int&gt;
class Person{
    public:
        Person(NameType name, AgeType age) {
            this-&gt;m_name = name;
            this-&gt;m_age = age;
        }
        NameType m_name;
        AgeType m_age;
}
</code></pre>
<ul>
<li><p>类模板不支持自动类型推导</p>
</li>
<li><p>类模板参数可以设默认值</p>
</li>
<li><p>需要指点显示类型</p>
<pre><code class="lang-cpp">Person&lt;string, int&gt; p(&#39;abc&#39;, 18);
</code></pre>
</li>
<li><p>成员函数一开始不会创建出来，而是运行时才去创建</p>
</li>
</ul>
<h3 id="类模板做函数的参数"><a href="#类模板做函数的参数" class="headerlink" title="类模板做函数的参数"></a>类模板做函数的参数</h3><pre><code class="lang-cpp">//指定传入类型
void dowork(Person&lt;string, int&gt; &amp;p);
template&lt;class T1, class T2&gt;
// 参数模板化
void dowork2(Person&lt;T1, T2&gt; &amp;p);
void test() {
    Person&lt;string, int&gt; p(&#39;ab&#39;, 18);
    dowork2(p);
}
// 整体类型化
template&lt;class T&gt;
void dowork3(T &amp;p);
void test() {
    Person&lt;string, int&gt; p(&#39;aa&#39;, 18);
    dowork3(p);
}
</code></pre>
<h3 id="类模板和继承"><a href="#类模板和继承" class="headerlink" title="类模板和继承"></a>类模板和继承</h3><pre><code class="lang-cpp">template &lt;class T&gt;
class Base{
    public: 
        T m_a;
}
// child 继承与base必须告诉base中的T的类型，否则T无法分配内存
class Child : public Base&lt;int&gt;{

}
// childr2 也是模板类
template&lt;class T1, class T2&gt;
class Child2 : public Base&lt;T2&gt;{
    public:
    T1 m_b;
}
</code></pre>
<ul>
<li>基类如果是模板类，必须让子类告诉编译器基类中的T是什么类型，如果不告诉，那么就无法分配内存</li>
<li>利用参数列表<code>class Child : public Base&lt;int&gt;</code></li>
</ul>
<h3 id="类模板类外实现成员函数"><a href="#类模板类外实现成员函数" class="headerlink" title="类模板类外实现成员函数"></a>类模板类外实现成员函数</h3><pre><code class="lang-cpp">template&lt;class T1, class T2&gt;
class Person{
    public:
        Person(T1 name, T2 age);
        T1 m_name;
        T2 m_age;
}
template&lt;class T1, class T2&gt;
Person&lt;T1,T2&gt;::Person(T1 name, T2 age) {
    this-&gt;m_name = name;
    this-&gt;m_age = age;
}
</code></pre>
<h3 id="类模板分文件编写问题以及解决"><a href="#类模板分文件编写问题以及解决" class="headerlink" title="类模板分文件编写问题以及解决"></a>类模板分文件编写问题以及解决</h3><pre><code class="lang-cpp">--- Person.h
--- Person.cpp
--- main.cpp
</code></pre>
<p><code>Person.h</code>写<code>Person</code>模板类的声明，<code>Person.cpp</code>写<code>Person</code>模板类的实现，在<code>main.cpp</code>中导入<code>Person.h</code>时，由于类模板的成员函数运行阶段才会去创建，所以编译器在编译时不会对<code>Person.cpp</code>中的方法进行创建，导致在链接时无法链接到方法。无法解析外部命令</p>
<p>解决方法：将类的声明和实现写到同一文件，后缀为<code>.hpp</code></p>
<h3 id="类模板和友元函数"><a href="#类模板和友元函数" class="headerlink" title="类模板和友元函数"></a>类模板和友元函数</h3><ul>
<li>友元函数类内实现跟普通类实现相同</li>
<li>声明时需要加上<code>&lt;&gt;</code>代表声明的是模板函数</li>
</ul>
<pre><code class="lang-cpp">template&lt;class T1, class T2&gt; class Person; // 让编译器看到Person声明
template&lt;class T1, class T2&gt; void printPerson(Person&lt;T1, T2&gt; &amp;p); // 让编译器提前看到printPerson声明
template&lt;class T1, class T2&gt;
class Person{
    friend void printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p); // 加上&lt;&gt;代表模板函数
    public:
        Person(T1 name, T2 age);
        T1 m_name;
        T2 m_age;
}
template&lt;class T1, class T2&gt; // 友元函数类外实现
void printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p) {
// ...
}
</code></pre>]]></content>
      <categories>
        <category>C++ 学习</category>
      </categories>
      <tags>
        <tag>C++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记(二)</title>
    <url>//5287e3ee/</url>
    <content><![CDATA[<h1 id="C-学习笔记（二）"><a href="#C-学习笔记（二）" class="headerlink" title="C++学习笔记（二）"></a>C++学习笔记（二）</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是对对象的抽象</p>
<p>对象是对类的实例</p>
<pre><code class="lang-cpp">class 类名{
public: 公共权限
    设置 成员属性
    设置 成员函数
}
</code></pre>
<h3 id="设计一个圆类，求圆的周长"><a href="#设计一个圆类，求圆的周长" class="headerlink" title="设计一个圆类，求圆的周长"></a>设计一个圆类，求圆的周长</h3><pre><code class="lang-cpp">/*
设计一个类，求圆的周长
*/
const double pi = 3.1415926535;

class Circle{ //class 代表声明一个类，后面紧跟的是类的名称
  public: //公共权限
  // 半径 成员属性
    int  m_R;
    // 求圆周长的函数
    double calZC() { // 类里面的函数，叫作成员函数
      return 2 * pi * m_R;
    }
    // 设置半径的成员方法 成员函数通常可以修改成员属性
    void setR(int r) {
      m_R = r;
    }
};
</code></pre>
<h3 id="设计学生类"><a href="#设计学生类" class="headerlink" title="设计学生类"></a>设计学生类</h3><pre><code class="lang-cpp">class Student {
public:
  string m_Name; // 姓名
  int m_Id;  // 学号

  void  setName(string name) {
    m_Name = name;
  }

  void setId(int id) {
    m_Id = id;
  }

  void showInfo() {
    cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; m_Name &lt;&lt; &quot; 学号:&quot; &lt;&lt; m_Id;
  }
};
</code></pre>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>​        宏函数只是简单的在编译期进行替换，所以宏函数无法对传参进行检查，也会出现歧义。内联函数是一个真正的函数，会检查函数参数列表，并返回值。内联函数在编译期也会进行替换，所以内联函数会占用空间，但是内联函数相对于普通函数的优势是省去了函数调用时的压栈，跳转和返回的开销。我们可以理解为内联函数以空间换时间。类中的成员函数默认是内联函数。</p>
<p>​        内联仅仅是给编译器的一个建议，编译器不一定会接受这种建议，如果你没有江汉数声明为内联函数，那么编译器也可能将此函数做内联编译，一个好的编译器将会内联小的、简单的函数。</p>
<h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><pre><code class="lang-cpp">void test(int a = 10, int b = 20, int c = 30) {
    cout &lt;&lt; a + b + c&lt;&lt; endl;
}
// 形参b设置默认值，那么后面的形参c也需要设置默认值，如果一个位置有个默认参数，那么后面的参数也必须有默认值
void test(int a, int b = 20, int c = 30) {}
// 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能在设置默认参数
void test(int a = 0, int b = 0); // 声明时
void test(int a, int b) { //定义时
    // ...
}
</code></pre>
<h3 id="占位参数"><a href="#占位参数" class="headerlink" title="占位参数"></a>占位参数</h3><pre><code class="lang-cpp">void test(int a, int = 1) {}
</code></pre>
<p>​        占位参数，函数调用时必需提供这个参数，但是用不到参数，可以有默认值</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>实现重载的条件</p>
<ul>
<li>同一个作用域</li>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数顺序不同</li>
</ul>
<p>当函数重载碰到默认参数时，要注意避免二义性问题</p>
<pre><code class="lang-cpp">void func2(int a, int b = 10) {}
void func2(int a){}
这里出现了二义性问题
</code></pre>
<p>引用的重载</p>
<pre><code class="lang-cpp">void func(int &amp;a) {} //引用必需要合法的空间
void func(const int &amp;a) {} //const 也可以作为重载的条件

void test() {
    func(10);
}
</code></pre>
<h3 id="函数重载的原理"><a href="#函数重载的原理" class="headerlink" title="函数重载的原理"></a>函数重载的原理</h3><p>​        编译器为了实现重载，会用不同的参数来修饰不同的函数名，比如<code>void func();</code> 编译器可能会将函数名修饰成<code>_func</code>，当编译器碰到<code>void func(int x);</code>编译器可能会将函数名修饰为<code>_func_int</code>，当编译器遇到<code>void func(int x, char c);</code>编译器可能会将函数名修改为<code>_func_int_char</code>。这个可能字眼是因为不同的编译器有不同的规则</p>
<h3 id="extern-C"><a href="#extern-C" class="headerlink" title="extern C"></a><code>extern C</code></h3><p>在<code>C++</code>中函数可以重载，在编译器会将函数名称偷偷改变，但是如果想调用<code>C</code>语言的方法时，也会将函数名改变，但是<code>C</code>中是没有重载的，所以编译会出错。这时使用<code>extern</code>可以将函数以<code>C</code>语言方式做链接。</p>
<pre><code class="lang-cpp">extern &quot;C&quot; void show();
</code></pre>
<p>也可以在<code>C</code>的头文件中加上</p>
<pre><code class="lang-cpp">#ifdef __cplusplus
extern &quot;C&quot;{
#endif
void show();
#ifdef __cplusplus
}
#endif
</code></pre>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>​        封装就是将现实中的具体的事物抽象化，把其具有的属性和操作合成一个整体，封装到一个类中。</p>
<p>​        <code>C</code>语言使用<code>struct</code>来进行封装，但是在<code>C</code>语言中的<code>struct</code>不能写成员函数，属性和行为是分离的，类型检测不够，写起来比较麻烦。</p>
<p>​        <code>C++</code> 中的封装，严格类型转换检测，让属性和行为绑定到一起。属性和行为作为一个整体来表示生活中的事物。<code>C++</code>中控制权限 <code>public</code>公共权限、<code>private</code>私有权限、<code>protect</code>保护权限。</p>
<p>​        在<code>C++</code>中<code>struct</code>和<code>class</code>是一个意思，唯一的不同是默认权限，<code>struct</code>是<code>public</code>，但是<code>class</code>的默认权限是<code>private</code>。</p>
<pre><code class="lang-cpp">class Animal{
    void eat();
    // 如果不声明权限，默认权限是private
    //所谓私有权限就是私有成员（属性、函数），在类内部可以访问，类外部不可以访问
    public：
        int height;
    // 公共权限，在类内部和类外部都可以访问
    protected:
        int wight;
    // 保护权限，类内部可以访问，（当前类的子类可以访问），类外部不可以访问
}
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">关键词</th>
<th style="text-align:center">类内访问</th>
<th style="text-align:center">类外访问</th>
<th style="text-align:center">子类访问</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>public</code></td>
<td style="text-align:center">可以</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">可以</td>
</tr>
<tr>
<td style="text-align:center"><code>protect</code></td>
<td style="text-align:center">可以</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">可以</td>
</tr>
<tr>
<td style="text-align:center"><code>private</code></td>
<td style="text-align:center">可以</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">不可以</td>
</tr>
</tbody>
</table>
</div>
<h3 id="封装一个立方体类"><a href="#封装一个立方体类" class="headerlink" title="封装一个立方体类"></a>封装一个立方体类</h3><pre><code class="lang-cpp">class Cube{
public:
  void setL(int l) {m_L = l;}
  int getL() {return m_L;}
  void setW(int w) {m_W = w;}
  int getW() const{return m_W;} //成员函数加const，代表这个成员函数没有修改成员属性
  void setH(int h) {m_H = h;}
  int getH() {return m_H;}
  void getCubeS() {
    cout &lt;&lt; &quot;立方体面积为:&quot; &lt;&lt; 2 * m_L*m_W + 2 * m_W * m_H + 2 * m_L * m_H &lt;&lt; endl;
  }
  void getCubeV() {
    cout &lt;&lt; &quot;立方体体积:&quot; &lt;&lt; m_L * m_W * m_H &lt;&lt; endl;
  }
  //成员函数判断是否相等
  bool compareCubeByClass(Cube &amp; cube) {
    //...
  }

private:
  int m_L;
  int m_W;
  int m_H;
};
// 传入参数如果加了const，那么只能调用const方法
bool compareCube(Cube &amp; cub1, Cube &amp; cub2) {
  // ...
}
</code></pre>
<h2 id="对象的构造和析构"><a href="#对象的构造和析构" class="headerlink" title="对象的构造和析构"></a>对象的构造和析构</h2><p>构造函数没有返回值，没有void，类名相同，可以发生重载，可以有参数</p>
<p>析构函数写法，与类名相同，类名前面加上一个符号 ~ ,也没有返回值，不写void，不可以有参数（不能发生重载）</p>
<pre><code class="lang-cpp">class Person {
public:
// 构造函数写法，与类名相同，没有返回值，可以发生重载（可以有参数）
// 构造函数由编译器自动调用，而不是手动，而且只会调用一次
  Person() {
    cout &lt;&lt; &quot;构造函数&quot; &lt;&lt; endl;
  }
// 析构函数写法，与类名相同，类名前面加上一个符号 ~ ,也没有返回值，不写void，不可以有参数（不能发生重载）
// 自动调用，只会调用一次
  ~Person(){
    cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;
  }
};

void test() {
  Person p1;
  //默认调用构造和析构，是系统提供的两个空函数
}
</code></pre>
<h3 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h3><p><strong>按照参数进行分类</strong> 分为无参构造函数，有参构造函数</p>
<p><strong>按照类型进行分类</strong> 分为普通构造函数，拷贝构造函数</p>
<p><strong>无参构造写法和调用</strong> </p>
<ul>
<li><code>Person p1;</code> 注意不能写成<code>Person p1()</code>, 因为编译器认为这个是函数声明</li>
</ul>
<p><strong>有参构造写法和调用</strong> </p>
<ul>
<li><code>Person p2(10)或者 Person p2 = Person(10)</code></li>
<li><code>Person(10)</code>匿名对象，执行当前行后就会释放这个对象</li>
</ul>
<p><strong>拷贝构造函数</strong></p>
<ul>
<li><code>Person(const Person &amp;p)</code></li>
<li><code>Person p1(p2)</code> 或者 <code>Person p1 = Person(p2)</code></li>
<li><p>不能用拷贝构造函数初始化匿名对象</p>
<ul>
<li>如果写成 <code>Person (p1)</code> 这种写法等价于 <code>Person p1</code></li>
<li>写到右值可以做拷贝构造函数</li>
</ul>
</li>
<li><p><code>Person p = 100</code> ,隐式类型转换，相当于调用 <code>Person=Person(100)</code></p>
</li>
</ul>
<pre><code class="lang-cpp">class Person {
public: // 构造和析构必须写在public下
  Person() { // 默认 无参构造函数
    cout &lt;&lt; &quot;构造&quot;;
  }
  Person(int a) { //有参构造函数 
    cout &lt;&lt; a &lt;&lt; endl;
  }
  Person(const Person&amp; p) { // 拷贝函数
    cout &lt;&lt; &quot;拷贝函数&quot; &lt;&lt; endl;
  }
  ~Person() {
    cout &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl;
  }
};

int main() {
  Person p3; //默认构造函数不加(),加（），编译器认为这是函数的声明
  Person(100); // 叫匿名对象，匿名对象特定，如果编译器发现了对象是匿名对象，那么这行执行完，就执行析构函数
  Person p1 = Person(100); // 这时声明了一个匿名对象并将其命名为p1
  Person(p1); // 不能用拷贝构造来初始化匿名对象
  Person p4 = Person(p3); //如果写成左值，编译器认为你写Person p4,对象的声明，如果写成右值，那么可以
  Person p6 = 100; //相当于调用了Person p7 = Person(100)， 隐式类型转换
  return 0;
}
</code></pre>
<h3 id="拷贝构造调用的时机"><a href="#拷贝构造调用的时机" class="headerlink" title="拷贝构造调用的时机"></a>拷贝构造调用的时机</h3><ul>
<li><p>用已经创建好的对象来初始化新的对象</p>
</li>
<li><p>以值传递的方式给函数参数传值</p>
<pre><code class="lang-cpp">void dowork(Person p1) {}// Person p1 = Person(p)
</code></pre>
</li>
<li><p>以值的方式返回局部对象</p>
<pre><code class="lang-cpp">void dowork2() {
    Person p1;
    return p1;
}
void test() {
    Person p = dowork2();
}
</code></pre>
</li>
</ul>
<h3 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h3><p>系统默认给一个类提供3个函数，默认构造、拷贝构造、析构函数</p>
<ul>
<li>当提供了有参构造函数，那么系统就不会给我们提供默认构造函数，但是系统还会提供默认拷贝构造函数</li>
<li>当我们提供了 拷贝构造，那么系统就不会提供其他构造了</li>
</ul>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>类在进行指针类型的拷贝时，浅拷贝只是简单的复制堆区地址，会导致重复释放内存的异常，而深拷贝是重新开辟一片内存空间。</p>
<pre><code class="lang-cpp">Person(const Person &amp;p) {
    m_age = p.m_age;
    m_name = (char*)malloc(strlen(p.m_name)+1);
    strcpy(n_name, p.m_name)
}
//析构函数
~Person(){
    if(m_name != NULL) {
        free(m_name);
        m_name = NULL;
    }
}
</code></pre>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>构造函数后面 +: 属性(参数),属性(参数)  …</p>
<pre><code class="lang-cpp">//利用初始化列表初始化数据
Person(int a,int  b,int c): m_a(a), m_b(b), m_c(c) {}
</code></pre>
<h3 id="类对象作为成员"><a href="#类对象作为成员" class="headerlink" title="类对象作为成员"></a>类对象作为成员</h3><p>构造时，类中的类成员先执行构造函数，类自身在执行构造。析构相反</p>
<h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a><code>explicit</code></h3><p>防止隐式类型转换</p>
<h2 id="new-和delete"><a href="#new-和delete" class="headerlink" title="new 和delete"></a><code>new</code> 和<code>delete</code></h2><ul>
<li><code>new</code>在堆区开辟空间</li>
<li>所有<code>new</code>出来的对象，都会返回该类型的指针，<code>malloc</code>返回<code>void *</code>使用时需要强转</li>
<li><code>malloc</code>不会调用构造函数，<code>new</code>会调用</li>
<li><code>new</code>是运算符，<code>malloc</code>是系统的一个函数</li>
<li><code>delete</code>也是运算符，配合<code>new</code>使用，<code>malloc</code>与<code>free</code>配合使用</li>
<li>使用<code>void *</code>来接收<code>new</code>出来的指针，会出现释放问题</li>
<li><code>new</code>会调用默认构造函数</li>
<li><code>new</code>申请内存是无需指定内存块大小，<code>malloc</code>需要</li>
</ul>
<pre><code class="lang-cpp">Person *pa = new Person[10];
delete [] pa;
// new 数组时需要有默认构造函数
// delete 数组时需要加[]
// new 的时候加[], 那么delete时加上，new的时候不加，那么delete时也不加
</code></pre>]]></content>
      <categories>
        <category>C++ 学习</category>
      </categories>
      <tags>
        <tag>C++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记(一)</title>
    <url>//b34cf332/</url>
    <content><![CDATA[<h1 id="C-学习笔记（一）"><a href="#C-学习笔记（一）" class="headerlink" title="C++ 学习笔记（一）"></a>C++ 学习笔记（一）</h1><h2 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h2><p>作用域运算符  <code>::</code>全局作用域</p>
<pre><code class="lang-cpp">int a = 200;
void test() {
    int a = 100;
    cout &lt;&lt; a &lt;&lt; endl; // 输出 100
    cout &lt;&lt; ::a &lt;&lt; endl; //输出200
    std::cout &lt;&lt; &quot;nihao&quot;; //::前面加std则是说明cout是std作用域下的
}
</code></pre>
<h2 id="namespace的使用"><a href="#namespace的使用" class="headerlink" title="namespace的使用"></a><code>namespace</code>的使用</h2><p><code>namespace</code>命名空间主要用于解决命名冲突</p>
<ul>
<li><p>命名空间下可以放函数、变量、结构体、类</p>
</li>
<li><p>命名空间必须定义在全局作用域下</p>
</li>
<li>命名空间可以检讨命名空间</li>
<li>命名空间是开放的，可以随时往原先的命名空间添加内容</li>
<li>一个命名空间分开写会自动合并</li>
<li>命名空间可以匿名，匿名命名空间内的变量相当于<code>static</code></li>
<li>命名空间可以起别名</li>
</ul>
<h2 id="using-声明和using-编译"><a href="#using-声明和using-编译" class="headerlink" title="using 声明和using 编译"></a><code>using</code> 声明和<code>using</code> 编译</h2><h3 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a><code>using</code> 声明</h3><p>使用<code>using</code>声明时要避免二义性问题，</p>
<pre><code class="lang-cpp">namespace KG{
    int sunwukongId = 10;
}
void test() {
    int sumwukongId = 20;
    using KG::sunwukongId;
    // 写了using 声明后，说明以后的所有sunwukongId都是KG下的，
    // 但是编译器又有就近原则，这就造成了二义性
    cout &lt;&lt; sunwukongId &lt;&lt; endl;
}
</code></pre>
<h3 id="using-编译"><a href="#using-编译" class="headerlink" title="using 编译"></a><code>using</code> 编译</h3><pre><code class="lang-cpp">void test2() {
    int sunwukongId = 20;
    using namespace KG; //打开命名空间KG，可以执行
    cout &lt;&lt; sunwukongId &lt;&lt; endl;
}
</code></pre>
<h2 id="C-对C的增强"><a href="#C-对C的增强" class="headerlink" title="C++对C的增强"></a>C++对C的增强</h2><h3 id="全局变量检测增强"><a href="#全局变量检测增强" class="headerlink" title="全局变量检测增强"></a>全局变量检测增强</h3><pre><code class="lang-cpp">//全局变量中
int a;
int a = 10;
//在C语言中可以通过编译
//在C++中不能通过编译
</code></pre>
<h3 id="函数检测增强"><a href="#函数检测增强" class="headerlink" title="函数检测增强"></a>函数检测增强</h3><pre><code class="lang-cpp">// 函数 参数类型增强
int getRecS(w, h) {
    // 无返回值可以通过C编译不能通过C++编译
}
// 在C中可以通过编译
// 在C++中不可以通过编译

//参数检测增强
void test02() {
    getRecS(10, 10, 10)；
}
</code></pre>
<h3 id="类型转换检测增强"><a href="#类型转换检测增强" class="headerlink" title="类型转换检测增强"></a>类型转换检测增强</h3><pre><code class="lang-cpp">void test03() {
    char *p = malloc(sizeof(64)); //malloc返回值是void*
}
// C可以通过编译，因为C认为void*是一个万能指针，可以转换成char*，
// 而C++不行，C++ 版本须为
// char *p = (char*)malloc(sizeof(64));
</code></pre>
<h3 id="struct增强"><a href="#struct增强" class="headerlink" title="struct增强"></a><code>struct</code>增强</h3><pre><code class="lang-cpp">struct Person{
    int m_Age;
    void plusAge();
    // C中struct不能加函数，C++可以
}
void test04() {
    struct Person p1; 
    // C语言必须加上struct
}
</code></pre>
<h3 id="bool类型增强"><a href="#bool类型增强" class="headerlink" title="bool类型增强"></a><code>bool</code>类型增强</h3><pre><code class="lang-cpp">// C中没有bool类型，在C++中bool类型 非0的值都是1
</code></pre>
<h3 id="三目运算符增强"><a href="#三目运算符增强" class="headerlink" title="三目运算符增强"></a>三目运算符增强</h3><pre><code class="lang-cpp">void test05() {
    int a = 10;
    int b = 20;
    printf(&quot;%d\n&quot;, a &gt; b ? a : b);
    a &gt; b ? a : b = 100;
    // 三目运算符，C语言中返回值，C++返回的是变量
    // C语言模仿C++写法
    // *(a &gt; b ? &amp;a : &amp;b) = 100
}
</code></pre>
<h3 id="const增强"><a href="#const增强" class="headerlink" title="const增强"></a><code>const</code>增强</h3><pre><code class="lang-cpp">const int m_A = 10; //全局const，在C和C++中都不能修改
void test07() {
   const int m_B = 20; //C中伪常量，C++中真常量
    int *p = (int*)&amp;m_B;
    printf(&quot;%d\n&quot;, *p);
    // 在C中const的作用仅仅是不允许修改，但是可以通过指针来修改
    // 在C++中通过指针修改的仅仅是*p, 而m_B并没有变
    // int arr[m_B] 在C中不能来定义数组，在C++中可以
}
</code></pre>
<ul>
<li><p><code>C</code>语言中，<code>const</code>修饰的变量，是伪常量，编译器是会分配内存的，只要分配内存就可以更改</p>
</li>
<li><p><code>C++</code>中，<code>const</code>不会分配内存，在<code>C++</code>中<code>int *p = (int*)&amp;m_B</code>的<code>*p</code>指向的是编译器临时开辟的一块内存空间</p>
</li>
<li><p><code>const</code>在<code>C</code>中默认是外部外部链接，在其他文件中使用<code>extern</code>可以找到变量，而在<code>C++</code>中则是默认内部链接</p>
</li>
<li><p><code>const</code>分配内存，取地址会分配临时内存，使用<code>extern</code>时编译器也会给<code>const</code>变量分配内存，用普通变量初始化<code>const</code>变量也会给<code>const</code>分配内存</p>
</li>
</ul>
<pre><code class="lang-cpp">int a = 10;
const int b = a; //会分配内存
</code></pre>
<ul>
<li>自定义数据类型，加<code>const</code>也会分配内存</li>
</ul>
<pre><code class="lang-cpp">struct Person{
    string m_Name;
    int m_Age;
}
void test() {
    const Person p1; // 分配了内存
    Person *p = (Person*)&amp;p1;
    p-&gt;m_Name = &quot;abc&quot;;
    (*p).m_Age = 18;
}
</code></pre>
<p><code>const</code>和<code>define</code>区别总结</p>
<pre><code class="lang-shell">1. const 有类型，可进行编译器类型安全检查，#define五类性，不可进行检查
2. const 有作用域，而#define 不重视作用域，默认定义处到文件结尾，如果定义在指定作用域下有效的常量，那么#define就 不能用，#define可以用undef 来结束作用周期
</code></pre>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用是<code>C++</code>对<code>C</code>的重要扩充。在<code>C/C++</code>中指针的作用基本都是一样的，但是<code>C++</code>增加了另一种给函数传递地址的途径，这就是按引用传递，他也存在与其他一些编程语言中，并不是<code>C++</code>的发明。</p>
<ul>
<li>变量名实质上是一段连续内存的别名，是一个标号（门牌号）</li>
<li>程序中通过变量来申请并命名内存空间</li>
<li>通过变量的名字可以使用存储空间</li>
</ul>
<pre><code class="lang-cpp">int a = 10;
int &amp;b = a;
b = 200;//修改b时，a也会修改
</code></pre>
<h3 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h3><pre><code class="lang-cpp">引用使用格式：type &amp;别名=原名
</code></pre>
<ul>
<li>引用 就是起别名，这里<code>a</code>的<code>b</code>都指向同一片地址空间，<code>&amp;</code>写到左侧叫引用，写到右侧是取地址。</li>
<li>引用必须初始化，引用初始化后不可以修改</li>
</ul>
<pre><code class="lang-cpp">void test() {
    //int &amp;a;//编译不通过
    int  a = 10;
    int &amp;b = a; //引用初始化后不可以修改
    int c = 20;
    b = c;//这里是把c的值赋给b，而不是b引用c，初始化后不可以修改
}
</code></pre>
<ul>
<li>对数组建立引用</li>
</ul>
<pre><code class="lang-cpp">void test() {
    int arr[10];
    for (int i = 0; i &lt; 10; i ++)
        arr[i] = i;
    int (&amp;parr[i])[10] =  arr;
    for (int i = 0; i &lt; 10; i ++) {
        cout &lt;&lt; parr[i];
    }
}
</code></pre>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><pre><code class="lang-cpp">// 值传递，直接传递a，b的值，不更改a与b的值
void swap1(int a, int b){ 
    int tmp = a;
    a = b;
    b = tmp;
}
// 指针传递，传递a，b的指针，更改a，b的值
void swap2(int *a, int *b) { 
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
//引用传递，类似传递地址，相当于int &amp;a = a，可以通过引用改变a，b的值
void swap3(int &amp;a, int &amp;b) { 
    int tmp = a;
    a = b;
    b = tmp;
}
void test() {
    int a = 10, b = 20;
    swap1(a, b);
    swap2(&amp;a, &amp;b);
    swap3(a, b);
}
</code></pre>
<h3 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h3><ul>
<li><p>引用必需引一块合法的内存空间</p>
<pre><code class="lang-cpp">void test() {
    int &amp;a = 10;//引用必需引一块合法的内存空间
}
</code></pre>
</li>
<li><p>不要返回局部变量的引用</p>
<pre><code class="lang-cpp">int &amp;dowork() {
    int a = 10;
    return a;
}
int&amp; work2() {
    static int a = 10;
    return a;
}
void test() {
    int &amp;ret =  dowork(); // 局部引用已经销毁，数据不准确
    dowork2() = 1000; 
    // 如果函数的返回值引用，那么这个函数调用可以作为左值，
    //相当于写了a=1000
}
</code></pre>
<h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><pre><code class="lang-cpp">引用的本质在C++内部实现是一个指针常量
</code></pre>
<h3 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h3><pre><code class="lang-cpp">struct Person{
    int m_age;
}
// 通过指针给对对象分配内存
void allocat(Person **p) {
    *p = (Person *)malloc(sizeof(Person));
    (*p)-&gt;m_age = 100;
}
void test01() {
    Person *p = NULL;
    allocat(&amp;p);
}
// 利用指针引用开辟空间
void allocat(Person* &amp;p) {
    p = (Person*)malloc(sizeof(Person));
    p-&gt;m_age = 100;
}
void test02() {
    Person *p = NULL;
    allocat(p);
}
</code></pre>
</li>
</ul>
<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><pre><code class="lang-cpp">void test() {
    int  &amp;ref = 10; // 引用了不合法的内存，不可以
    const int &amp;ref = 10;
    //加入const后，编译器处理方式为
    // int tmp = 10; const int &amp;ref = tmp;
    // 常量引用ref可以通过指针来修改
    int *p = (int*)&amp;ref;
    *p = 1000;

}
</code></pre>
<p>常量引用使用场景，通常用来修饰形参</p>
<pre><code class="lang-cpp">void showValue(const int &amp;val) {
    //如果只是想展示内容，而不修改内容，那么就用const来修饰这个形参
}
</code></pre>
<p>483</p>]]></content>
      <categories>
        <category>C++ 学习</category>
      </categories>
      <tags>
        <tag>C++ 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt无法输入中文</title>
    <url>//20641ee8/</url>
    <content><![CDATA[<h2 id="安装fcitx-frontend-qt5"><a href="#安装fcitx-frontend-qt5" class="headerlink" title="安装fcitx-frontend-qt5"></a>安装<code>fcitx-frontend-qt5</code></h2><pre><code class="lang-shell">sudo apt-get install fcitx-frontend-qt51
</code></pre>
<p>查看<code>`fcitx-frontend-qt5</code>的安装目录。</p>
<pre><code class="lang-shell">dpkg -L fcitx-frontend-qt5
</code></pre>
<p>一般是这个</p>
<pre><code class="lang-shell">/usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so
</code></pre>
<h2 id="复制到安装目录"><a href="#复制到安装目录" class="headerlink" title="复制到安装目录"></a>复制到安装目录</h2><p>我安装的是<code>QT6</code></p>
<pre><code>sudo cp libfcitxplatforminputcontextplugin.so {QT安装目录}/6.0.3/gcc_64/plugins/platforminputcontexts
sudo cp libfcitxplatforminputcontextplugin.so {QT安装目录}Tools/QtCreator/lib/Qt/plugins/platforminputcontexts
</code></pre>]]></content>
      <categories>
        <category>报错处理</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>VI和VIM基本操作</title>
    <url>//a67e3062/</url>
    <content><![CDATA[<h1 id="Vi和Vim-基本操作"><a href="#Vi和Vim-基本操作" class="headerlink" title="Vi和Vim 基本操作"></a>Vi和Vim 基本操作</h1><h2 id="Vi的插入"><a href="#Vi的插入" class="headerlink" title="Vi的插入"></a>Vi的插入</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>a</code></td>
<td style="text-align:center">光标位置右边插入文字</td>
</tr>
<tr>
<td style="text-align:center"><code>i</code></td>
<td style="text-align:center">光标位置当前处插入文字</td>
</tr>
<tr>
<td style="text-align:center"><code>o</code></td>
<td style="text-align:center">光标位置下方开启新行</td>
</tr>
<tr>
<td style="text-align:center"><code>O</code></td>
<td style="text-align:center">光标位置上方开启新行</td>
</tr>
<tr>
<td style="text-align:center"><code>I</code></td>
<td style="text-align:center">光标所在行首插入文字</td>
</tr>
<tr>
<td style="text-align:center"><code>A</code></td>
<td style="text-align:center">光标所在行尾插入文字</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Vi-的退出"><a href="#Vi-的退出" class="headerlink" title="Vi 的退出"></a>Vi 的退出</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ZZ(shift+z+z)</code></td>
<td style="text-align:center">保存退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:wq</code></td>
<td style="text-align:center">保存退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:x</code></td>
<td style="text-align:center">保存退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:w filename</code></td>
<td style="text-align:center">保存在指定文件</td>
</tr>
<tr>
<td style="text-align:center"><code>:q</code></td>
<td style="text-align:center">退出，如果文件修改但没有保存，会提示无法退出</td>
</tr>
<tr>
<td style="text-align:center"><code>:q!</code></td>
<td style="text-align:center">退出，不保存</td>
</tr>
<tr>
<td style="text-align:center"><code>:!命令</code></td>
<td style="text-align:center">暂时离开<code>vi</code>，执行命令</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Vi的删除和修改功能"><a href="#Vi的删除和修改功能" class="headerlink" title="Vi的删除和修改功能"></a>Vi的删除和修改功能</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[n]x</code></td>
<td style="text-align:center">删除光标后<code>n</code>的字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[n]X</code></td>
<td style="text-align:center">删除光标前<code>n</code>的字符</td>
</tr>
<tr>
<td style="text-align:center"><code>D</code></td>
<td style="text-align:center">删除光标所在开始到此行尾的字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[n]dd</code></td>
<td style="text-align:center">删除从当前行开始的<code>n</code>行（准确来说，是剪切，剪切不粘贴即为删除）</td>
</tr>
<tr>
<td style="text-align:center"><code>[n]yy</code></td>
<td style="text-align:center">复制从当前行开始的<code>n</code>行，向下复制</td>
</tr>
<tr>
<td style="text-align:center"><code>p</code></td>
<td style="text-align:center">把粘贴板上的内容插入到当前行</td>
</tr>
<tr>
<td style="text-align:center"><code>dG</code></td>
<td style="text-align:center">删除光标所在开始到文件尾的所有字符</td>
</tr>
<tr>
<td style="text-align:center"><code>J</code></td>
<td style="text-align:center">合并两行，将光标所在行和下一行进行合并，在两行中间加入一个空格</td>
</tr>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">执行上一次的操作</td>
</tr>
<tr>
<td style="text-align:center"><code>u</code></td>
<td style="text-align:center">撤销前一个命令</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Vi的行定位功能"><a href="#Vi的行定位功能" class="headerlink" title="Vi的行定位功能"></a>Vi的行定位功能</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ctrl+f</code></td>
<td style="text-align:center">向前滚动一个屏幕</td>
</tr>
<tr>
<td style="text-align:center"><code>ctrl+b</code></td>
<td style="text-align:center">向后滚动一个屏幕</td>
</tr>
<tr>
<td style="text-align:center"><code>gg</code></td>
<td style="text-align:center">到文件第一行行首</td>
</tr>
<tr>
<td style="text-align:center"><code>G</code></td>
<td style="text-align:center">到文件最后一行行首，<code>G</code>必需大写</td>
</tr>
<tr>
<td style="text-align:center"><code>:$</code></td>
<td style="text-align:center">到文件最后一行（行首）</td>
</tr>
<tr>
<td style="text-align:center"><code>mG或mgg</code></td>
<td style="text-align:center">到指定行，<code>m</code>为目标行数</td>
</tr>
<tr>
<td style="text-align:center"><code>/内容</code></td>
<td style="text-align:center">查找指定内容</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Vi的文本查找功能"><a href="#Vi的文本查找功能" class="headerlink" title="Vi的文本查找功能"></a>Vi的文本查找功能</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>/字符串</code></td>
<td style="text-align:center">查找指定字符串</td>
</tr>
<tr>
<td style="text-align:center"><code>n</code></td>
<td style="text-align:center">寻找下一个</td>
</tr>
<tr>
<td style="text-align:center"><code>N</code></td>
<td style="text-align:center">回到前一个</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">查找上一个</td>
</tr>
<tr>
<td style="text-align:center"><code>/^字符串</code></td>
<td style="text-align:center">查找以字符串开始的行</td>
</tr>
<tr>
<td style="text-align:center"><code>/字符串$</code></td>
<td style="text-align:center">查找以字符串结尾的行</td>
</tr>
<tr>
<td style="text-align:center"><code>/a.b</code></td>
<td style="text-align:center">查找字符串<code>a</code>任意字符<code>b</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Vi的替换功能"><a href="#Vi的替换功能" class="headerlink" title="Vi的替换功能"></a>Vi的替换功能</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:center">替换当前光标字符</td>
</tr>
<tr>
<td style="text-align:center"><code>:r 文件名</code></td>
<td style="text-align:center">在光标当前位置下一行载入另一个文件</td>
</tr>
<tr>
<td style="text-align:center"><code>:s/p1/p2/g</code></td>
<td style="text-align:center">将当前行中所有<code>p1</code>均用<code>p2</code>替代</td>
</tr>
<tr>
<td style="text-align:center"><code>:g/p1/s//p2/g</code></td>
<td style="text-align:center">将文件中所有<code>p1</code>均用<code>p2</code>替代</td>
</tr>
<tr>
<td style="text-align:center"><code>:n1,n2 s/p1/p2/g</code></td>
<td style="text-align:center">将<code>n1</code>到<code>n2</code>行中所有<code>p1</code>用<code>p2</code>替代</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Vi的set指令"><a href="#Vi的set指令" class="headerlink" title="Vi的set指令"></a>Vi的<code>set</code>指令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>:set ic</code></td>
<td style="text-align:center">搜寻是忽略大小写</td>
</tr>
<tr>
<td style="text-align:center"><code>:set noic</code></td>
<td style="text-align:center">搜寻是不忽略大小写</td>
</tr>
<tr>
<td style="text-align:center"><code>:set nu</code></td>
<td style="text-align:center">显示行号</td>
</tr>
<tr>
<td style="text-align:center"><code>:set nonu</code></td>
<td style="text-align:center">不显示行号</td>
</tr>
</tbody>
</table>
</div>]]></content>
      <categories>
        <category>Linux 学习笔记</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统管理</title>
    <url>//6c72ecbc/</url>
    <content><![CDATA[<h1 id="Linux系统管理"><a href="#Linux系统管理" class="headerlink" title="Linux系统管理"></a>Linux系统管理</h1><h2 id="日历-cal"><a href="#日历-cal" class="headerlink" title="日历 cal"></a>日历 <code>cal</code></h2><p><code>cal</code>命令用户查看当前日历，<code>-y</code>显示整年日历</p>
<h2 id="显示或设置时间date"><a href="#显示或设置时间date" class="headerlink" title="显示或设置时间date"></a>显示或设置时间<code>date</code></h2><p>设置时间格式</p>
<pre><code class="lang-shell"> date [MMDDhhmm[CC]YY][.ss] + format
</code></pre>
<p><code>CC</code>为年的前两位<code>yy</code>为年的后两位，前两为的<code>mm</code>为月，后两位的<code>mm</code>为分钟，<code>dd</code>为天，<code>hh</code>为小时，<code>ss</code>为秒</p>
<h2 id="查看进程信息-ps"><a href="#查看进程信息-ps" class="headerlink" title="查看进程信息 ps"></a>查看进程信息 <code>ps</code></h2><p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元，</p>
<p><code>ps</code>命令可以查看进程的详细状况，常用选项（选项可以不加<code>-</code>）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">进程</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-a</code></td>
<td style="text-align:center">显示终端上所有进程，包括其他用户的进程</td>
</tr>
<tr>
<td style="text-align:center"><code>-u</code></td>
<td style="text-align:center">显示进程的详细状态</td>
</tr>
<tr>
<td style="text-align:center"><code>-x</code></td>
<td style="text-align:center">显示没有控制终端的进程</td>
</tr>
<tr>
<td style="text-align:center"><code>-w</code></td>
<td style="text-align:center">显示加宽，一边显示更多的信息</td>
</tr>
<tr>
<td style="text-align:center"><code>-r</code></td>
<td style="text-align:center">只显示正在运行的进程</td>
</tr>
</tbody>
</table>
</div>
<h2 id="动态显示进程-top"><a href="#动态显示进程-top" class="headerlink" title="动态显示进程 top"></a>动态显示进程 <code>top</code></h2><p><code>top</code>命令用来动态显示运行中的进程，<code>top</code>命令能够在运行后，在指定时间间隔更新显示信息，可以在使用<code>top</code>命令时加上<code>-d&lt;interval&gt;</code>来指定显示信息更新时间间隔。</p>
<p>在<code>top</code>命令执行后，可以按下按年得到对显示结果进行排序</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>M</code></td>
<td style="text-align:center">根据内存使用量来排序</td>
</tr>
<tr>
<td style="text-align:center"><code>P</code></td>
<td style="text-align:center">根据<code>CPU</code>占有率来排序</td>
</tr>
<tr>
<td style="text-align:center"><code>T</code></td>
<td style="text-align:center">根据进程运行时间的长短来排序</td>
</tr>
<tr>
<td style="text-align:center"><code>U</code></td>
<td style="text-align:center">可以根据后面输入的用户名来筛选进程</td>
</tr>
<tr>
<td style="text-align:center"><code>K</code></td>
<td style="text-align:center">可以根据后面输入的<code>PID</code>来杀死进程</td>
</tr>
</tbody>
</table>
</div>
<h2 id="结束进程-KILL"><a href="#结束进程-KILL" class="headerlink" title="结束进程 KILL"></a>结束进程 <code>KILL</code></h2><p><code>kill</code>命令指定进程号的进程，需要配合<code>ps</code>使用</p>
<pre><code class="lang-shell">kill [-signal] pid
</code></pre>
<p>信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。</p>
<h2 id="后台程序-amp-、jobs、fg"><a href="#后台程序-amp-、jobs、fg" class="headerlink" title="后台程序 &amp;、jobs、fg"></a>后台程序 <code>&amp;、jobs、fg</code></h2><ul>
<li>用户可以将一个前台执行的程序调入后台执行，方法为：<code>命令 &amp;</code></li>
<li>如果程序已经在执行，<code>ctrl+z</code>可以 将程序调入后台</li>
<li><code>jobs</code>查看后台运行程序</li>
<li><code>fg</code>编号（编号为通过<code>jobs</code>查看的编号），将后台运行程序调出到前台</li>
</ul>
<h2 id="关机重启-reboot、shutdown、init"><a href="#关机重启-reboot、shutdown、init" class="headerlink" title="关机重启 reboot、shutdown、init"></a>关机重启 <code>reboot、shutdown、init</code></h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>reboot</code></td>
<td style="text-align:center">重新启动操作系统</td>
</tr>
<tr>
<td style="text-align:center"><code>shutdown -r now</code></td>
<td style="text-align:center">重新启动操作系统，<code>shutdown</code>会给别的用户提示</td>
</tr>
<tr>
<td style="text-align:center"><code>shutdown -h now</code></td>
<td style="text-align:center">立刻关机，其中<code>now</code>相当于时间为0的状态</td>
</tr>
<tr>
<td style="text-align:center"><code>shutdown -h 20：25</code></td>
<td style="text-align:center">系统在今天<code>20：25</code>会关机</td>
</tr>
<tr>
<td style="text-align:center"><code>shutdown -h +10</code></td>
<td style="text-align:center">系统再过十分钟会自动关机</td>
</tr>
<tr>
<td style="text-align:center"><code>init 0</code></td>
<td style="text-align:center">关机</td>
</tr>
<tr>
<td style="text-align:center"><code>init 6</code></td>
<td style="text-align:center">重启</td>
</tr>
</tbody>
</table>
</div>
<h2 id="字符界面和图形界面切换"><a href="#字符界面和图形界面切换" class="headerlink" title="字符界面和图形界面切换"></a>字符界面和图形界面切换</h2><p>在<code>redhat</code>平台下，可通过命令进行切换</p>
<pre><code class="lang-shell">init 3 ： 切换到字符界面
init 5 ： 切换到图形界面
</code></pre>
<p>通过快捷键切换（适用于大部分平台）</p>
<pre><code class="lang-shell">Ctrl+Alt+F2 切换到字符界面
Ctrl+Alt+F7 切换到图形界面
</code></pre>
<h2 id="检测磁盘空间-df"><a href="#检测磁盘空间-df" class="headerlink" title="检测磁盘空间 df"></a>检测磁盘空间 <code>df</code></h2><p><code>df</code>命令用户检测文件系统的磁盘空间占用和空余情况，可以显示所有文件系统对节点和磁盘块的使用情况。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-a</code></td>
<td style="text-align:center">显示所有文件系统的磁盘使用情况</td>
</tr>
<tr>
<td style="text-align:center"><code>-m</code></td>
<td style="text-align:center">以1024字节为单位显示</td>
</tr>
<tr>
<td style="text-align:center"><code>-t &lt;fs&gt;</code></td>
<td style="text-align:center">显示各指定文件系统的磁盘空间使用情况</td>
</tr>
<tr>
<td style="text-align:center"><code>-T</code></td>
<td style="text-align:center">显示文件系统</td>
</tr>
</tbody>
</table>
</div>
<pre><code>## 格式化 `mkfs`
</code></pre><p><code>mkfs</code>命令相当于<code>DOS/WINDOWS</code>系统中的格式化命令，用户创建指定的文件系统</p>
<pre><code class="lang-shell">mkfs [选项] 设备文件名 [blocks]
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-V</code></td>
<td style="text-align:center">详细显示模式</td>
</tr>
<tr>
<td style="text-align:center"><code>-t &lt;.fs&gt;</code></td>
<td style="text-align:center">指定文件系统类型，默认值为<code>ext2</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-c</code></td>
<td style="text-align:center">在创建文件系统的同时，进行磁盘坏块检查</td>
</tr>
<tr>
<td style="text-align:center"><code>blocks</code></td>
<td style="text-align:center">文件系统块的大小</td>
</tr>
</tbody>
</table>
</div>
<h2 id="应用软件安装和卸载"><a href="#应用软件安装和卸载" class="headerlink" title="应用软件安装和卸载"></a>应用软件安装和卸载</h2><p>在<code>Linux</code>系统中，几乎所有的软件均通过<code>RPM</code>进行安装、卸载及关机等操作。</p>
<pre><code class="lang-shell">rpm [选项] [软件包名]
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-i</code></td>
<td style="text-align:center">指定安装的软件包</td>
</tr>
<tr>
<td style="text-align:center"><code>-h</code></td>
<td style="text-align:center">使用<code>#</code>显示详细的安装过程和进度</td>
</tr>
<tr>
<td style="text-align:center"><code>-v</code></td>
<td style="text-align:center">显示安装的详细信息</td>
</tr>
<tr>
<td style="text-align:center"><code>-q</code></td>
<td style="text-align:center">查询系统是否已安装指定的软件包</td>
</tr>
<tr>
<td style="text-align:center"><code>-a</code></td>
<td style="text-align:center">查看系统以安装的所有软件包</td>
</tr>
<tr>
<td style="text-align:center"><code>-e</code></td>
<td style="text-align:center">卸载软件包</td>
</tr>
<tr>
<td style="text-align:center"><code>-nodeps</code></td>
<td style="text-align:center">配合<code>-e</code>参数使用，强制卸载不检查依赖项</td>
</tr>
<tr>
<td style="text-align:center"><code>-force</code></td>
<td style="text-align:center">强制操作，如强制安装删除等</td>
</tr>
</tbody>
</table>
</div>
<h2 id="查看或配置网卡信息-ifconfig"><a href="#查看或配置网卡信息-ifconfig" class="headerlink" title="查看或配置网卡信息 ifconfig"></a>查看或配置网卡信息 <code>ifconfig</code></h2><p>如果，我们只是敲<code>ifconfig</code>，它会显示所有网卡的信息</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">显示字段</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>eh0</code></td>
<td style="text-align:center">网络接口名称</td>
</tr>
<tr>
<td style="text-align:center"><code>Link encap</code></td>
<td style="text-align:center">链路封装协议</td>
</tr>
<tr>
<td style="text-align:center"><code>Hwaddr</code></td>
<td style="text-align:center">网络接口的<code>MAC</code>地址</td>
</tr>
<tr>
<td style="text-align:center"><code>Inet addr</code></td>
<td style="text-align:center"><code>IP</code>地址</td>
</tr>
<tr>
<td style="text-align:center"><code>Bcast</code></td>
<td style="text-align:center">广播地址</td>
</tr>
<tr>
<td style="text-align:center"><code>Mask</code></td>
<td style="text-align:center">子网掩码</td>
</tr>
<tr>
<td style="text-align:center"><code>UP</code></td>
<td style="text-align:center">网络接口状态标识，<code>UP</code>已经启用，<code>DOWN</code>已经停用</td>
</tr>
<tr>
<td style="text-align:center"><code>BROADCAST</code></td>
<td style="text-align:center">广播协议，表示网络接口是否支持广播</td>
</tr>
<tr>
<td style="text-align:center"><code>RUNNING</code></td>
<td style="text-align:center">传播协议，表示网络接口是否已经开始传输分组数据</td>
</tr>
<tr>
<td style="text-align:center"><code>MULTICAST</code></td>
<td style="text-align:center">多播协议，表示网络接口是否支持多播</td>
</tr>
<tr>
<td style="text-align:center"><code>MTU,Metric</code></td>
<td style="text-align:center"><code>MTU</code>最大传输单位，单位：字节，<code>Metric</code>度量值，用于<code>RIP</code>建立</td>
</tr>
<tr>
<td style="text-align:center"><code>RX bytes</code></td>
<td style="text-align:center">接受数据字节统计</td>
</tr>
<tr>
<td style="text-align:center"><code>TX bytes</code></td>
<td style="text-align:center">发送数据字节统计</td>
</tr>
</tbody>
</table>
</div>
<h2 id="测试远程主机连通性-ping"><a href="#测试远程主机连通性-ping" class="headerlink" title="测试远程主机连通性 ping"></a>测试远程主机连通性 <code>ping</code></h2><ul>
<li><code>ping</code>通过<code>ICMP</code>协议向远程主机发送<code>ECHO_REQUEST</code>请求，期望主机回复<code>ECHO_REPLY</code>消息</li>
<li>通过<code>ping</code>命令可以检查是否与远程主机建立了<code>TCP/IP</code>连接</li>
</ul>
<h2 id="网络路由设置-route"><a href="#网络路由设置-route" class="headerlink" title="网络路由设置 route"></a>网络路由设置 <code>route</code></h2><p><code>route</code>可以增加、修改、显示路由信息</p>
<pre><code>route [-v] [-A family] add default [gw 默认网关地址] [[dev interface]]
</code></pre><h2 id="监控网络状态-netstat"><a href="#监控网络状态-netstat" class="headerlink" title="监控网络状态 netstat"></a>监控网络状态 <code>netstat</code></h2><p><code>netstat</code>命令监控网络状态，包括接口设置、<code>`IP</code>路由、各种网络协议的统计</p>]]></content>
      <categories>
        <category>Linux 学习笔记</category>
      </categories>
      <tags>
        <tag>Linux 系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户权限</title>
    <url>//e7492e71/</url>
    <content><![CDATA[<h1 id="Linux-用户权限"><a href="#Linux-用户权限" class="headerlink" title="Linux 用户权限"></a>Linux 用户权限</h1><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="查看当前用户whoami"><a href="#查看当前用户whoami" class="headerlink" title="查看当前用户whoami"></a>查看当前用户<code>whoami</code></h3><p><code>whoami</code>该命令用户查看当前系统帐号的用户名，可通过<code>cat /etc/passwd</code>查看系统用户信息。</p>
<p>由于系统管理员通常需要使用多种身份登录系统，例如通常使用普通用户登录系统，然后再以<code>su</code>命令切换到<code>root</code>身份对传统进行管理，这时就可以使用<code>whoami</code>来查看当前用户身份。</p>
<h3 id="查看登录用户-who"><a href="#查看登录用户-who" class="headerlink" title="查看登录用户 who"></a>查看登录用户 <code>who</code></h3><p><code>who</code>命令用户查看当前所有登录系统的用户信息</p>
<p>常用选项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-m</code>或<code>am I</code></td>
<td style="text-align:center">只显示运行<code>who</code>的用户名，登录终端和登录时间</td>
</tr>
<tr>
<td style="text-align:center"><code>-q</code>或<code>--count</code></td>
<td style="text-align:center">只显示用户的登录帐号和登录用户的数量</td>
</tr>
<tr>
<td style="text-align:center"><code>-u</code></td>
<td style="text-align:center">在登录时间后显示该用户最后一次操作到当前时间的时间间隔</td>
</tr>
<tr>
<td style="text-align:center"><code>-u</code>或<code>--heading</code></td>
<td style="text-align:center">显示列标题</td>
</tr>
</tbody>
</table>
</div>
<h3 id="查看登录用户-w"><a href="#查看登录用户-w" class="headerlink" title="查看登录用户 w"></a>查看登录用户 <code>w</code></h3><p><code>w</code>命令也可以查看登录当前系统的用户信息，与<code>who</code>命令相比，<code>w</code>命令的功能更强大，它不但可以显示当前有哪些用户登录到系统，还可以显示这些用户正在进行的操作，并给出更加详细和科学的统计数据。</p>
<pre><code class="lang-shell">w [选项] [用户名]
</code></pre>
<p>如果<code>w</code>命令携带用户名，则只显示指定用户的信息，否则显示当前所有登录用户的信息。</p>
<p>常用选项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-h</code></td>
<td style="text-align:center">只显示运行<code>who</code>命令的用户名、登录终端和登录时间</td>
</tr>
<tr>
<td style="text-align:center"><code>-l</code></td>
<td style="text-align:center">显示详细信息列表，此为预设值</td>
</tr>
<tr>
<td style="text-align:center"><code>-s</code></td>
<td style="text-align:center">使用短列表，不显示用户登录时间、<code>JCPU</code>和<code>PCPU</code>时间</td>
</tr>
<tr>
<td style="text-align:center"><code>-u</code></td>
<td style="text-align:center">忽略执行程序的程序，以及程序的<code>PCPU</code>时间</td>
</tr>
</tbody>
</table>
</div>
<h3 id="推出登录账户-exit"><a href="#推出登录账户-exit" class="headerlink" title="推出登录账户 exit"></a>推出登录账户 <code>exit</code></h3><ul>
<li>如果是图形界面，推出当前终端</li>
<li>如果是使用<code>ssh</code>远程登录，推出登录帐号</li>
<li>如果是切换后的登录用户，退场则返回上一个登录帐号</li>
</ul>
<h3 id="切换用户-su"><a href="#切换用户-su" class="headerlink" title="切换用户 su"></a>切换用户 <code>su</code></h3><p>可以通过<code>su</code>命令切换用户，<code>su</code>后面可以加<code>-</code>，<code>su</code>和<code>su -</code>命令不同之处在与，<code>su -</code>切换到对应的用户会将当前的工作目录自动切换到切换后用户主目录。</p>
<h3 id="添加、删除组帐号：groupadd、groupdel"><a href="#添加、删除组帐号：groupadd、groupdel" class="headerlink" title="添加、删除组帐号：groupadd、groupdel"></a>添加、删除组帐号：<code>groupadd、groupdel</code></h3><ul>
<li><p><code>groupadd</code>新建组帐号</p>
</li>
<li><p><code>groupdel</code>删除组帐号</p>
</li>
<li><p><code>cat /etc/group</code> 查看用户组</p>
<pre><code class="lang-shell">创建工作组： groupadd 组名
删除工作组： groupdel 组名
注意： 需要切换到 root用户
</code></pre>
</li>
</ul>
<h3 id="修改组-usermod"><a href="#修改组-usermod" class="headerlink" title="修改组 usermod"></a>修改组 <code>usermod</code></h3><pre><code class="lang-shell">usermod -g 用户组 用户名
</code></pre>
<pre><code class="lang-shell">修改用户所在组：usermod -g 组名 用户名
</code></pre>
<h3 id="添加用户帐号-useradd"><a href="#添加用户帐号-useradd" class="headerlink" title="添加用户帐号 useradd"></a>添加用户帐号 <code>useradd</code></h3><p>在<code>Unix/Linux</code>中添加用户帐号可以使用<code>adduser</code>或<code>useradd</code>命令，因为<code>adduser</code>命令是指向<code>useradd</code>命令的一个链接，因此，这两个命令的使用格式完全一样。</p>
<pre><code class="lang-shell">useradd [参数] 新建用户帐号
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-d &lt;dirname&gt;</code></td>
<td style="text-align:center">指定用户登录系统时的主目录，如果不使用该参数，系统自动在<code>/home</code>目录下建立与用户名同名目录为主目录</td>
</tr>
<tr>
<td style="text-align:center"><code>-m</code></td>
<td style="text-align:center">自动建立目录</td>
</tr>
<tr>
<td style="text-align:center"><code>-g</code></td>
<td style="text-align:center">指定组名称</td>
</tr>
</tbody>
</table>
</div>
<h3 id="修改文件权限-chmod"><a href="#修改文件权限-chmod" class="headerlink" title="修改文件权限 chmod"></a>修改文件权限 <code>chmod</code></h3><p><code>chmod</code>修改文件权限有两种使用格式：字母法和数字法</p>
<pre><code class="lang-shell">字母法：chmod u/g/o/a +/-/= rwx 文件
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>u/g/o/a</code></th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>u</code></td>
<td style="text-align:center"><code>user</code>表示该文件所有者</td>
</tr>
<tr>
<td style="text-align:center"><code>g</code></td>
<td style="text-align:center"><code>group</code>表示与该文件的所有者属于同一组（<code>group</code>）者，及用户组</td>
</tr>
<tr>
<td style="text-align:center"><code>o</code></td>
<td style="text-align:center"><code>other</code>表示其他以外的人</td>
</tr>
<tr>
<td style="text-align:center"><code>a</code></td>
<td style="text-align:center"><code>all</code>表示这三者皆是</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>+-=</code></th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">增加权限</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">撤销权限</td>
</tr>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center">设定权限</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>rwx</code></th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:center"><code>read</code>表示可读取，对于一个目录，如果没有<code>r</code>权限，那么就意味这不能通过<code>ls</code>查看这个目录的内容</td>
</tr>
<tr>
<td style="text-align:center"><code>w</code></td>
<td style="text-align:center"><code>wriet</code>表示可写入，对于一个目录，如果没有<code>w</code>权限，那么就意味着不能在目录下创建新文件</td>
</tr>
<tr>
<td style="text-align:center"><code>x</code></td>
<td style="text-align:center"><code>excute</code>表示可执行，对于一个目录，如果没有<code>x</code>权限，那么就意味着不能通过<code>cd</code>进入这个目录</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="lang-shell">数字法： rwx 这些权限可以用数字代替
r: 读取权限，数字代号为 4
w：写入权限，数字代号为 2
x：执行权限，数字代号为 1
chmod 741 file -R （-R 代表递归给目录加上相同的权限）
</code></pre>
<h3 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者 chown"></a>修改文件所有者 <code>chown</code></h3><pre><code class="lang-shell">chown 用户名 文件或目录名
</code></pre>
<h3 id="修改文件所属组-chgrp"><a href="#修改文件所属组-chgrp" class="headerlink" title="修改文件所属组 chgrp"></a>修改文件所属组 <code>chgrp</code></h3><pre><code class="lang-shell">chgrp 用户组名 文件或目录名
</code></pre>]]></content>
      <categories>
        <category>Linux 学习笔记</category>
      </categories>
      <tags>
        <tag>用户权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令</title>
    <url>//9da1ef6b/</url>
    <content><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><p>格式：<code>命令 选项 参数</code></p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>匹配任意多个字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td><code>[]</code></td>
<td><code>[</code>和<code>]</code>将字符组扩起来，表示可以匹配字符组中任意一个，<code>-</code>用户表示字符范围</td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>匹配<code>a、b、c</code>中任意一个</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>匹配从<code>a</code>到<code>z</code>范围内任意一个字符</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符，将通配字符转义成普通字符</td>
</tr>
</tbody>
</table>
</div>
<h2 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h2><pre><code class="lang-shell">命令 --help
man 命令
</code></pre>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tab</code></td>
<td>智能补全，如果没有重复的选项 ，自动补全，如果有重复项，按下两个<code>tab</code>，显示列表</td>
</tr>
<tr>
<td>:arrow_up: :arrow_down:</td>
<td>历史记录</td>
</tr>
</tbody>
</table>
</div>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开终端</td>
<td><code>ctrl+alt+t</code></td>
</tr>
<tr>
<td>在终端中锁定</td>
<td><code>ctrl+c</code></td>
</tr>
<tr>
<td>清屏</td>
<td><code>ctrl+l</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="查看文件-ls"><a href="#查看文件-ls" class="headerlink" title="查看文件 ls"></a>查看文件 <code>ls</code></h3><div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看文件</td>
<td><code>ls</code></td>
</tr>
<tr>
<td>查看隐藏文件</td>
<td><code>ls -a</code></td>
</tr>
<tr>
<td>查看文件详细信息</td>
<td><code>ls -l</code></td>
</tr>
<tr>
<td>配合<code>-l</code>以人性化方式显示文件大小</td>
<td><code>ls -lh</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>输出重定西会覆盖原来的内容</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>输出重定向则会追加到文件的尾部</td>
</tr>
</tbody>
</table>
</div>
<h3 id="man-功能键"><a href="#man-功能键" class="headerlink" title="man 功能键"></a><code>man</code> 功能键</h3><div class="table-container">
<table>
<thead>
<tr>
<th>功能键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>空格</td>
<td>显示手册下一屏</td>
</tr>
<tr>
<td><code>Enter</code></td>
<td>一次滚动手册页的一行</td>
</tr>
<tr>
<td><code>b</code></td>
<td>回滚一屏</td>
</tr>
<tr>
<td><code>f</code></td>
<td>前滚一屏</td>
</tr>
<tr>
<td><code>q</code></td>
<td>推出<code>man</code>命令</td>
</tr>
<tr>
<td><code>h</code></td>
<td>列出所有功能键</td>
</tr>
<tr>
<td><code>/word</code></td>
<td>搜索<code>word</code>字符串</td>
</tr>
</tbody>
</table>
</div>
<h3 id="创建目录-mkdir"><a href="#创建目录-mkdir" class="headerlink" title="创建目录 mkdir"></a>创建目录 <code>mkdir</code></h3><pre><code class="lang-shell">mkdir 目录名 -p 递归创建
</code></pre>
<p>通过<code>mkdir</code>命令可以创建一个新的目录。参数<code>-p</code>可递归创建目录。</p>
<h3 id="删除文件-rm"><a href="#删除文件-rm" class="headerlink" title="删除文件 rm"></a>删除文件 <code>rm</code></h3><pre><code class="lang-shell">rm 文件
rmdir 删除文件夹
</code></pre>
<p><code>rmkdir</code> 目录名 目录一定是空的</p>
<p>可通过<code>rm</code>删除文件或目录。使用<code>rm</code>命令要小心，因为文件删除后不能回恢复。为了放置文件误删，可以在<code>rm</code>后使用<code>-i</code>参数一逐个确认要删除的文件。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-i</code></td>
<td>已进行交互方式执行</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>强制删除，忽略不存在的文件，无需提示</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>递归地删除目录下的内容，删除文件夹是必需加此参数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="建立链接文件-ln"><a href="#建立链接文件-ln" class="headerlink" title="建立链接文件 ln"></a>建立链接文件 <code>ln</code></h3><pre><code class="lang-shell">ln 源文件 链接文件 硬链接
ln -s 源文件 链接文件 软链接
</code></pre>
<p>软链接文件不占磁盘空间，但是删除源文件会影响软链接文件</p>
<p>硬链接文件站磁盘空间，但是删除源文件不会影响硬链接文件</p>
<p>硬链接和复制的区别，无论你修改了哪一个链接之后的文件，另一个会改变，但拷贝不会</p>
<h3 id="文本搜索-grep"><a href="#文本搜索-grep" class="headerlink" title="文本搜索 grep"></a>文本搜索 <code>grep</code></h3><pre><code>grep [-选项] ’搜索内容串‘ 文件名
</code></pre><p>常见选项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-v</code></td>
<td>显示不包括匹配文本的所有行（相当与求反）</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>显示匹配行以及行号</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>忽略大小写</td>
</tr>
</tbody>
</table>
</div>
<p><code>grep</code>后的搜索规则也可以是正则表达式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^a</code></td>
<td>以<code>a</code>为起始的字符搜索文件</td>
</tr>
<tr>
<td><code>a$</code></td>
<td>以<code>a</code>为结尾的字符搜索文件</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配任意一个非换行的字符</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配任意字符（大于0的整数）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="计算文件的行数与字数-wc"><a href="#计算文件的行数与字数-wc" class="headerlink" title="计算文件的行数与字数 wc"></a>计算文件的行数与字数 <code>wc</code></h3><pre><code class="lang-shell">wc [-选项] 文件名
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-l</code></td>
<td>统计行数</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>统计字数，一个字被定义为有空白、跳格或换行的字符分隔的字符串</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>统计字节数</td>
</tr>
<tr>
<td><code>-m</code></td>
<td>统计字符数，这个标志不能与<code>-c</code>标识一起使用</td>
</tr>
</tbody>
</table>
</div>
<h3 id="文件搜索-find"><a href="#文件搜索-find" class="headerlink" title="文件搜索 find"></a>文件搜索 <code>find</code></h3><p>在特定目录下搜索符合条件的文件也可以用来搜索特定用户属主的文件</p>
<pre><code class="lang-shell">find 目录 参数 文件名（可以使用通配符）
-name 文件名
-size 大小
-perm 权限
</code></pre>
<p>常见用法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>find ./ -name test.sh</code></td>
<td>查找当前目录下所有名为<code>test.sh</code>的文件</td>
</tr>
<tr>
<td><code>find ./ -name &#39;*.sh&#39;</code></td>
<td>查找当前目录下所有后缀为<code>.sh</code>的文件</td>
</tr>
<tr>
<td><code>find ./ -name &quot;[A-Z]*&quot;</code></td>
<td>查找当前目录下所有以大写字母开头的文件</td>
</tr>
<tr>
<td><code>find /tmp -size 2M</code></td>
<td>查找在<code>/tmp</code>目录下等于<code>2M</code>的文件</td>
</tr>
<tr>
<td><code>find /tmp -size +2M</code></td>
<td>查找在<code>/tmp</code>目录下大于<code>2M</code>的文件</td>
</tr>
<tr>
<td><code>find /tmp -size -2M</code></td>
<td>查找在<code>/tmp</code>目录下小于<code>2M</code>的文件</td>
</tr>
<tr>
<td><code>find ./ -size +4k -size -5M</code></td>
<td>查找当前目录下大于<code>4k</code>小于<code>5k</code>的文件</td>
</tr>
<tr>
<td><code>find ../ -perm 0777</code></td>
<td>查找当前目录下权限为<code>777</code>的文件或目录</td>
</tr>
</tbody>
</table>
</div>
<h3 id="拷贝-cp"><a href="#拷贝-cp" class="headerlink" title="拷贝 cp"></a>拷贝 <code>cp</code></h3><p><code>cp</code>命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于<code>DOS</code>中的<code>copy</code>命令。</p>
<p>常见选项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a</code></td>
<td>该选项通常在复制目录时使用，她保留链接、文件属性，并递归的复制目录，简单而言，保持文件与原有属性。</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>删除已经存在的目标文件而不提示</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>交互式复制，在覆盖目标文件之前将给出提示要求用户确认</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>若给出的源文件是目录文件，则<code>cp</code>将递归复制该目录下的所有子目录或文件，目标文件必须为一个目录名</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>显示拷贝进度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="移动-mv"><a href="#移动-mv" class="headerlink" title="移动 mv"></a>移动 <code>mv</code></h3><p>用户可以使用<code>mv</code>命令来移动文件或目录，也可以给文件或目录重命名。</p>
<p>常用选项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-f</code></td>
<td>禁止交互式操作，如有覆盖也不会给出提示</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>确认交互方式操作，如果<code>mv</code>操作将导致对已存在目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>显示移动进度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="获取文件类型-file"><a href="#获取文件类型-file" class="headerlink" title="获取文件类型 file"></a>获取文件类型 <code>file</code></h3><p><code>linux</code>系统文件类型不是根据文件扩展名分类的，通过<code>file</code>命令可以确认文件具体类型。</p>
<h3 id="归档管理-tar"><a href="#归档管理-tar" class="headerlink" title="归档管理 tar"></a>归档管理 <code>tar</code></h3><p>计算机的数据经常需要备份，<code>tar</code>是<code>Unix/Linux</code>中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。</p>
<pre><code class="lang-shell">tar [参数] 打包文件名 文件
归档： tar -cvf 归档文件名.tar 文件1 文件2 目录1 目录2
解归档：tar -xvf 归档文件名.tar 路径
</code></pre>
<p><code>tar</code>命令很特殊，其参数前面可以使用<code>-</code>，也可以不使用</p>
<h3 id="文件压缩解压"><a href="#文件压缩解压" class="headerlink" title="文件压缩解压"></a>文件压缩解压</h3><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a><code>gzip</code></h4><ul>
<li><code>tar</code>与<code>gzip</code>命令结合使用实现文件打包、压缩。</li>
<li><code>tar</code>只负责打包文件，但不压缩，用<code>gzip</code>压缩<code>tar</code>打包后的文件，其扩展名一般用<code>xxxx.tar.gz</code></li>
</ul>
<pre><code class="lang-shell">gzip [选项] 被压缩文件
压缩： gzip 归档文件名.tar 生成一个文件 归档文件名.tar.gz 文件大小小于归档文件大小[归档文件名.tar] 不存在了
解压缩： gzip -d 归档文件名.tar.gz 生成一个文件 归档文件名.tar
</code></pre>
<pre><code>一步归档压缩：
tar -czvf 文件名.tar.gz 文件1 文件2 目录1 目录2
一步解归档压缩：
tar -xzvf 文件名.tar.gz -C 路径
</code></pre><p>常用选项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-d</code></td>
<td>解压</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>压缩所有子目录</td>
</tr>
</tbody>
</table>
</div>
<h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a><code>bzip2</code></h4><pre><code>一步归档压缩：
tar -cjvf 文件名.tar.bz2 文件1 文件2 目录1 目录2
一步解归档压缩：
tar -xjvf 文件名.tar.bz2 -C 路径
</code></pre><h4 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip,unzip"></a><code>zip,unzip</code></h4><pre><code class="lang-shell">一步归档压缩：
zip [-r] 目标文件（没有扩展名） 源文件
zip 文件名 文件1 文件2 目录1 目录2 生成一个文件为： 文件.zip
一步解归档压缩：
unzip -d 解压后目录文件 压缩文件
unzip 文件名.zip -C 路径
</code></pre>
<h3 id="查看命令位置-which"><a href="#查看命令位置-which" class="headerlink" title="查看命令位置 which"></a>查看命令位置 <code>which</code></h3><pre><code class="lang-shell">which ls
</code></pre>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>一个命令的输出可以通过管道作为另一个命令的输入。</p>]]></content>
      <categories>
        <category>Linux 学习笔记</category>
      </categories>
      <tags>
        <tag>Linux 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 目录和文件</title>
    <url>//920965dc/</url>
    <content><![CDATA[<h1 id="Linux-目录与文件"><a href="#Linux-目录与文件" class="headerlink" title="Linux 目录与文件"></a>Linux 目录与文件</h1><h2 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h2><p>[绝对路径]文件位置： </p>
<pre><code>windows: 盘符:\文件夹\文件
linux: /home/文件夹/0612/day01/a
</code></pre><p>[相对路径]当前目录所在位置0612 ./day01/a </p>
<pre><code>.代表当前目录
.. 上一级文件夹
</code></pre><h3 id="目录创建规则"><a href="#目录创建规则" class="headerlink" title="目录创建规则"></a>目录创建规则</h3><ul>
<li>长度不超过256</li>
<li>不能包含特殊字符</li>
<li>见名知意</li>
</ul>
<h2 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h2><ul>
<li><code>/</code>: 根目录，一般根目录下只存放目录，在<code>linux</code>下有且只有一个根目录。</li>
<li><code>/bin,/usr/bin</code>: 可执行二进制文件的目录，如常用的命令<code>ls、tar、mv、cat</code>等。</li>
<li><code>/boot</code>: 放置<code>linux</code>系统启动是用到的一些文件，如Linux的内核文件 <code>/boot/vmlinuz</code>，系统引导管理器:<code>/boot/grub</code>。</li>
<li><code>/dev</code>: 放置<code>linux</code>系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 <code>mount /dev/chrom/mnt</code>。</li>
<li><code>/etc</code>:系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有<code>/etc/inittab、/etc/fstab、/etc/init.d/、/etc/X11、/etc/sysconfig、/etc/xinetd.d</code>。</li>
<li><code>/home</code>:系统默认的用户家目录，新增用户帐号时，用户的家目录都存放在此目录，<code>~</code>表示当前用户的家目录，<code>~edu</code>表示用户<code>edu</code>的家目录。</li>
<li><code>/lib、/usr/lib、/usr/local/lib</code>:系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。</li>
<li><code>/lost+fount</code>:系统异常产生错误时，会将一些遗失的片段放置与此目录下。</li>
<li><code>/mnt、/media</code>:光盘默认挂载点，通常光盘挂载与<code>/mnt/chrom</code>下，也不一定，可以选择任意位置挂载。</li>
<li><code>/opt</code>:给主机额外安装软件所摆放的目录。</li>
<li><code>/proc</code>:此目录的数据都在内存中，如系统核心、外部设备、网络状态，由于数据都存放在内存中，所以不占用磁盘空间，比较重要的目录有<code>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*</code>等。</li>
<li><code>/root</code>:系统管理员<code>root</code>的家目录。</li>
<li><code>/sbin、/usr/bin、/usr/local/sbin</code>:放置系统管理员使用的可执行命令，如<code>fdisk、shutdown、mount</code>等，与<code>/bin</code>不同的是，这几个目录是给系统管理员<code>root</code>使用的命令，一般用户只能查看而不能设置和使用。</li>
<li><code>/tmp</code>: 一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要的数据不可放置在此目录下。</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>计算机中一切皆文件</p>
<pre><code>在windows中区分文件通过扩展名区分文件，在linux中通过颜色区分也可以通过命令区分 file 文件名
</code></pre><h3 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h3><ul>
<li>普通文件</li>
<li>目录文件</li>
<li><p>设备文件</p>
<ul>
<li>字符设备文件</li>
<li>块设备文件</li>
</ul>
</li>
<li><p>管道文件</p>
</li>
<li><p>链接文件</p>
</li>
</ul>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>读[r]， 写[w]，执行[x]</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">d</th>
<th style="text-align:center">rwx</th>
<th style="text-align:center">rwx</th>
<th style="text-align:center">rwx</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">目录</td>
<td style="text-align:center">文件所属用户</td>
<td style="text-align:center">文件所属组</td>
<td style="text-align:center">其他用户</td>
</tr>
</tbody>
</table>
</div>]]></content>
      <categories>
        <category>Linux 学习笔记</category>
      </categories>
      <tags>
        <tag>Linux目录文件</tag>
      </tags>
  </entry>
  <entry>
    <title>vultr+cloudflare</title>
    <url>//4e01c297/</url>
    <content><![CDATA[<h2 id="申请免费域名-cloudflare-托管域名："><a href="#申请免费域名-cloudflare-托管域名：" class="headerlink" title="申请免费域名+ cloudflare 托管域名："></a>申请免费域名+ <code>cloudflare</code> 托管域名：</h2><p><a href="https://iyideng.me/welfare/freenom-free-domain-register.html" target="_blank" rel="noopener">申请免费域名+域名托管</a></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>freenom</code> 申请到的域名设置<code>DNS</code>只需要设置<code>cloudflare</code>的解析得到的<code>dns</code>，不需要设置<code>80.80.80.80</code></p>
<p><code>cloudflare</code> 解析时使用的<code>ip</code>是<code>VPS</code>服务器的<code>ip</code></p>
<h2 id="VPS-搭建服务器"><a href="#VPS-搭建服务器" class="headerlink" title="VPS 搭建服务器"></a><code>VPS</code> 搭建服务器</h2><h3 id="搭建-Trojan-服务器"><a href="#搭建-Trojan-服务器" class="headerlink" title="搭建 Trojan 服务器"></a>搭建 <code>Trojan</code> 服务器</h3><p><a href="https://iyideng.me/black-technology/cgfw/trojan-server-building-and-using-tutorial.html" target="_blank" rel="noopener">搭建Trojan服务器</a></p>
<p><code>centos8</code>以上的不需要升级内核，内核升级可能造成服务器无法启动，</p>
<h3 id="搭建-Vless服务器（推荐）"><a href="#搭建-Vless服务器（推荐）" class="headerlink" title="搭建 Vless服务器（推荐）"></a>搭建 <code>Vless</code>服务器（推荐）</h3><p><a href="[Vless+ws+tls梯子搭建一键脚本教程 | 酉荻的博客 (luyiminggonnabeok.cn">搭建 <code>Vless</code>服务器</a>](<a href="http://luyiminggonnabeok.cn/2020/10/13/Vless-ws-tls一键脚本教程/" target="_blank" rel="noopener">http://luyiminggonnabeok.cn/2020/10/13/Vless-ws-tls一键脚本教程/</a>))</p>
<h3 id="BBR加速"><a href="#BBR加速" class="headerlink" title="BBR加速"></a><code>BBR</code>加速</h3><p><a href="https://www.haah.net/archives/4551.html" target="_blank" rel="noopener"><code>bbr</code>加速</a></p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>飞机</tag>
      </tags>
  </entry>
  <entry>
    <title>Django与mysql相连</title>
    <url>//3a7fd0d4/</url>
    <content><![CDATA[<h2 id="Django与mysql相连"><a href="#Django与mysql相连" class="headerlink" title="Django与mysql相连"></a>Django与mysql相连</h2><h3 id="Django链接数据库"><a href="#Django链接数据库" class="headerlink" title="Django链接数据库"></a>Django链接数据库</h3><p>在项目根setting.py中更改默认配置</p>
<pre><code class="lang-js">DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;test&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;: &#39;****&#39;,
        &#39;HOST&#39;: &#39;****&#39;,
        &#39;PORT&#39;: &#39;3306&#39;
    }
}
</code></pre>
<p><code>ENGINE</code> 用于特定的数据库引擎的配置，一般选项如下</p>
<pre><code class="lang-js"> django.db.backends.sqlite3
 django.db.backends.postgresql
 django.db.backends.mysql
 django.db.backends.oracle
</code></pre>
<p><code>NAME</code>:要连接的数据库名称的配置<br><code>USER</code>:配置连接数据库的用户账号<br><code>PASSWORD</code>:配置连接数据库的登录密码<br><code>HOST</code>:配置数据库所在的主机IP地址<br> <code>PORT</code>:配置连接数据库的端口号<br><code>CHARSET</code>:配置连接数据库交互数据编码格式</p>
<h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><p><code>Django</code>项目中定义模型数据，其实就是定义class类型，通过类型创建的对象来封装管理数据，一定要在这里明确关联和对应关系</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">程序</th>
<th style="text-align:center">数据库</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>class</code>类型</td>
<td style="text-align:center"><code>table</code> 表格</td>
</tr>
<tr>
<td style="text-align:center"><code>attr</code>属性</td>
<td style="text-align:center"><code>field</code>字段</td>
</tr>
<tr>
<td style="text-align:center"><code>object</code>对象</td>
<td style="text-align:center"><code>record</code>记录</td>
</tr>
</tbody>
</table>
</div>
<p>模型中的属性与数据库中的字段对应</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">对象中的属性类型定义</th>
<th style="text-align:center">表中的字段类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>AutoField()</code></td>
<td style="text-align:center"><code>auto_increment</code> 自动增长</td>
</tr>
<tr>
<td style="text-align:center"><code>BOoleanField()</code></td>
<td style="text-align:center"><code>bool</code> 布尔类型</td>
</tr>
<tr>
<td style="text-align:center"><code>NullNooleanField()</code></td>
<td style="text-align:center"><code>bool or null</code> 扩展布尔类型</td>
</tr>
<tr>
<td style="text-align:center"><code>CharField()</code></td>
<td style="text-align:center"><code>varchar</code> 字符串</td>
</tr>
<tr>
<td style="text-align:center"><code>TextField()</code></td>
<td style="text-align:center"><code>text</code> 长文本</td>
</tr>
<tr>
<td style="text-align:center"><code>IntegerField()</code></td>
<td style="text-align:center"><code>int</code> 整数</td>
</tr>
<tr>
<td style="text-align:center"><code>DecimalField()</code></td>
<td style="text-align:center"><code>double</code> 双精度</td>
</tr>
<tr>
<td style="text-align:center"><code>FloatField()</code></td>
<td style="text-align:center"><code>float</code>  单精度</td>
</tr>
<tr>
<td style="text-align:center"><code>DateField()</code></td>
<td style="text-align:center"><code>date</code> 日期</td>
</tr>
<tr>
<td style="text-align:center"><code>TimeField()</code></td>
<td style="text-align:center"><code>time</code> 时间</td>
</tr>
<tr>
<td style="text-align:center"><code>DateTimeField()</code></td>
<td style="text-align:center"><code>datetime</code> 日期时间</td>
</tr>
<tr>
<td style="text-align:center"><code>FileField()</code></td>
<td style="text-align:center"><code>blob</code> 二进制</td>
</tr>
<tr>
<td style="text-align:center"><code>ImageField()</code></td>
<td style="text-align:center"><code>bolb</code>二进制</td>
</tr>
</tbody>
</table>
</div>
<p>每个字段定义时，都有自己的一些特殊选项指定</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>null</code></td>
<td style="text-align:center">如果为<code>True</code>，将NULL空值存储到数据库中，默认<code>False</code></td>
</tr>
<tr>
<td style="text-align:center"><code>blank</code></td>
<td style="text-align:center">如果为<code>True</code>，表示该字段允许存储空值，默认<code>False</code></td>
</tr>
<tr>
<td style="text-align:center"><code>db_column</code></td>
<td style="text-align:center">字段名称，如果不指定，直接使用类型属性的名称作为字段名称</td>
</tr>
<tr>
<td style="text-align:center"><code>db_index</code></td>
<td style="text-align:center">如果设置为<code>True</code>，表示个当前字段添加索引支持</td>
</tr>
<tr>
<td style="text-align:center"><code>default</code></td>
<td style="text-align:center">给字段默认值</td>
</tr>
<tr>
<td style="text-align:center"><code>primary_key</code></td>
<td style="text-align:center">是否设置当前字段为主键</td>
</tr>
<tr>
<td style="text-align:center"><code>unique</code></td>
<td style="text-align:center">如果为<code>True</code>，该字段储存的值必须时唯一的</td>
</tr>
</tbody>
</table>
</div>
<p>在大部分项目汇总，还会涉及到多表关联</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ForeignKey</td>
<td style="text-align:center">一对一关联，该字段定义在多个一方</td>
</tr>
<tr>
<td style="text-align:center">ManToManyField</td>
<td style="text-align:center">多对多关联关系，该字段两方都需要定义</td>
</tr>
<tr>
<td style="text-align:center">OneToOneField</td>
<td style="text-align:center">一对一关联，该字段可以定义在任意一方</td>
</tr>
</tbody>
</table>
</div>
<p>项目结构</p>
<pre><code class="lang-js">├── backend
│   ├── __init__.py
│   ├── admin.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── manage.py
└── ulb_manager
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
</code></pre>
<p>在根目录的<code>setting.py</code>中添加</p>
<pre><code class="lang-js">INSTALLED_APPS = [
    ///...
    &#39;backend&#39;,
]
</code></pre>
<p>修改<code>backend/models.py</code></p>
<pre><code class="lang-js">from django.db import models


# Create your models here.
class User(models.Model):
    id = models.AutoField(primary_key = True)
    account = models.CharField(max_length=20)
    password = models.CharField(max_length=20)

    def __str__(self): # 表中每条数据显示账号
        return u&#39;account: %s&#39; % self.account


class Class(models.Model):
    id = models.AutoField(primary_key = True)
    name = models.CharField(max_length=20)
</code></pre>
<p><code>model</code>中定义两个类，代表两个表<code>User，Class</code>，</p>
<p>创建两个表</p>
<pre><code class="lang-js">python manage.py makemigrations
</code></pre>
<p>同步到<code>mysql</code></p>
<pre><code class="lang-js">python manage.py migrate
</code></pre>
<p>这时在<code>mysql</code>中可以看到新增加的表</p>
<pre><code class="lang-js">mysql&gt; show tables;
+----------------------------+
| Tables_in_test             |
+----------------------------+
| auth_group                 |
| auth_group_permissions     |
| auth_permission            |
| auth_user                  |
| auth_user_groups           |
| auth_user_user_permissions |
| backend_class              |
| backend_user               |
| django_admin_log           |
| django_content_type        |
| django_migrations          |
| django_session             |
| user                       |
+----------------------------+
</code></pre>
<h3 id="后台显示数据库"><a href="#后台显示数据库" class="headerlink" title="后台显示数据库"></a>后台显示数据库</h3><p>在<code>backend/admin.py</code>中注册模型</p>
<pre><code class="lang-py">from django.contrib import admin

from .models import *
# Register your models here.
admin.site.register(User)
admin.site.register(Class)
</code></pre>
<p>运行<code>django</code></p>
<pre><code class="lang-js">python manage.py runserver 8888
</code></pre>
<p>在<code>http://127.0.0.1:8888/admin/</code>中可以看到后台登录界面</p>
<h4 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a>创建超级用户</h4><pre><code class="lang-js">python manage.py createsuperuser
</code></pre>
<p>账号和密码都是<code>admin</code>，其他可以随便填</p>
<p>这时可以通过后台登录界面进入后台看到数据库数据</p>
<h3 id="修改-语言和时区"><a href="#修改-语言和时区" class="headerlink" title="修改 语言和时区"></a>修改 语言和时区</h3><p>在<code>根目录/setting.py</code>中修改 语言和时区</p>
<pre><code class="lang-js">LANGUAGE_CODE = &#39;zh-Hans&#39;

TIME_ZONE = &#39;Asia/Shanghai&#39;
</code></pre>
<p>后台界面可以显示中文，通过增加可以添加数据</p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>连接MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>axios与django通信</title>
    <url>//5218864/</url>
    <content><![CDATA[<h3 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h3><pre><code class="lang-js">import axios from &#39;axios&#39;
import qs from &#39;qs&#39;

export function request (config) {
  const instance = axios.create({ //实例，配置一些基础信息
    baseURL: &#39;http://192.168.0.100:8888/api/&#39;,
    timeout: 5000,
    withCredentials: true
  })

  instance.interceptors.request.use(config =&gt; { //请求拦截器
    console.log(config)
    if (config.method == &quot;POST&quot;) {
      config.data = qs.stringify(config.data) // post的数据要经过处理
    }
    return config
  }, err =&gt; {
    console.log(err)
  })

  instance.interceptors.response.use(res =&gt; {//接收拦截器
    return res.data
  }, err =&gt; {
    console.log(err)
  })

  return instance(config)
}
</code></pre>
<h3 id="具体get与post"><a href="#具体get与post" class="headerlink" title="具体get与post"></a>具体get与post</h3><pre><code class="lang-js">import { request } from &#39;./request&#39;

export function getBooks () {
  return request({
    url: &#39;books&#39;
  })
}

export function postLogin (config) {
  return request({
    method: &#39;post&#39;,
    url: &#39;books&#39;,
    data: config,
    headers: {
      &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; // 发送数据的类型
    }
  })
}
</code></pre>
<h3 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h3><pre><code class="lang-vue">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;form&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;login&quot; v-model=&quot;name&quot; /&gt;
      &lt;input type=&quot;text&quot; placeholder=&quot;pwd&quot; v-model=&quot;pwd&quot; /&gt;
      &lt;input type=&quot;submit&quot; value=&quot;登录&quot; @click=&quot;submitForm&quot; /&gt;
    &lt;/form&gt;
    &lt;!-- &lt;button @click=&quot;submitForm&quot;&gt;submit&lt;/button&gt; --&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { getBooks } from &#39;network/home&#39;
import { postLogin } from &#39;network/home&#39;

export default {
  el: &#39;#app&#39;,
  data () {
    return {
      name: &quot;1234&quot;,
      pwd: &#39;1234&#39;,
    }
  },
  created () {
    getBooks().then(res =&gt; {
      console.log(res)
      this.content = res.data
    })
  },
  methods: {
    submitForm (event) {
      console.log(this.name)
      let formData = new FormData()
      formData.append(&#39;name&#39;, this.name)
      formData.append(&#39;pwd&#39;, this.pwd)
      postLogin(formData).then(res =&gt; {
        console.log(res)
      })
    }
  }
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;
</code></pre>
<h3 id="django配置"><a href="#django配置" class="headerlink" title="django配置"></a>django配置</h3><pre><code>MIDDLEWARE = [
     &#39;django.middleware.csrf.CsrfViewMiddleware&#39;, # 注释掉csrf
]
APPEND_SLASH=False
</code></pre>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Axios通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Django + Vue 快速构建项目</title>
    <url>//b2788495/</url>
    <content><![CDATA[<h2 id="使用Vue-Django搭建项目"><a href="#使用Vue-Django搭建项目" class="headerlink" title="使用Vue+Django搭建项目"></a>使用<code>Vue+Django</code>搭建项目</h2><p><a href="https://zhuanlan.zhihu.com/p/25080236" target="_blank" rel="noopener">参考</a></p>
<h3 id="构建Django项目"><a href="#构建Django项目" class="headerlink" title="构建Django项目"></a>构建<code>Django</code>项目</h3><p><em>命令：</em></p>
<pre><code class="lang-text">django-admin startproject ulb_manager
</code></pre>
<p><em>结构：</em></p>
<pre><code class="lang-text">.
├── manage.py
└── ulb_manager
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
</code></pre>
<h2 id="进入项目根目录，创建一个-app-作为项目后端"><a href="#进入项目根目录，创建一个-app-作为项目后端" class="headerlink" title="进入项目根目录，创建一个 app 作为项目后端"></a>进入项目根目录，创建一个 <code>app</code> 作为项目后端</h2><p><em>命令：</em></p>
<pre><code class="lang-text">cd ulb_manager
python manage.py startapp backend
</code></pre>
<p>即：<code>app</code> 名叫做 <code>backend</code></p>
<p><em>结构：</em></p>
<pre><code class="lang-text">.
├── backend
│   ├── __init__.py
│   ├── admin.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── manage.py
└── ulb_manager
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
</code></pre>
<h3 id="将Vue打包的dist文件放入url-manager"><a href="#将Vue打包的dist文件放入url-manager" class="headerlink" title="将Vue打包的dist文件放入url_manager"></a>将<code>Vue</code>打包的<code>dist</code>文件放入<code>url_manager</code></h3><pre><code class="lang-text">.
├─backend
│  ├─migrations
│  └─__pycache__
├─vue-fonter
│  └─dist
│      └─static
│          ├─css
│          ├─fonts
│          ├─img
│          └─js
└─ulb_manager
    └─__pycache__
</code></pre>
<p><code>Vue-CLI3.x</code>在打包时不会生成<code>static</code>文件</p>
<p>使用<code>vue ui</code>，导入<code>Vue</code>项目，在配置/基础配置/ 修改资源目录 为<code>static</code></p>
<p>这样在进行打包就会生成<code>static</code>文件</p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1glz7x4dxvmj31bz0ovn01.jpg" alt></p>
<h3 id="使用Django的通用视图-TemplateView"><a href="#使用Django的通用视图-TemplateView" class="headerlink" title="使用Django的通用视图 TemplateView"></a>使用<code>Django</code>的通用视图 <code>TemplateView</code></h3><p>找到项目根<code>urls.py(ulb_manager/urls.py)</code>，使用通用视图创建最简单的模板控制器，访问 <code>『/』</code>时直接返回<code>index.html</code></p>
<pre><code class="lang-text">urlpatterns = [
    path(&#39;admin/&#39;, admin.site.urls),
    path(&#39;&#39;, TemplateView.as_view(template_name=&quot;index.html&quot;)),
    path(&#39;api/&#39;, include(&#39;backend.urls&#39;))
]
</code></pre>
<h3 id="配置Django项目的模板搜索路径"><a href="#配置Django项目的模板搜索路径" class="headerlink" title="配置Django项目的模板搜索路径"></a>配置<code>Django</code>项目的模板搜索路径</h3><p>上一步使用了<code>Django</code>的模板系统，所以需要配置一下模板使<code>Django</code>知道从哪里找到<code>index.html</code></p>
<p>打开 <code>settings.py (ulb_manager/settings.py)</code>，找到<code>TEMPLATES</code>配置项，修改如下:</p>
<pre><code class="lang-text">TEMPLATES = [
    {
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        # &#39;DIRS&#39;: [],
        **&#39;DIRS&#39;: [&#39;vue-fonter/dist&#39;]**,
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: {
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
        },
    },
]
</code></pre>
<p>注意这里的<code>vue-fonter</code>是<code>VueJS</code>项目目录，<code>dist</code>则是运行 <code>npm run build</code>构建出的<code>index.html</code>与静态文件夹<code>static</code> 的父级目录</p>
<p>这时启动<code>Django</code>项目，访问<code>/</code>则可以访问<code>index.html</code>，但是还有问题，静态文件都是404错误，下一步我们解决这个问题</p>
<h3 id="配置静态文件搜索路径"><a href="#配置静态文件搜索路径" class="headerlink" title="配置静态文件搜索路径"></a>配置静态文件搜索路径</h3><p>打开 <code>settings.py (ulb_manager/settings.py</code>)，找到<code>STATICFILES_DIRS</code> 配置项，配置如下:</p>
<pre><code class="lang-text"># Add for vuejs
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, &quot;vue-fonter/dist/static&quot;),
]
</code></pre>
<p>这样<code>Django</code>不仅可以将<code>/</code> 映射到<code>index.html</code>，而且还可以顺利找到静态文件</p>
<h3 id="backend-配置"><a href="#backend-配置" class="headerlink" title="backend 配置"></a><code>backend</code> 配置</h3><p>在<code>backend</code>中创建<code>urls</code></p>
<pre><code class="lang-py">from django.urls import path
from . import views

urlpatterns = [
    path(&#39;books/&#39;, view = views.books, name=&quot;books&quot;)
]
</code></pre>
<p>在<code>backend/views.py</code>中</p>
<pre><code class="lang-py">from django.shortcuts import render
from django.http.response import  JsonResponse

# Create your views here.

def books(request):
    books = [
        {&#39;id&#39;: 1, &#39;title&#39;: &quot;python&quot;, &quot;price&quot;: 89}
    ]
    return JsonResponse(books, safe=False)
</code></pre>
<p>此时访问<code>/</code>我们可以看到使用<code>Django</code>作为后端的<code>VueJS</code>前端,访问<code>/api/books</code>我们可以看到<code>json</code>数据</p>
<h3 id="解决开发时的跨域问题"><a href="#解决开发时的跨域问题" class="headerlink" title="解决开发时的跨域问题"></a>解决开发时的跨域问题</h3><p>使用<code>corsheaders</code></p>
<pre><code class="lang-js">pip install corsheaders
</code></pre>
<p>在<code>setting.py</code>中加入</p>
<pre><code class="lang-js">INSTALLED_APPS = [
    //...
    &#39;corsheaders&#39;,
]
MIDDLEWARE = [
    //......
    &#39;corsheaders.middleware.CorsMiddleware&#39;,  # 添加cors，在第三行，位置不能改
    &#39;django.middleware.common.CommonMiddleware&#39;,
]
CORS_ORIGIN_ALLOW_ALL = True
# 允许请求携带cookies
CORS_ALLOW_CREDENTIALS= True
</code></pre>
<p>以上是从网上找的解决方法，但是并没有解决问题，</p>
<p>先看一下同源的定义</p>
<pre><code>同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
</code></pre><p><code>vue</code>启动<code>server</code>是的<code>ip</code>是<code>192.168.0.100:8080</code>，<code>django</code>启动服务时的<code>ip</code>是<code>127.0.0.1:8000</code>，</p>
<p>试着修改了一下<code>django</code>的启动<code>ip</code></p>
<p>在<code>setting.py</code>中加入</p>
<pre><code class="lang-js">ALLOWED_HOSTS = [
    &#39;192.168.0.100&#39;,
    &#39;127.0.0.1&#39;,
    &#39;0.0.0.0&#39;,
    &#39;localhost&#39;,
]
</code></pre>
<p>然后启动</p>
<pre><code class="lang-js">django ./manage.py runserver 192.168.0.100:8888
</code></pre>
<p>然后启动<code>vue</code></p>
<pre><code class="lang-js">npm run serve
</code></pre>
<p>这时不在出现跨域问题 </p>
<p>成功！</p>
<h4 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h4><p>利用<code>vscode</code> 写前端<code>vue</code>，<code>pycharm</code>写<code>django</code>后端 ，调试时<code>pycharm</code>打开<code>django</code>服务，<code>vscode</code> 打开<code>vue</code>，</p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Django+Vue+Nginx+uWSGI部署</title>
    <url>//1ae14b31/</url>
    <content><![CDATA[<h2 id="Django-Vue-Nginx-uWSGI部署"><a href="#Django-Vue-Nginx-uWSGI部署" class="headerlink" title="Django+Vue+Nginx+uWSGI部署"></a><code>Django+Vue+Nginx+uWSGI</code>部署</h2><p><a href="https://blog.csdn.net/qq_41785581/article/details/102598073" target="_blank" rel="noopener">参考</a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code class="lang-js">ip:123.56.252.111
vue: dist
django: django_server

├── backend
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── __pycache__
│   │   ├── __init__.cpython-39.pyc
│   │   ├── urls.cpython-39.pyc
│   │   └── views.cpython-39.pyc
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── db.sqlite3
├── element-test
│   └── dist
│       ├── header.ico
│       ├── index.html
│       └── static
│           ├── css
│           ├── fonts
│           ├── img
│           └── js
├── manage.py
├── media
├── mysite
│   ├── asgi.py
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-39.pyc
│   │   ├── settings.cpython-39.pyc
│   │   ├── urls.cpython-39.pyc
│   │   └── wsgi.cpython-39.pyc
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── static
│   ├── admin
│   ├── css
│   ├── fonts
│   ├── img
│   └── js
├── test.py
├── uwsgi.ini
├── uwsgi.log
├── uwsgi_nginx.sock
└── uwsgi.pid
</code></pre>
<h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>在<a href="http://www.orzff.cn/7dfc688d/" target="_blank" rel="noopener">服务器配置</a>有详细介绍</p>
<h3 id="Django"><a href="#Django" class="headerlink" title="Django"></a><code>Django</code></h3><p>在<a href="http://www.orzff.cn/7dfc688d/" target="_blank" rel="noopener">服务器配置</a>有详细介绍</p>
<h3 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a><code>uWSGI</code></h3><h4 id="安装uWSGI"><a href="#安装uWSGI" class="headerlink" title="安装uWSGI"></a>安装<code>uWSGI</code></h4><pre><code class="lang-js">pip install uwsgi
</code></pre>
<h4 id="简单测试一下"><a href="#简单测试一下" class="headerlink" title="简单测试一下"></a>简单测试一下</h4><p>创建<code>test.py</code></p>
<pre><code class="lang-js"># test.py
def application(env, start_response):
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;,&#39;text/html&#39;)])
    return [b&quot;Hello World&quot;] # python3
    #return [&quot;Hello World&quot;] # python2
</code></pre>
<p>运行 <code>uWSGI</code>:</p>
<pre><code class="lang-js">uwsgi --http :8000 --wsgi-file test.py
</code></pre>
<p>选项的含义：</p>
<ul>
<li><code>http :8000</code> 使用<code>http</code> 协议，8000端口。</li>
<li><code>wsgi-file test.py</code> 使用<code>test.py</code> 作为与 <code>uWSGI</code>交互的文件。</li>
</ul>
<p>访问 <code>123.56.252.111:8000</code>，输出“Hello World”，说明该程序是这么工作的：</p>
<pre><code class="lang-mermaid">graph LR;
客户端 --http:8000--&gt; uWSGI
uWSGI --&gt; Python
</code></pre>
<h3 id="测试Django"><a href="#测试Django" class="headerlink" title="测试Django"></a>测试<code>Django</code></h3><h4 id="测试django"><a href="#测试django" class="headerlink" title="测试django"></a>测试<code>django</code></h4><p>在创建的<code>django</code>目录，执行</p>
<pre><code class="lang-js">python manage.py runserver 0.0.0.0:8000
</code></pre>
<p>先将<code>IP</code>设置下<code>ALLOWHOSTS</code>中</p>
<p>在<a href="http://www.orzff.cn/7dfc688d/" target="_blank" rel="noopener">服务器配置</a>有详细介绍</p>
<p>在浏览器输入<code>123.56.255.111:8000</code>即出现<code>django</code>欢迎界面</p>
<h4 id="测试uWSGI"><a href="#测试uWSGI" class="headerlink" title="测试uWSGI"></a>测试<code>uWSGI</code></h4><pre><code>uwsgi --http :8000 --module mysite.wsgi
</code></pre><p>在浏览器输入<code>123.56.255.111:8000</code>出现<code>Internal Server Error</code>属于正常现象，因为没有资源</p>
<pre><code class="lang-mermaid">graph LR;
客户端 --http:8000--&gt; uWSGI
uWSGI --&gt; Djano
</code></pre>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><code>Nginx</code></h3><p>安装<code>nginx</code>在<a href="http://www.orzff.cn/7dfc688d/" target="_blank" rel="noopener">服务器配置</a>有详细介绍</p>
<h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动<code>nginx</code></h4><pre><code>#centos 7
systemctl start nginx
</code></pre><p>在浏览器输入<code>123.56.255.111:80</code>出现<code>CenOS</code>或<code>Nginx</code>的欢迎界面</p>
<h4 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置<code>nginx</code></h4><p>开启这三个端口：</p>
<ul>
<li><code>80端口</code> 显示<code>Nginx</code>欢迎界面，测试<code>Nginx</code>是否能正常运行</li>
<li><code>8000端口</code> <code>Nginx</code>接收请求的端口，自行处理静态请求，动态请求则转发给<code>uWSGI</code>的8001端口处理</li>
<li><code>8001端口</code> <code>uWSGI</code>接收动态请求的端口，处理完毕后将处理结果发给<code>Nginx</code>的8000端口</li>
</ul>
<p>检查一下是否有<code>uwsgi_params</code>文件（后面的配置文件需要用到），它应该在<code>nginx</code>的目录里（<code>/etc/nginx/</code>），如果没有，可以<a href="https://github.com/nginx/nginx/blob/master/conf/uwsgi_params" target="_blank" rel="noopener">点击这里</a>下载。</p>
<p>创建<code>/etc/nginx/sites-available</code>的目录，在目录里创建<code>support_center_nginx.conf</code>配置文件进行配置：</p>
<pre><code class="lang-js"> # support_center_nginx.conf
 # the upstream component nginx needs to connect to
 upstream django {
   server 127.0.0.1:8001; # for a web port socket (we&#39;ll use this first)
 }

 # configuration of the server
 server {
       # the port your site will be served on
       listen      8000;
       # the domain name it will serve for
       server_name 123.56.252.111; # substitute your machine&#39;s IP address or FQDN
       charset     utf-8;

       # max upload size
       client_max_body_size 75M;   # adjust to taste


      # Django media
       location /media  {
         alias /root/mysite/media; # your Django project&#39;s media files - amend as required
       }

       location /static {
        alias /root/mysite/static; # your Django project&#39;s static files - amend as required
       }

        # Finally, send all non-media requests to the Django server.
       location / {
        uwsgi_pass  django;
        include     /etc/nginx/uwsgi_params; # the uwsgi_params file you installed   
      }
</code></pre>
<p>创建一个软链接(<code>/etc/nginx/sites-enabled</code>)指向它：</p>
<pre><code class="lang-js">ln -s /etc/nginx/sites-available /etc/nginx/sites-enabled
</code></pre>
<p>在<code>/etc/nginx/nginx.conf</code>中将该文件夹包含进去，使得<code>Nginx</code>启动时，能够将文件夹中配置的项目运行起来：<br><code>include /etc/nginx/sites-enabled/*.conf</code></p>
<p>注意，这个语句添加在<code>http</code>中，<code>server</code>外</p>
<pre><code class="lang-js"> http {
    server {
         listen    8888;
        # listen       [::]:80 default_server;
         server_name  _;
        # root         /usr/share/nginx/html;

         # Load configuration files for the default server block.
         include /etc/nginx/default.d/*.conf;

         location / {
           root /root/mysite/element-test/dist;
           try_files $uri $uri/ @router;
           index index.html index.htm;
         }

         location @router{
           rewrite ^.*$ /index.html last;
         }

         error_page 404 /404.html;
         location = /404.html {
         }

         error_page 500 502 503 504 /50x.html;
         location = /50x.html {
         }
     }
     include /etc/nginx/sites-enabled/*.conf;
}
</code></pre>
<h4 id="处理静态文件"><a href="#处理静态文件" class="headerlink" title="处理静态文件"></a>处理静态文件</h4><p>运行<code>Nginx</code>之前，得先把<code>Django</code>的静态文件集中到一个文件夹中（该文件夹就是<code>STATIC_ROOT</code>的值）：<br>先向<code>settings.py</code>中添加：</p>
<pre><code class="lang-python">STATIC_ROOT = &#39;/root/mysite/static&#39;
</code></pre>
<p>然后，将静态资源集中：</p>
<pre><code class="lang-bash">python manage.py collectstatic
</code></pre>
<h4 id="nginx测试"><a href="#nginx测试" class="headerlink" title="nginx测试"></a><code>nginx</code>测试</h4><pre><code class="lang-js">systemctl restart nginx
</code></pre>
<p>向<code>media</code>文件夹中放一张图<code>media.jpg</code>用于测试，</p>
<p><code>media</code>的位置在上面<code>support_center_nginx.conf</code>中的<code>location /media</code>的指定位置</p>
<p>在浏览器输入<code>123.56.255.111:8000/media/picture.png</code>出现一张图片</p>
<pre><code class="lang-mermaid">graph LR;
客户端 --http--&gt; Nginx
Nginx --uwsgi--&gt; uWSGI
uWSGI --&gt; Python
</code></pre>
<h4 id="使用-ini对uWSGI进行设置"><a href="#使用-ini对uWSGI进行设置" class="headerlink" title="使用.ini对uWSGI进行设置"></a>使用<code>.ini</code>对<code>uWSGI</code>进行设置</h4><p>创建<code>uwsgi.ini</code></p>
<pre><code class="lang-js">[uwsgi]
#  项目路径 
chdir = /root/mysite

#django的wsgi文件路径
wsgi-file = /root/mysite/wsgi.py

# 使用mmcsite.wsgi模块
module = mysite.wsgi

# 虚拟环境的路径
home = /root/Envs/Django

# 启用master
master = true

# 启动五个进程
processes = 10

# 每个进程启动30个线程
threads = 30

# 指定socket监听的地址和端口
socket = 0.0.0.0:8001

# socket权限
chmod-socket = 666

# 结束后清理环境
vacuum = true

# 日志文件
daemonize = /root/mysite/uwsgi.log

# pid文件
pidfile = /root/mysite/uwsgi.pid

# 允许用内嵌的语言启动线程，这将允许你在app程序中产生一个子线程
enable-threads = true
</code></pre>
<p>然后，启动 <code>uWSGI</code></p>
<pre><code class="lang-bash">uwsgi --ini uwsgi.ini
</code></pre>
<h3 id="转发80端口"><a href="#转发80端口" class="headerlink" title="转发80端口"></a>转发80端口</h3><p>将<code>/etc/nginx/sites-available/support_center_nginx.conf</code>重命名<code>/etc/nginx/sites-available/nginx_backend.conf</code></p>
<pre><code class="lang-ls">cd /etc/nginx/sites-available/
mv support_center_nginx.conf nginx_backend.conf`
</code></pre>
<p>新建一个文件<code>/etc/nginx/sites-available/nginx_fonter.conf</code></p>
<pre><code class="lang-js">vim nginx_fonter.conf
</code></pre>
<p>在文件中加入</p>
<pre><code class="lang-js">server {
    # 监听端口
   listen 8888;

    #ip
   server_name 123.56.252.111;

    # 编码规则
   charset utf-8;

   client_max_body_size 75M;

# 主页面内容，
# root：指向vue的dist文件
# try_files：使用vue内部的路由转发
# index：
   location / {
     root /root/mysite/element-test/dist;
     try_files $uri $uri/ @router;   
     index index.html index.htm;
   }

   location @router {
     rewrite ^.*$ /index.html last;
   }

   error_page 404 /404.html;
   location = /404.html{
   }

   error_page 500 502 503 504 /50x.html;
   location = /50x.html{
   }

 }
</code></pre>
<p>修改<code>/etc/nginx/nginx.conf</code></p>
<pre><code class="lang-js"> http {
    server {
         listen    8888;
        # listen       [::]:80 default_server;
         server_name  _;
        # root         /usr/share/nginx/html;

         # Load configuration files for the default server block.
         include /etc/nginx/default.d/*.conf;

         location / {
           proxy_set_header Host $host:$server_port;
           proxy_set_header Host $http_host;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header REMOTE-HOST $remote_addr;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
           proxy_set_header Connection &quot;&quot;;
           proxy_set_header X-Nginx-Proxy true;
           proxy_pass http://123.56.252.111:8888/;
         }

         location @router{
           rewrite ^.*$ /index.html last;
         }

         error_page 404 /404.html;
         location = /404.html {
         }

         error_page 500 502 503 504 /50x.html;
         location = /50x.html {
         }
     }
     include /etc/nginx/sites-enabled/*.conf;
}
</code></pre>
<p>简单说下这样做的目的：</p>
<p>客户的所有请求都是通<code>80</code>端口，与默认端口通信是不需要加<code>:80</code>的，<code>nginx</code>从<code>80</code>端口接收到浏览器的请求，转发到<code>8888</code>端口，<code>8888</code>接收到在<code>/etc/nginx/sites-available/fonter.conf</code>文件处理</p>
<p>后端界面客户不会主动访问所以不用转发来隐藏端口，</p>
<p><code>/etc/nginx/sites-available/fonter.conf</code> 和 <code>/etc/nginx/sites-available/nginx_backend.conf</code>，都在 <code>/etc/nginx/sites-available</code>中，通过软连接<code>/etc/nginx/sites-enabled</code>在<code>/etc/nginx/nginx.conf</code>中的<code>include /etc/nginx/sites-enabled/*.conf;</code>导入<code>nginx.conf</code>文件,与主配置文件分离</p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Vue</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器配置</title>
    <url>//7dfc688d/</url>
    <content><![CDATA[<h2 id="centos安装python3"><a href="#centos安装python3" class="headerlink" title="centos安装python3"></a><code>centos</code>安装<code>python3</code></h2><h2 id="参考-centos下安装python3详细教程"><a href="#参考-centos下安装python3详细教程" class="headerlink" title="参考 centos下安装python3详细教程"></a>参考 <a href="https://blog.csdn.net/t8116189520/article/details/81976755" target="_blank" rel="noopener">centos下安装python3详细教程</a></h2><h3 id="1-python位置"><a href="#1-python位置" class="headerlink" title="1.python位置"></a>1.python位置</h3><p>使用<code>whereis python</code>得到<code>python</code>位置</p>
<pre><code class="lang-js">[root@iz2ze3g6pyat2fqpma7zdvz django_test]# whereis python
python: /usr/bin/python /usr/bin/python.config /usr/bin/python2.7 /usr/bin/python.bak /usr/bin/python2.7-config /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz
</code></pre>
<p>得到<code>python</code>的位置在 <code>/usr/bin</code>目录</p>
<pre><code class="lang-js">[root@iz2ze3g6pyat2fqpma7zdvz ~]# cd /usr/bin
[root@iz2ze3g6pyat2fqpma7zdvz bin]# ll python*
lrwxrwxrwx 1 root root   32 Dec 22 19:40 python -&gt; /usr/local/python3/bin/python3.9
lrwxrwxrwx 1 root root    9 Dec 22 18:30 python2 -&gt; python2.7
-rwxr-xr-x 1 root root 7144 Nov 17 06:23 python2.7
-rwxr-xr-x 1 root root 1835 Nov 17 06:23 python2.7-config
lrwxrwxrwx 1 root root   16 Dec 22 18:30 python2-config -&gt; python2.7-config
lrwxrwxrwx 1 root root   32 Dec 23 18:43 python3 -&gt; /usr/local/python3/bin/python3.9
lrwxrwxrwx 1 root root    7 Dec 22 18:30 python.bak -&gt; python2
lrwxrwxrwx 1 root root   39 Dec 22 19:36 python.config -&gt; /usr/local/python3/bin/python3.9-config
lrwxrwxrwx 1 root root   14 Dec 22 18:30 python-config.bak -&gt; python2-config

python_django:
total 20
drwxr-xr-x 2 root root 4096 Dec 23 15:33 bin
drwxr-xr-x 2 root root 4096 Dec 23 15:33 include
drwxr-xr-x 3 root root 4096 Dec 23 15:33 lib
drwxr-xr-x 3 root root 4096 Dec 23 15:33 lib64
-rw-r--r-- 1 root root  201 Dec 23 15:33 pyvenv.cfg
</code></pre>
<p>进入<code>/usr/bin</code>目录使用<code>ll python*</code>我们可以得到<code>python</code>的各种版本</p>
<p><code>-&gt;</code>是软连接，意味这个文件是后面文件的软链接，这个<code>python</code>也可以看成命令</p>
<h3 id="2-python3的依赖"><a href="#2-python3的依赖" class="headerlink" title="2 python3的依赖"></a>2 <code>python3</code>的依赖</h3><pre><code class="lang-js">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make
</code></pre>
<h3 id="3-安装pip"><a href="#3-安装pip" class="headerlink" title="3 安装pip"></a>3 安装<code>pip</code></h3><p>centos7没有安装pip</p>
<pre><code class="lang-js">#运行这个命令添加epel扩展源
yum -y install epel-release

#安装pip
yum install python-pip
</code></pre>
<h3 id="4-用pip安装wget"><a href="#4-用pip安装wget" class="headerlink" title="4 用pip安装wget"></a>4 用<code>pip</code>安装<code>wget</code></h3><pre><code class="lang-js">pip install wget
</code></pre>
<h3 id="5-用wget下载python3"><a href="#5-用wget下载python3" class="headerlink" title="5 用wget下载python3"></a>5 用<code>wget</code>下载<code>python3</code></h3><p>在<a href="https://www.python.org/downloads/source/" target="_blank" rel="noopener">官网</a>找到想要的版本链接</p>
<pre><code class="lang-js">wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz
</code></pre>
<h3 id="6-编译python3源码包"><a href="#6-编译python3源码包" class="headerlink" title="6 编译python3源码包"></a>6 编译<code>python3</code>源码包</h3><pre><code class="lang-js">#解压
xz -d Python-3.6.4.tar.xz
tar -xf Python-3.6.4.tar
#进入解压后的目录，依次执行下面命令进行手动编译
cd Python-3.6.4
./configure prefix=/usr/local/python3
make &amp;&amp; make install
# 如果出现can&#39;t decompress data; zlib not available这个错误，则需要安装相关库
#安装依赖zlib、zlib-devel
yum install zlib zlib
yum install zlib zlib-devel
</code></pre>
<h3 id="7-添加软连接"><a href="#7-添加软连接" class="headerlink" title="7 添加软连接"></a>7 添加软连接</h3><pre><code class="lang-js">#将原来的链接备份
mv /usr/bin/python /usr/bin/python.bak

#添加python3的软链接
ln -s /usr/local/python3/bin/python3.6 /usr/bin/python

#测试是否安装成功了
python -V
</code></pre>
<p>如果本身没有python3的软链接，可以再</p>
<pre><code class="lang-js">ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3
</code></pre>
<h3 id="8-更改yum配置"><a href="#8-更改yum配置" class="headerlink" title="8 更改yum配置"></a>8 更改<code>yum</code>配置</h3><p>因为<code>yum</code>使用<code>python2</code>，所以需要更改一个<code>yum</code>的配置</p>
<pre><code class="lang-js">vi /usr/bin/yum
把#! /usr/bin/python修改为#! /usr/bin/python2

vi /usr/libexec/urlgrabber-ext-down
把#! /usr/bin/python 修改为#! /usr/bin/python2
</code></pre>
<h2 id="virtualenv和virtualenvwrapper"><a href="#virtualenv和virtualenvwrapper" class="headerlink" title="virtualenv和virtualenvwrapper"></a><code>virtualenv</code>和<code>virtualenvwrapper</code></h2><p><code>python</code>虚拟环境</p>
<p>简单点说<code>python</code>的虚拟环境就是给每个项目一个独立的<code>python</code>配置，各个项目之间的配置不影响，</p>
<h3 id="1-下载virtualenv"><a href="#1-下载virtualenv" class="headerlink" title="1 下载virtualenv"></a>1 下载<code>virtualenv</code></h3><pre><code class="lang-js">pip install virtualenv
</code></pre>
<h3 id="2-创建新项目"><a href="#2-创建新项目" class="headerlink" title="2 创建新项目"></a>2 创建新项目</h3><pre><code class="lang-js">virtualenv env
</code></pre>
<h3 id="3-使用虚拟环境"><a href="#3-使用虚拟环境" class="headerlink" title="3 使用虚拟环境"></a>3 使用虚拟环境</h3><pre><code class="lang-js">source env/bin/activate
</code></pre>
<h3 id="4-退出虚拟环境"><a href="#4-退出虚拟环境" class="headerlink" title="4 退出虚拟环境"></a>4 退出虚拟环境</h3><pre><code class="lang-js">deactivate
</code></pre>
<h3 id="5-virtualenvwrapper安装"><a href="#5-virtualenvwrapper安装" class="headerlink" title="5 virtualenvwrapper安装"></a>5 <code>virtualenvwrapper</code>安装</h3><p><code>virtualenvwrapper</code> 可以对虚拟环境进行集中管理</p>
<pre><code class="lang-js">pip install virtualenvwrapper
</code></pre>
<h3 id="6-添加-bashrc"><a href="#6-添加-bashrc" class="headerlink" title="6 添加~/.bashrc"></a>6 添加<code>~/.bashrc</code></h3><p>在<code>~/.bashrc</code>添加</p>
<pre><code class="lang-js">export WORKON_HOME=~/Envs
source /usr/local/bin/virtualenvwrapper.sh
</code></pre>
<p>读入配置文件</p>
<pre><code class="lang-js">source ~/.bashrc　　　　#读入配置文件，立即生效
</code></pre>
<h3 id="7-virtualenvwrapper基本使用"><a href="#7-virtualenvwrapper基本使用" class="headerlink" title="7 virtualenvwrapper基本使用"></a>7 <code>virtualenvwrapper</code>基本使用</h3><ul>
<li>创建虚拟环境 <code>mkvirtualenv</code></li>
</ul>
<pre><code class="lang-js">mkvirtualenv venv
</code></pre>
<p>　这样会在<code>WORKON_HOME</code>变量指定的目录下新建名为<code>venv</code>的虚拟环境。</p>
<ul>
<li><p>指定python版本</p>
<p><code>--python</code>指定<code>python</code>解释器</p>
</li>
</ul>
<pre><code>mkvirtualenv --python=/usr/local/python3.5.3/bin/python venv
</code></pre><ul>
<li>查看当前虚拟环境目录</li>
</ul>
<pre><code class="lang-js">workon
</code></pre>
<ul>
<li>切换到虚拟环境</li>
</ul>
<pre><code class="lang-js">workon xxx
</code></pre>
<ul>
<li>退出虚拟环境</li>
</ul>
<pre><code class="lang-js">deactivate
</code></pre>
<ul>
<li>删除虚拟环境</li>
</ul>
<pre><code class="lang-js">rmvirtualenv xxx
</code></pre>
<h3 id="8-出错处理"><a href="#8-出错处理" class="headerlink" title="8 出错处理"></a>8 出错处理</h3><p>出现 <code>ModuleNotFoundError: No module named &#39;_ctypes&#39;</code></p>
<ul>
<li>安装<code>libffi-devel</code></li>
</ul>
<pre><code class="lang-js">yum install libffi-devel -y
</code></pre>
<ul>
<li>重装<code>python</code></li>
<li>使用<code>make &amp;&amp; make install</code></li>
</ul>
<h2 id="django"><a href="#django" class="headerlink" title="django"></a><code>django</code></h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1 下载"></a>1 下载</h3><p>使用<code>pip install django</code></p>
<h3 id="2-创建django项目"><a href="#2-创建django项目" class="headerlink" title="2 创建django项目"></a>2 创建django项目</h3><p><code>django-admin startproject xxx</code></p>
<h3 id="3-启动django"><a href="#3-启动django" class="headerlink" title="3 启动django"></a>3 启动django</h3><pre><code class="lang-js">python manage.py runserver 0.0.0.0:80
</code></pre>
<h3 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4 配置文件"></a>4 配置文件</h3><p>进入setting.py文件</p>
<p>在allowHost中添加自己的ip</p>
<pre><code class="lang-js"> ALLOWED_HOSTS = [
    &#39;123.56.252.111&#39;,
    &#39;localhost&#39;,
   &#39;0.0.0.0:8000&#39;,                                                                           &#39;127.0.0.1&#39;
      ]
</code></pre>
<p>这样在运行后就可以用<code>http://123.56.252.111:8000/</code>来访问</p>
<h3 id="5-报错处理"><a href="#5-报错处理" class="headerlink" title="5 报错处理"></a>5 报错处理</h3><p><a href="https://blog.csdn.net/weixin_44110998/article/details/103499213" target="_blank" rel="noopener">参考</a></p>
<p>出现</p>
<pre><code class="lang-js">django.core.exceptions.ImproperlyConfigured: SQLite 3.8.3 or later is required (found 3.7.17).
</code></pre>
<ul>
<li><p>在<a href="https://www.sqlite.org/download.html" target="_blank" rel="noopener">官网</a>找到想要版本的链接</p>
</li>
<li><p>使用<code>wget</code>下载</p>
</li>
</ul>
<pre><code class="lang-js">#链接最好重新获取，否则可能不是最新版本
wget https://www.sqlite.org/2019/sqlite-autoconf-3300100.tar.gz
</code></pre>
<ul>
<li>解压安装</li>
</ul>
<pre><code class="lang-js">[root@localhost home]# tar zxvf sqlite-autoconf-3300100.tar.gz
[root@localhost home]# cd sqlite-autoconf-3300100/
[root@localhost sqlite-autoconf-3300100]# ./configure
[root@localhost sqlite-autoconf-3300100]# make &amp; make install
</code></pre>
<ul>
<li>查看版本</li>
</ul>
<pre><code class="lang-js">#检查新安装的sqlite3版本
[root@localhost home]# /usr/local/bin/sqlite3 --version
3.30.1 2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b

#检查旧的sqlite3版本
[root@localhost home]# /usr/bin/sqlite3 --version
3.7.17 2013-05-20 00:56:22 118a3b35693b134d56ebd780123b7fd6f1497668

# 把旧的sqlite3改个名字
[root@localhost home]# mv /usr/bin/sqlite3  /usr/bin/sqlite3_old

# 设置软链接
[root@localhost home]# ln -s /usr/local/bin/sqlite3 /usr/bin/sqlite3

#查看sqlite3版本
[root@localhost home]# sqlite3 --version
3.30.1 2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b
</code></pre>
<ul>
<li>添加到<code>bashrc</code>文件</li>
</ul>
<p>在<code>~/.bashrc</code>中添加</p>
<pre><code class="lang-js">export LD_LIBRARY_PATH=&quot;/usr/local/lib&quot;
</code></pre>
<ul>
<li>检查<code>sqlite3</code>版本</li>
</ul>
<pre><code class="lang-js">[root@localhost home]# python3
Python 3.6.5 (default, Jul  9 2019, 20:03:55) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import sqlite3
&gt;&gt;&gt; sqlite3.sqlite_version
&#39;3.30.1&#39;
&gt;&gt;&gt; exit()  
[root@localhost home]#
</code></pre>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a><code>nginx</code></h2><p><a href="https://www.cnblogs.com/huiyi0521/p/10253341.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h3><p>添加Nginx 存储库</p>
<pre><code class="lang-js">sudo yum -y install epel-release
</code></pre>
<p>安装<code>nginx</code></p>
<pre><code class="lang-js">sudo yum -y install nginx
</code></pre>
<h3 id="2-启动"><a href="#2-启动" class="headerlink" title="2 启动"></a>2 启动</h3><p>启动nginx</p>
<pre><code class="lang-js">sudo systemctl start nginx
</code></pre>
<h3 id="3-防火墙"><a href="#3-防火墙" class="headerlink" title="3 防火墙"></a>3 防火墙</h3><p>允许http通信</p>
<pre><code class="lang-js">sudo firewall-cmd --permanent --zone=public --add-service=http
</code></pre>
<p>允许https通信</p>
<pre><code class="lang-js">sudo firewall-cmd --permanent --zone=public --add-service=https
</code></pre>
<p>重启防火墙 </p>
<pre><code class="lang-js">sudo firewall-cmd --reload
</code></pre>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h3><p>在浏览器输入地址</p>
<h3 id="5-卸载"><a href="#5-卸载" class="headerlink" title="5 卸载"></a>5 卸载</h3><p>停止nginx</p>
<pre><code class="lang-js">service nginx stop
// centos 7
sysyemcyl stop nginx
</code></pre>
<p>删除自启动</p>
<pre><code class="lang-js">chkconfig nginx off
</code></pre>
<p>从源头删除nginx</p>
<pre><code class="lang-js">rm -rf /usr/sbin/nginx
rm -rf /etc/nginx
rm -rf /etc/init.d/nginx
</code></pre>
<p>使用yum清理</p>
<pre><code class="lang-js">yum remove nginx
</code></pre>
<h2 id="修改root-后面的名字"><a href="#修改root-后面的名字" class="headerlink" title="修改root@后面的名字"></a>修改<code>root@</code>后面的名字</h2><p><code>centos7</code></p>
<pre><code class="lang-js">hostnamectl set-hostname dhl #
hostname #查看
vim /etc/hosts # 编辑hosts文件，给127.0.0.1添加hostname

127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 dhl
</code></pre>
<p>重启shell生效</p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器与本地传输文件</title>
    <url>//7ff886e9/</url>
    <content><![CDATA[<h2 id="SCP"><a href="#SCP" class="headerlink" title="SCP"></a><code>SCP</code></h2><p>首先确保服务器与本地通过<code>ssh</code>能进行链接，确保有<code>scp</code></p>
<h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><ul>
<li>远程拷贝文件<ul>
<li><code>scp</code> 本地文件 远程服务器用户名@远程服务器ip地址：指定拷贝到远程服务器路径</li>
<li><code>scp</code> 远程服务器用户名@远程服务器ip地址：远程服务器文件 指定拷贝到本地电脑的路径</li>
</ul>
</li>
<li>远程拷贝目录<ul>
<li><code>scp</code> <code>-r</code>本地文件 远程服务器用户名<code>@</code>远程服务器<code>ip</code>地址：指定拷贝到远程服务器路径</li>
<li><code>scp</code> <code>-r</code> 远程服务器用户名<code>@</code>远程服务器<code>ip</code>地址：远程服务器文件 指定拷贝到本地电脑的路径</li>
<li><code>-r</code> 表示递归拷贝整个目录</li>
</ul>
</li>
</ul>
<h3 id="传输文件至服务器"><a href="#传输文件至服务器" class="headerlink" title="传输文件至服务器"></a>传输文件至服务器</h3><p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gluhz0agd7j315x08oatm.jpg" alt></p>
<pre><code class="lang-js">scp 1.txt root@123.56.252.111:/root
</code></pre>
<h3 id="从服务器拷贝目录"><a href="#从服务器拷贝目录" class="headerlink" title="从服务器拷贝目录"></a>从服务器拷贝目录</h3><p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gluhyy1bkbj31690a7qqm.jpg" alt></p>
<pre><code class="lang-js">scp -r root@123.56.252.111:/root/select_test C:/Users/64371/Desktop
</code></pre>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取wallpaper图片</title>
    <url>//2514ad2c/</url>
    <content><![CDATA[<h2 id="1-user-agent-list"><a href="#1-user-agent-list" class="headerlink" title="1. user_agent_list"></a>1. user_agent_list</h2><p>这里是从网上获得的user_agent列表， 稍加修改就可以了</p>
<pre><code class="lang-py">import random


# 返回一个随机的请求头 headers
def getheaders():
    # 各种PC端
    user_agent_list_2 = [
        # Opera
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60&quot;,
        &quot;Opera/8.0 (Windows NT 5.1; U; en)&quot;,
        &quot;Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50&quot;,
        # Firefox
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0&quot;,
        &quot;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&quot;,
        # Safari
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2&quot;,
        # chrome
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&quot;,
        &quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16&quot;,
        # 360
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;,
        # 淘宝浏览器
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11&quot;,
        # 猎豹浏览器
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER&quot;,
        &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;,
        # QQ浏览器
        &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;,
        # sogou浏览器
        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)&quot;,
        # maxthon浏览器
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Maxthon/4.4.3.4000 Chrome/30.0.1599.101 Safari/537.36&quot;,
        # UC浏览器
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36&quot;,
    ]
    # 各种移动端
    user_agent_list_3 = [
        # IPhone
        &quot;Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;,
        # IPod
        &quot;Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;,
        # IPAD
        &quot;Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5&quot;,
        &quot;Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;,
        # Android
        &quot;Mozilla/5.0 (Linux; U; Android 2.2.1; zh-cn; HTC_Wildfire_A3333 Build/FRG83D) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;,
        &quot;Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;,
        # QQ浏览器 Android版本
        &quot;MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;,
        # Android Opera Mobile
        &quot;Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10&quot;,
        # Android Pad Moto Xoom
        &quot;Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13&quot;,
        # BlackBerry
        &quot;Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+&quot;,
        # WebOS HP Touchpad
        &quot;Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0&quot;,
        # Nokia N97
        &quot;Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124&quot;,
        # Windows Phone Mango
        &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)&quot;,
        # UC浏览器
        &quot;UCWEB7.0.2.37/28/999&quot;,
        &quot;NOKIA5700/ UCWEB7.0.2.37/28/999&quot;,
        # UCOpenwave
        &quot;Openwave/ UCWEB7.0.2.37/28/999&quot;,
        # UC Opera
        &quot;Mozilla/4.0 (compatible; MSIE 6.0; ) Opera/UCWEB7.0.2.37/28/999&quot;
    ]
    # 一部分 PC端的
    user_agent_list_1 = [
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;,
        &quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&quot;,
        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,
        &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,
        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&quot;,
        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;
    ]
    user_agent_list = user_agent_list_1 + user_agent_list_2 + user_agent_list_3;
    UserAgent = random.choice(user_agent_list)
    header = {&quot;User-Agent&quot;: UserAgent}
    return header
</code></pre>
<h2 id="2-免费代理"><a href="#2-免费代理" class="headerlink" title="2.免费代理"></a>2.免费代理</h2><p>这里只是列举了几个免费代理的网站，从上面爬取ip:port 和类型组装成字典输出即可</p>
<pre><code class="lang-py">import requests
import user_agent_list
import re
import random


class SpiderProxy():
    def __init__(self):
        self.url = [&quot;https://www.kuaidaili.com/free/inha/1/&quot;, &quot;https://www.7yip.cn/free/?action=china&amp;page=2&quot;,
                    &quot;https://www.7yip.cn/free/?action=china&amp;page=3&quot;, ]
        self.header = user_agent_list.getheaders()
        self.proxy = {}
        self.proxies_list = []
        self.run()

    def get_proxies_list(self, url):
        try:
            response = requests.get(url, headers=self.header, timeout=3)
            response_data = response.content.decode(&#39;utf-8&#39;)

            ip_list = re.findall(r&#39;&lt;td data-title=&quot;IP&quot;&gt;(.*?)&lt;/td&gt;&#39;, response_data, re.S)
            port_list = re.findall(r&#39;&lt;td data-title=&quot;PORT&quot;&gt;(.*?)&lt;/td&gt;&#39;, response_data, re.S)
            type_list = re.findall(r&#39;&lt;td data-title=&quot;类型&quot;&gt;(.*?)&lt;/td&gt;&#39;, response_data, re.S)

            for index in range(len(ip_list)):
                self.proxies_list.append(&quot;{\&#39;%s\&#39;:\&#39;%s:%s\&#39;}&quot; % (type_list[index], ip_list[index], port_list[index]))

        except Exception as e:
            print(e)

        # for tmp_proxy in tmp_list:
        #     proxy = eval(tmp_proxy)
        #     response = requests.get(&quot;www.baidu.com&quot;, headers=self.header, proxies=proxy)
        #     if response.status_code == 200:
        #         self.proxies_list.append(tmp_proxy)

    def get_proxy(self):
        while 1:
            try:
                self.proxy = eval(random.choice(self.proxies_list))
                response = requests.get(&quot;http://www.baidu.com&quot;, headers=self.header, proxies=self.proxy, timeout=3)
                if response.status_code == 200:
                    return
            except Exception as e:
                print(&quot;getProxy ------&gt; ERROR&quot;, e)

    def run(self):
        for url in self.url:
            self.get_proxies_list(url)
</code></pre>
<h2 id="3-loopRequests"><a href="#3-loopRequests" class="headerlink" title="3. loopRequests"></a>3. loopRequests</h2><p>自己封装的循环访问的方法，可以解决部分网络延迟问题</p>
<p>在使用代理方面，每50次访问就更换代理，避免被封IP</p>
<pre><code class="lang-py">import requests
import spider_proxy
import time


class LoopRequest():
    def __init__(self):
        self.proxies = spider_proxy.SpiderProxy()
        self.count = 50

    def get(self, url, **args):
        return self.request(&#39;GET&#39;, url, **args)

    def post(self, url, **args):
        return self.request(&#39;POST&#39;, url, **args)

    def get_proxy(self):
        if self.count &lt;= 0:
            self.proxies.get_proxy()
            self.count = 50
        self.count -= 1

    def request(self, method, url, **args):
        self.get_proxy()

        args[&#39;headers&#39;] = self.proxies.header
        args[&#39;proxies&#39;] = self.proxies.proxy
        args[&#39;timeout&#39;] = 5
        args[&#39;verify&#39;] = False
        loop = 50
        while loop:
            try:
                print(&quot;loopRequest: %s 第 %s 次尝试&quot; % (url, 51-loop))
                requests.packages.urllib3.disable_warnings()
                response = requests.request(method, url, **args)
                print(&quot;loopRequest: %s 链接成功&quot; % url)
                return response
            except Exception as e:
                print(&quot;loopRequest: &quot; + e)
                time.sleep(5)
                if loop == 0:
                    return &quot;get error&quot;
            loop -= 1


request = LoopRequest()
</code></pre>
<h2 id="4-cookie"><a href="#4-cookie" class="headerlink" title="4.  cookie"></a>4.  cookie</h2><p>由于<code>wallpaper</code>登录以后可以看到更多图片，所以这里要模仿登录来拿到<code>cookie</code></p>
<p><code>session</code>在这里并不能起到很好的效果，所以直接使用<code>cookie</code>来模拟登录</p>
<p>详细信息挫这里: <a href="http://www.orzff.cn/72810b67/" target="_blank" rel="noopener">wallpaper 模拟登录 | Mug-9’s blog (orzff.cn)</a></p>
<pre><code class="lang-py">import requests
import re
import loopRequest


class SpiderCookies():
    def __init__(self):
        self.get_url = &quot;https://wallhaven.cc/login&quot;
        self.post_url = &quot;https://wallhaven.cc/auth/login&quot;
        self.request = loopRequest.request
        self.data = {}
        self._token = &quot;&quot;
        self.cookies = {}
        self.Is = False
        self.update()

    # 1. 请求页面获得_token 和 cookie
    def get_html(self):
        response = self.request.get(self.get_url)
        response_data = response.content.decode(&#39;utf-8&#39;)

        self._token = re.findall(r&#39;&lt;meta name=&quot;csrf-token&quot; content=&quot;(.*?)&quot;&gt;&#39;, response_data, re.S)

        cookies = &quot;&quot;
        for cookie in response.cookies:
            cookies += cookie.name + &quot;=&quot; + cookie.value + &quot;;&quot;

        # 用header来携带cookie
        self.request.proxies.header[&#39;Cookie&#39;] = cookies

    # 2.装填data
    def combined_data(self):
        self.data = {
            &#39;_token&#39;: self._token,
            &#39;username&#39;: &#39;643719884@qq.com&#39;,
            &#39;password&#39;: &#39;dhl643719884&#39;
        }

    # 3. 组装cookie
    def combined_cookie(self):
        response = self.request.post(self.post_url, data=self.data)

        # 这里拿到的cookie是相对比较齐全的cookie，主要用这个cookie来组装
        post_cookies = response.request.headers[&#39;Cookie&#39;]
        post_cookies_list = post_cookies.split(&quot;; &quot;)

        # 这里cookie只要__cfduid
        temp_cookie = self.request.proxies.header[&#39;Cookie&#39;]
        temp_cookie_list = temp_cookie.split(&quot;;&quot;)

        # 组装
        self.cookies.update(__cfduid = temp_cookie_list[0].split(&#39;=&#39;)[1])
        for cookie in post_cookies_list:
            self.cookies[cookie.split(&#39;=&#39;)[0]] = cookie.split(&#39;=&#39;)[1]

        # header pop掉Cookie
        self.request.proxies.header.pop(&#39;Cookie&#39;)

    # 4.登录
    def post_html(self):
        response = self.request.get(self.post_url, cookies=self.cookies)
        response_data = response.content.decode(&#39;utf-8&#39;)
        if response.status_code == 200:
            print(&quot;WallPaper: Cookies获取成功&quot;)
            self.Is = True
        else:
            print(&quot;WallPaper: Cookies获取失败&quot;)

    def update(self):
        self.get_html()
        self.combined_data()
        self.combined_cookie()
        self.post_html()
</code></pre>
<h2 id="5-spider-图片"><a href="#5-spider-图片" class="headerlink" title="5. spider 图片"></a>5. spider 图片</h2><h3 id="5-1-先获取页面上所有图片二级页面的url"><a href="#5-1-先获取页面上所有图片二级页面的url" class="headerlink" title="5.1 先获取页面上所有图片二级页面的url"></a>5.1 先获取页面上所有图片二级页面的url</h3><pre><code class="lang-py"># 1. 获取页面信息,获取每张战片所在页面的url
    def get_html(self, url):
        response = self.request.get(url, cookies=self.cookies.cookies)
        response_data = response.content.decode(&#39;utf-8&#39;)
        href_list = re.findall(r&#39;&lt;a class=&quot;preview&quot; href=&quot;(.*?)&quot;  target=&quot;_blank&quot;  &gt;&lt;/a&gt;&#39;, response_data, re.S)
        return href_list
</code></pre>
<h3 id="5-2-对于每张图片页面，获取每张图片的页面"><a href="#5-2-对于每张图片页面，获取每张图片的页面" class="headerlink" title="5.2 对于每张图片页面，获取每张图片的页面"></a>5.2 对于每张图片页面，获取每张图片的页面</h3><p>使用<code>etree+xpath</code>即可拿到每张图片的url</p>
<p>为防止网络问题，这里进行了5次重复</p>
<pre><code class="lang-py"># 2. 进入页面 获取图片的url
    def get_img_url(self, url):
        loop = 5
        img_url = []
        while loop:
            response = self.request.get(url)
            response_data = response.content.decode(&#39;utf-8&#39;)
            response_html = etree.HTML(response_data)
            img_url = response_html.xpath(&#39;//*[@id=&quot;wallpaper&quot;]/@src&#39;)
            if len(img_url):
                return img_url
            loop -= 1
        self.error_log.write(url)
        print(url, &quot;ERROR&quot;)
        return img_url
</code></pre>
<h3 id="5-3-下载"><a href="#5-3-下载" class="headerlink" title="5.3  下载"></a>5.3  下载</h3><p>下载到本地<code>E:\picture\当天日期</code></p>
<p>检查本地log看是否已存在相同图片</p>
<pre><code class="lang-py"># 3. 下载
    def img_download(self, url):
        with self.sem:
            img_name = url.split(&#39;/&#39;)[-1]
            if self.file_check(img_name):
                print(&quot;---%s 已存在&quot; % img_name)
                return

            picture_mkdir = &quot;E:\\picture&quot;
            if not os.path.exists(picture_mkdir):
                os.mkdir(picture_mkdir)
            os.chdir(picture_mkdir)
            data_mkdir = &quot;%s\\%s&quot; % (picture_mkdir, datetime.date.today())
            if not os.path.exists(data_mkdir):
                os.mkdir(data_mkdir)
            os.chdir(data_mkdir)

            response = self.request.get(url)
            response_data = response.content
            print(&quot;---%s 开始写入&quot; % img_name)
            threadLock.acquire()
            with open(&quot;%s&quot; % img_name, &quot;wb&quot;) as f:
                f.write(response_data)
            threadLock.release()
            print(&quot;---%s 写入完毕 -- count: %s&quot; % (img_name, self.count))

            threadLock.acquire()
            self.download_log.write(img_name)
            self.count -= 1
            threadLock.release()
</code></pre>
<h3 id="5-4-检查本地log"><a href="#5-4-检查本地log" class="headerlink" title="5.4 检查本地log"></a>5.4 检查本地log</h3><p>检查看是否已存在图片</p>
<pre><code class="lang-py"> # 4. 本地log
    def file_check(self, img_name):
        threadLock.acquire()
        self.download_log.seek(0, 0)
        file_content = self.download_log.read()
        threadLock.release()
        if img_name in file_content:
            return True
        else:
            return False
</code></pre>
<h3 id="5-5-run"><a href="#5-5-run" class="headerlink" title="5.5 run"></a>5.5 run</h3><p>计划每次下载100张图片，网页页数从2-100</p>
<pre><code class="lang-py"># 6.run
    def run(self):
        loop = 50
        while loop:
            if self.cookies.Is:
                break
            else:
                self.cookies.update()
            time.sleep(2)
            loop -= 1
        if loop &lt;= 0:
            self.error_log.write(&quot;Cookies 获得失败&quot;)
            return
        for i in range(2, 100):
            url = &quot;%s%s&quot; % (self.url, i)
            href_list = self.get_html(url)
            for html_url in href_list:
                img_url = self.get_img_url(html_url)
                if len(img_url) and self.count &gt; 0:
                    threading.Thread(target=self.img_download, args=(img_url[0],)).start()
</code></pre>
<h2 id="6-github地址"><a href="#6-github地址" class="headerlink" title="6. github地址"></a>6. github地址</h2><p><a href="https://github.com/Mug-9/Python-Spider/tree/master/爬取WallHaven 图片" target="_blank" rel="noopener">Mug-9/Python-Spider: Spider (github.com)</a></p>]]></content>
      <categories>
        <category>Spider</category>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>爬图片</tag>
      </tags>
  </entry>
  <entry>
    <title>python 生成requirements.txt</title>
    <url>//3d982a67/</url>
    <content><![CDATA[<h2 id="生成requirements"><a href="#生成requirements" class="headerlink" title="生成requirements"></a>生成requirements</h2><p>在要生成requirements的目录的控制台输入</p>
<p><code>pip freeze &gt; requirements.txt</code></p>
<h2 id="安装requirement"><a href="#安装requirement" class="headerlink" title="安装requirement"></a>安装requirement</h2><p>要根据<code>requirements</code>安装时，在控制台输入</p>
<p><code>pip install -r requirements.txt</code></p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>requirements</tag>
      </tags>
  </entry>
  <entry>
    <title>gitee和github同步更新</title>
    <url>//2d45259f/</url>
    <content><![CDATA[<h2 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h2><p>由于众所周知的原因，在github上clone很慢，所以采用码云来加速clone</p>
<h3 id="1-在码云上导入github项目"><a href="#1-在码云上导入github项目" class="headerlink" title="1 在码云上导入github项目"></a>1 在码云上导入github项目</h3><p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gldgqbjrwgj30bx08xwen.jpg" alt="img1"></p>
<h3 id="2-修改config"><a href="#2-修改config" class="headerlink" title="2 修改config"></a>2 修改<code>config</code></h3><p><code>git clone</code>到本地，在视图中显示隐藏项目，进入<code>.git</code>找到<code>config</code></p>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gldgqf0oisj307k083weg.jpg" alt="img2"></p>
<h3 id="3-加上github的链接"><a href="#3-加上github的链接" class="headerlink" title="3 加上github的链接"></a>3 加上github的链接</h3><p>由于是在gitee上clone的项目，所以在config中只有gitee的链接，在github链接下面加上gitee的链接</p>
<p>注意： 一定是github下面加gitee的链接</p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gldgqh0or2j30f8010mx1.jpg" alt="img3"></p>
<h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>这样就可以在<code>push</code>的时候同时更新了</p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>win10 terminal 配置</title>
    <url>//e96d644/</url>
    <content><![CDATA[<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><pre><code class="lang-json">// This file was initially generated by Windows Terminal 1.4.3243.0
// It should still be usable in newer versions, but newer versions might have additional
// settings, help text, or changes that you will not see unless you clear this file
// and let us generate a new one for you.

// To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.
// For documentation on these settings, see: https://aka.ms/terminal-documentation
{
    &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;,

    &quot;defaultProfile&quot;: &quot;{574e775e-4f2a-5b96-ac1e-a2962a402336}&quot;,

    // You can add more global application settings here.
    // To learn more about global settings, visit https://aka.ms/terminal-global-settings

    // If enabled, selections are automatically copied to your clipboard.
    &quot;copyOnSelect&quot;: false,

    // If enabled, formatted data is also copied to your clipboard
    &quot;copyFormatting&quot;: false,

    &quot;tabWidthMode&quot;: &quot;equal&quot;,

    &quot;theme&quot;: &quot;light&quot;,

    // A profile specifies a command to execute paired with information about how it should look and feel.
    // Each one of them will appear in the &#39;New Tab&#39; dropdown,
    //   and can be invoked from the commandline with `wt.exe -p xxx`
    // To learn more about profiles, visit https://aka.ms/terminal-profile-settings
    &quot;profiles&quot;:
    {
        &quot;defaults&quot;:
        {
            // Put settings here that you want to apply to all profiles.
            &quot;fontFace&quot;: &quot;CaskaydiaCove NF&quot;,
            &quot;fontSize&quot;: 16,
            &quot;cursorShape&quot;: &quot;filledBox&quot;,
        },
        &quot;list&quot;:
        [
            {
                &quot;guid&quot;: &quot;{574e775e-4f2a-5b96-ac1e-a2962a402336}&quot;,
                &quot;hidden&quot;: false,
                &quot;name&quot;: &quot;PowerShell 7&quot;,
                &quot;source&quot;: &quot;Windows.Terminal.PowershellCore&quot;,
                &quot;tabTitle&quot;: &quot;PowerShell 7&quot;,

                // morec
                // 背景图片
                &quot;acrylicOpacity&quot;: 0.5, 
                &quot;backgroundImage&quot;: &quot;E:/picture/2020-12-18/wallhaven-o3d3w7.jpg&quot;,
                &quot;backgroundImageOpacity&quot;: 0.25,
                &quot;backgroundImagerStretchMode&quot;: &quot;fill&quot;,
                &quot;useAcrylic&quot;: true,

                &quot;padding&quot;: &quot;0, 0, 0, 0&quot;,
                // 键入时窗口滚动到输入行
                &quot;snapOnInput&quot;: true, 
                // 打开时的目录
                &quot;startingDirectory&quot;: &quot;.&quot;, 
                // tab标题
                &quot;tabTitle&quot;: &quot;powershell&quot;, 
                // 使用acrylic
                &quot;useAcrylic&quot;: false, 

                //主题
                    &quot;colorScheme&quot;: &quot;Solarized Dark Higher Contrast&quot;,
            },
            {
                &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;,
                &quot;hidden&quot;: false,
                &quot;name&quot;: &quot;PowerShell&quot;,
                &quot;commandline&quot;: &quot;powershell.exe&quot;,
                &quot;tabTitle&quot;: &quot;PowerShell&quot;,

                // morec
                // 背景图片
                &quot;acrylicOpacity&quot;: 0.25, 
                &quot;backgroundImage&quot;: &quot;E:/picture/2020-12-07/wallhaven-y87dxx.jpg&quot;,
                &quot;backgroundImageOpacity&quot;: 0.25,
                &quot;backgroundImagerStretchMode&quot;: &quot;fill&quot;,

                &quot;padding&quot;: &quot;0, 0, 0, 0&quot;,
                // 键入时窗口滚动到输入行
                &quot;snapOnInput&quot;: true, 
                // 打开时的目录
                &quot;startingDirectory&quot;: &quot;.&quot;, 
                // tab标题
                &quot;tabTitle&quot;: &quot;powershell&quot;, 
                // 使用acrylic
                &quot;useAcrylic&quot;: false, 

                //主题
                    &quot;colorScheme&quot;: &quot;Cobalt Neon&quot;,
            },
            {
                // Make changes here to the cmd.exe profile.
                &quot;guid&quot;: &quot;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}&quot;,
                &quot;name&quot;: &quot;Command Prompt&quot;,
                &quot;commandline&quot;: &quot;cmd.exe&quot;,
                &quot;hidden&quot;: false,
                // more 
                &quot;acrylicOpacity&quot;: 0.25,
                &quot;backgroundImage&quot;: &quot;E:/picture/wallhaven-1kjqdw.jpg&quot;,
                &quot;backgroundImageOpacity&quot;: 0.25,
                &quot;backgroundImagerStretchMode&quot;: &quot;fill&quot;,
                &quot;padding&quot;: &quot;0, 0, 0, 0&quot;,
                &quot;snapOnInput&quot;: true,
                &quot;startingDirectory&quot;: &quot;%USERPROFILE%&quot;,
                &quot;tabTitle&quot;: &quot;cmd&quot;,
                &quot;useAcrylic&quot;: false,

                //主题
                    &quot;colorScheme&quot;: &quot;Thanatos Dark&quot;,
            },
            {
                // 通过terminal连接服务器
                &quot;guid&quot;: &quot;{B5F0BC97-C32E-67A0-97E1-6112A50DF336}&quot;,
                &quot;name&quot;: &quot;aliyun&quot;,
                &quot;commandline&quot;: &quot;ssh root@123.56.252.111&quot;,
               &quot;acrylicOpacity&quot;: 0.4,
               &quot;backgroundImage&quot;: &quot;E:/picture/2020-12-18/wallhaven-6oq5lq.jpg&quot;,
               &quot;backgroundImageOpacity&quot;: 0.4,
               &quot;backgroundImagerStretchMode&quot;: &quot;fill&quot;,
               &quot;padding&quot;: &quot;0, 0, 0, 0&quot;,
               &quot;snapOnInput&quot;: true,
               &quot;startingDirectory&quot;: &quot;%USERPROFILE%&quot;,
               &quot;tabTitle&quot;: &quot;aliyun&quot;,
               &quot;useAcrylic&quot;: false,
               &quot;icon&quot;: &quot;ms-appx:///ProfileIcons/{9acb9455-ca41-5af7-950f-6bca1bc9722f}.png&quot;, // 图标
                //主题
                    &quot;colorScheme&quot;: &quot;Thanatos Dark&quot;,

            },
            {
                &quot;guid&quot;: &quot;{db1d57fc-a9c1-4051-9677-f0232f905f60}&quot;,
                &quot;hidden&quot;: false,
                &quot;name&quot;: &quot;Tencent Server&quot;,
                 &quot;commandline&quot;: &quot;ssh root@81.71.14.51&quot;,
                &quot;icon&quot;: &quot;ms-appdata:///roaming/TencentServer.png&quot;,

                // morec
                // 背景图片
                &quot;acrylicOpacity&quot;: 0.5, 
                &quot;backgroundImage&quot;: &quot;E:/picture/2020-12-23/wallhaven-o3dvv9.jpg&quot;,
                &quot;backgroundImageOpacity&quot;: 0.25,
                &quot;backgroundImagerStretchMode&quot;: &quot;fill&quot;,
                &quot;useAcrylic&quot;: true,

                &quot;padding&quot;: &quot;0, 0, 0, 0&quot;,
                // 键入时窗口滚动到输入行
                &quot;snapOnInput&quot;: true, 
                // 打开时的目录
                &quot;startingDirectory&quot;: &quot;.&quot;, 
                // tab标题
                &quot;tabTitle&quot;: &quot;powershell&quot;, 
                // 使用acrylic
                &quot;useAcrylic&quot;: false, 

                //主题
                    &quot;colorScheme&quot;: &quot;Thanatos Dark&quot;,
                    &quot;cursorColor&quot; : &quot;#FFFFFF&quot;,
            },
            {
                &quot;guid&quot;: &quot;{b453ae62-4e3d-5e58-b989-0a998ec441b8}&quot;,
                &quot;hidden&quot;: false,
                &quot;name&quot;: &quot;Azure Cloud Shell&quot;,
                &quot;source&quot;: &quot;Windows.Terminal.Azure&quot;
            },
        ]
    },

    // Add custom color schemes to this array.
    // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes
    &quot;schemes&quot;: [
        {
            &quot;name&quot;: &quot;Thanatos Dark&quot;,
            &quot;background&quot; : &quot;#1a2b3c&quot;,
            &quot;foreground&quot; : &quot;#e09887&quot;,
            &quot;selectionBackground&quot;: &quot;#fef8ec&quot;,
            &quot;black&quot;: &quot;#65737e&quot;,
            &quot;blue&quot;: &quot;#0e9bd1&quot;,
            &quot;brightBlack&quot;: &quot;#acacac&quot;,
            &quot;brightBlue&quot;: &quot;#7899ba&quot;,
            &quot;brightCyan&quot;: &quot;#0099ad&quot;,
            &quot;brightGreen&quot;: &quot;#0de1b1&quot;,
            &quot;brightRed&quot;: &quot;#d47186&quot;,
            &quot;brightWhite&quot;: &quot;#fef8ec&quot;,
            &quot;brightYellow&quot;: &quot;#d8cb32&quot;,
            &quot;brightPurple&quot;: &quot;#ab43aa&quot;,
            &quot;purple&quot;: &quot;#928ba6&quot;,
            &quot;cyan&quot;: &quot;#008486&quot;,
            &quot;green&quot;: &quot;#0099ad&quot;,
            &quot;red&quot;: &quot;#ce4559&quot;,
            &quot;white&quot;: &quot;#fef8ec&quot;,
            &quot;yellow&quot;: &quot;#d8cb32&quot;
        },
            {
              &quot;name&quot;: &quot;Cobalt Neon&quot;,
              &quot;black&quot;: &quot;#142631&quot;,
              &quot;red&quot;: &quot;#ff2320&quot;,
              &quot;green&quot;: &quot;#3ba5ff&quot;,
              &quot;yellow&quot;: &quot;#e9e75c&quot;,
              &quot;blue&quot;: &quot;#8ff586&quot;,
              &quot;purple&quot;: &quot;#781aa0&quot;,
              &quot;cyan&quot;: &quot;#8ff586&quot;,
              &quot;white&quot;: &quot;#ba46b2&quot;,
              &quot;brightBlack&quot;: &quot;#fff688&quot;,
              &quot;brightRed&quot;: &quot;#d4312e&quot;,
              &quot;brightGreen&quot;: &quot;#8ff586&quot;,
              &quot;brightYellow&quot;: &quot;#e9f06d&quot;,
              &quot;brightBlue&quot;: &quot;#3c7dd2&quot;,
              &quot;brightPurple&quot;: &quot;#8230a7&quot;,
              &quot;brightCyan&quot;: &quot;#6cbc67&quot;,
              &quot;brightWhite&quot;: &quot;#8ff586&quot;,
              &quot;background&quot;: &quot;#142838&quot;,
              &quot;foreground&quot;: &quot;#8ff586&quot;
            },
            {
              &quot;name&quot;: &quot;Aurora&quot;,
              &quot;black&quot;: &quot;#23262e&quot;,
              &quot;red&quot;: &quot;#f0266f&quot;,
              &quot;green&quot;: &quot;#8fd46d&quot;,
              &quot;yellow&quot;: &quot;#ffe66d&quot;,
              &quot;blue&quot;: &quot;#0321d7&quot;,
              &quot;purple&quot;: &quot;#ee5d43&quot;,
              &quot;cyan&quot;: &quot;#03d6b8&quot;,
              &quot;white&quot;: &quot;#c74ded&quot;,
              &quot;brightBlack&quot;: &quot;#292e38&quot;,
              &quot;brightRed&quot;: &quot;#f92672&quot;,
              &quot;brightGreen&quot;: &quot;#8fd46d&quot;,
              &quot;brightYellow&quot;: &quot;#ffe66d&quot;,
              &quot;brightBlue&quot;: &quot;#03d6b8&quot;,
              &quot;brightPurple&quot;: &quot;#ee5d43&quot;,
              &quot;brightCyan&quot;: &quot;#03d6b8&quot;,
              &quot;brightWhite&quot;: &quot;#c74ded&quot;,
              &quot;background&quot;: &quot;#23262e&quot;,
              &quot;foreground&quot;: &quot;#ffca28&quot;
            },
            {
              &quot;name&quot;: &quot;FunForrest&quot;,
              &quot;black&quot;: &quot;#000000&quot;,
              &quot;red&quot;: &quot;#d6262b&quot;,
              &quot;green&quot;: &quot;#919c00&quot;,
              &quot;yellow&quot;: &quot;#be8a13&quot;,
              &quot;blue&quot;: &quot;#4699a3&quot;,
              &quot;purple&quot;: &quot;#8d4331&quot;,
              &quot;cyan&quot;: &quot;#da8213&quot;,
              &quot;white&quot;: &quot;#ddc265&quot;,
              &quot;brightBlack&quot;: &quot;#7f6a55&quot;,
              &quot;brightRed&quot;: &quot;#e55a1c&quot;,
              &quot;brightGreen&quot;: &quot;#bfc65a&quot;,
              &quot;brightYellow&quot;: &quot;#ffcb1b&quot;,
              &quot;brightBlue&quot;: &quot;#7cc9cf&quot;,
              &quot;brightPurple&quot;: &quot;#d26349&quot;,
              &quot;brightCyan&quot;: &quot;#e6a96b&quot;,
              &quot;brightWhite&quot;: &quot;#ffeaa3&quot;,
              &quot;background&quot;: &quot;#251200&quot;,
              &quot;foreground&quot;: &quot;#dec165&quot;
            },
            {
              &quot;name&quot;: &quot;Solarized Dark Higher Contrast&quot;,
              &quot;black&quot;: &quot;#002831&quot;,
              &quot;red&quot;: &quot;#d11c24&quot;,
              &quot;green&quot;: &quot;#6cbe6c&quot;,
              &quot;yellow&quot;: &quot;#a57706&quot;,
              &quot;blue&quot;: &quot;#2176c7&quot;,
              &quot;purple&quot;: &quot;#c61c6f&quot;,
              &quot;cyan&quot;: &quot;#259286&quot;,
              &quot;white&quot;: &quot;#eae3cb&quot;,
              &quot;brightBlack&quot;: &quot;#006488&quot;,
              &quot;brightRed&quot;: &quot;#f5163b&quot;,
              &quot;brightGreen&quot;: &quot;#51ef84&quot;,
              &quot;brightYellow&quot;: &quot;#b27e28&quot;,
              &quot;brightBlue&quot;: &quot;#178ec8&quot;,
              &quot;brightPurple&quot;: &quot;#e24d8e&quot;,
              &quot;brightCyan&quot;: &quot;#00b39e&quot;,
              &quot;brightWhite&quot;: &quot;#fcf4dc&quot;,
              &quot;background&quot;: &quot;#142838&quot;,
              &quot;foreground&quot;: &quot;#9cc2c3&quot;
            }



    ],

    // Add custom actions and keybindings to this array.
    // To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.
    // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings
    &quot;actions&quot;:
    [
        // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.
        // These two lines additionally bind them to Ctrl+C and Ctrl+V.
        // To learn more about selection, visit https://aka.ms/terminal-selection
        { &quot;command&quot;: {&quot;action&quot;: &quot;copy&quot;, &quot;singleLine&quot;: false }, &quot;keys&quot;: &quot;ctrl+c&quot; },
        { &quot;command&quot;: &quot;paste&quot;, &quot;keys&quot;: &quot;ctrl+v&quot; },

        // Press Ctrl+Shift+F to open the search box
        { &quot;command&quot;: &quot;find&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; },

        // Press Alt+Shift+D to open a new pane.
        // - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.
        // - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane&#39;s profile.
        // To learn more about panes, visit https://aka.ms/terminal-panes
        { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;auto&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+d&quot; }
    ]
}
</code></pre>
<p><code>cmd</code></p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1glyrcq4prlj31hk0t41kx.jpg" alt="cmd"></p>
<h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><h3 id="客户端生成ssh公私钥"><a href="#客户端生成ssh公私钥" class="headerlink" title="客户端生成ssh公私钥"></a>客户端生成ssh公私钥</h3><p><code>ssh-keygen</code></p>
<h3 id="本地ssh公钥追加到服务器"><a href="#本地ssh公钥追加到服务器" class="headerlink" title="本地ssh公钥追加到服务器"></a>本地ssh公钥追加到服务器</h3><p>将<code>id_rsa.pub</code>的内容复制到<code>tmp.pub</code></p>
<pre><code class="lang-js">cd ~
vi tmp.pub
mkdir .ssh &amp;&amp; chmod 700 .ssh
touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys
cat tmp.pub &gt;&gt; .ssh/authorized_keys
rm tmp.pub
</code></pre>
<h3 id="重启terminal"><a href="#重启terminal" class="headerlink" title="重启terminal"></a>重启terminal</h3><p>成功！</p>
<h3 id="解决终端链接服务器长时间不操作卡死"><a href="#解决终端链接服务器长时间不操作卡死" class="headerlink" title="解决终端链接服务器长时间不操作卡死"></a>解决终端链接服务器长时间不操作卡死</h3><p>在服务器中执行</p>
<pre><code class="lang-js">vim /etc/ssh/sshd_config

ClientAliveInterval  60      // 每隔60S向客户端发送请求消息，并等待客户端响应
ClientAliveCountMax  10   // 客户端超过十次没响应，自动断开（即10分钟）

//重启sshd服务
//centos6
service ssh restart
//centos7
systemctl restart sshd
</code></pre>
<p>进入所在用户的<code>.ssh</code>目录,</p>
<p>root用户的目录在：<code>/root/.ssh/</code><br>创建<code>config</code>文件<br><code>vim /root/.ssh/config</code><br>在文件中添加：<br><code>ServerAliveINterval 60</code>(没写错，就是<code>INterval</code>，我也不知道为什么，)<br>保存退出，重新从终端通过<code>ssh</code>进入服务器后不会因为长时间操作断开。</p>
<p>加入这句之后，<code>ssh</code>客户端会每隔一段时间自动与<code>ssh</code>服务器通信一次，所以长时间操作不会断开。</p>
<h2 id="terminal-添加右键"><a href="#terminal-添加右键" class="headerlink" title="terminal 添加右键"></a><code>terminal</code> 添加右键</h2><h3 id="检查常量"><a href="#检查常量" class="headerlink" title="检查常量"></a>检查常量</h3><pre><code>echo %USERPROFILE%

echo %LOCALAPPDATA%
</code></pre><h3 id="获取图标"><a href="#获取图标" class="headerlink" title="获取图标"></a>获取图标</h3><p>创建<code>Terminal</code>文件夹</p>
<pre><code>mkdir &quot;%USERPROFILE%\AppData\Local\Terminal&quot;
</code></pre><p>保存这个 <a href="https://gitee.com/Jioho/img/raw/master/wsl/terminal.ico" target="_blank" rel="noopener">图标</a></p>
<p><img src="https://gitee.com/Jioho/img/raw/master/wsl/terminal.ico" alt></p>
<h3 id="添加注册表文件"><a href="#添加注册表文件" class="headerlink" title="添加注册表文件"></a>添加注册表文件</h3><p>新建一个文件 <code>new.reg</code></p>
<pre><code class="lang-js">Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]
@=&quot;Windows Terminal here&quot;
&quot;Icon&quot;=&quot;%USERPROFILE%\\AppData\\Local\\Terminal\\terminal.ico&quot;

[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]
@=&quot;C:\\Users\\[你的电脑用户名！你的电脑用名！]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;
</code></pre>
<ul>
<li><code>@</code>后面的[]改成电脑的用户名</li>
<li>如果第一步<code>USERPROFILE</code>没有东西打印出来，那么这里的<code>USERPROFILE</code>也改成<code>C:\Users\你的用户名</code></li>
<li>第5行时图标保存的地址</li>
</ul>
<p>执行<code>reg</code>文件，可以发现右键多了一个<code>windows termianl here</code></p>
<h3 id="当前目录"><a href="#当前目录" class="headerlink" title="当前目录"></a>当前目录</h3><p>在配置文件中添加或修改</p>
<pre><code class="lang-js">// 打开时的目录
&quot;startingDirectory&quot;: &quot;.&quot;,
</code></pre>
<p>这样也有一个缺点，直接打开<code>termianl</code>时目录为<code>C:\Windows\System32</code>目前没有解决方法</p>
<h2 id="PowerShell主题"><a href="#PowerShell主题" class="headerlink" title="PowerShell主题"></a><code>PowerShell</code>主题</h2><p><a href="https://www.misiyu.cn/article/134.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="安装oh-my-posh主题"><a href="#安装oh-my-posh主题" class="headerlink" title="安装oh-my-posh主题"></a>安装<code>oh-my-posh</code>主题</h3><p>在terminal输入</p>
<pre><code class="lang-js">Install-Module posh-git -Scope CurrentUser
Install-Module oh-my-posh -Scope CurrentUser
</code></pre>
<p>输入<code>Y</code>同意安装</p>
<h3 id="更新配置文件"><a href="#更新配置文件" class="headerlink" title="更新配置文件"></a>更新配置文件</h3><p>在<code>terminal</code>输入<code>$PROFILE</code></p>
<p>得到当前电脑的<code>powershell_profile</code>文件</p>
<pre><code class="lang-js">PS C:\Windows\System32&gt; $PROFILE
C:\Users\64371\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
PS C:\Windows\System32&gt;
</code></pre>
<p>继续输入</p>
<pre><code class="lang-js">if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }
notepad $PROFILE
</code></pre>
<p>在打开的文件夹中添加</p>
<pre><code class="lang-js">Import-Module posh-git
Import-Module oh-my-posh
Set-Theme Honukai
</code></pre>
<p><code>Set-Theme Honukai</code>是主题设置，其他可选主题</p>
<pre><code>Agnoster、Avit、Darkblood、Fish、Honukai、Paradox、Sorin、tehrob
</code></pre><p>更新配置</p>
<p>输入你用<code>$PROFILE</code>得到的路径</p>
<pre><code class="lang-js">C:\Users\64371\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
</code></pre>
<p>有些主题的样式可能会有些小空格，这时因为字体不支持<code>poweline</code>,推荐选择<code>Hack NF</code>字体，支持编程连字和<code>poweline</code>字形</p>
<p><a href="https://www.nerdfonts.com/font-downloads" target="_blank" rel="noopener">下载链接</a></p>
<p>我的样式</p>
<p><code>powershell 5</code></p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1glyrcnto2jj31hk0t4hdu.jpg" alt="poweshell5"></p>
<p><code>power shell 7</code></p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1glyrcgjag7j31hk0t4qv5.jpg" alt="powershell7"></p>
<h2 id="Centos-terminal-主题"><a href="#Centos-terminal-主题" class="headerlink" title="Centos-terminal 主题"></a><code>Centos-terminal</code> 主题</h2><p><a href="https://www.jianshu.com/p/fa82d932888b" target="_blank" rel="noopener">参考</a></p>
<h3 id="查看系统当前shell"><a href="#查看系统当前shell" class="headerlink" title="查看系统当前shell"></a>查看系统当前shell</h3><pre><code class="lang-js">echo $SHELL
</code></pre>
<p>结果</p>
<pre><code class="lang-js">/bin/bash
</code></pre>
<p>查看<code>/bin</code>下是否有<code>zsh</code>包</p>
<pre><code class="lang-ks">cat /etc/shells
**********************************************
返回的结果是:
/bin/sh
/bin/bash
/sbin/nologin
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
PS.默认没有安装zsh
</code></pre>
<h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装<code>zsh</code></h3><pre><code class="lang-js">sudo yum install -y zsh
</code></pre>
<p>在/bin下查看</p>
<pre><code class="lang-js">/bin/sh
/bin/bash
/sbin/nologin
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/zsh
</code></pre>
<h3 id="将zsh设置成默认shell"><a href="#将zsh设置成默认shell" class="headerlink" title="将zsh设置成默认shell"></a>将<code>zsh</code>设置成默认<code>shell</code></h3><pre><code class="lang-js">chsh -s /bin/zsh
</code></pre>
<p>修改<code>zsh</code>为默认shell需要将以前在<code>~/.bashrc</code>中的设置，复制到<code>~/.zshrc</code>中</p>
<h3 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装<code>oh-my-zsh</code></h3><p>需要先装<code>git</code></p>
<pre><code class="lang-js">sudo yum install git
</code></pre>
<p>修改<code>host</code></p>
<pre><code class="lang-jsp">vim /etc/hosts
</code></pre>
<p>添加</p>
<pre><code class="lang-js">199.232.28.133 raw.githubusercontent.com
</code></pre>
<p>下载</p>
<pre><code class="lang-js">sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
</code></pre>
<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes" target="_blank" rel="noopener">主题</a></p>
<p>选择一款主题，修改<code>~/.zshrc</code></p>
<pre><code class="lang-js">vim ~/.zshrc
</code></pre>
<p>将<code>ZSH_THEME</code>更改为选择的主题 <code>jonathan</code></p>
<p>更新配置</p>
<p><code>source ~/.zshrc</code></p>
<p>重启</p>
<p><code>reboot</code></p>
<p>我的样式</p>
<p><code>aliyun Centos7</code></p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1glyrclljeyj31hk0t4u0x.jpg" alt="阿里云"></p>
<p><code>tencent Centos7</code></p>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1glyrcizjn6j31hk0t44qq.jpg" alt="腾讯云"></p>
<h2 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h2><p>在<code>powershell</code>中执行</p>
<pre><code>PowerShell -Command &quot;Set-ExecutionPolicy RemoteSigned -scope Process; iwr -useb https://raw.githubusercontent.com/gerardog/gsudo/master/installgsudo.ps1 | iex&quot;
</code></pre><p>安装过程会询问你是否打算使用<code>sudo</code>作为<code>gsudo</code>的别名，这里可以根据个人需要进行选择。<br>运行结尾显示<code>Done</code>即表明安装完成</p>
<p>安装完成后，在<code>setting.json</code>中添加<code>list</code></p>
<pre><code class="lang-js">{
                &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;,
                &quot;hidden&quot;: false,
                &quot;name&quot;: &quot;PowerShell Administra&quot;,
                &quot;commandline&quot;: &quot;sudo.exe powershell.exe&quot;,
                &quot;tabTitle&quot;: &quot;PowerShell Administra&quot;,

                // morec
                // 背景图片
                &quot;acrylicOpacity&quot;: 0.25, 
                &quot;backgroundImage&quot;: &quot;E:/picture/2020-12-07/wallhaven-y87dxx.jpg&quot;,
                &quot;backgroundImageOpacity&quot;: 0.25,
                &quot;backgroundImagerStretchMode&quot;: &quot;fill&quot;,

                &quot;padding&quot;: &quot;0, 0, 0, 0&quot;,
                // 键入时窗口滚动到输入行
                &quot;snapOnInput&quot;: true, 
                // 打开时的目录
                &quot;startingDirectory&quot;: &quot;.&quot;, 
                // tab标题
                &quot;tabTitle&quot;: &quot;powershell&quot;, 
                // 使用acrylic
                &quot;useAcrylic&quot;: false, 

                //主题
                    &quot;colorScheme&quot;: &quot;Cobalt Neon&quot;,
            },
</code></pre>
<p>在普通的<code>powershell</code>中执行<code>sudo</code>，也可以升级成管理员</p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>win Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>利用hexo多个设备更新博客</title>
    <url>//1351aa80/</url>
    <content><![CDATA[<h2 id="多台电脑控制一个hexo博客"><a href="#多台电脑控制一个hexo博客" class="headerlink" title="多台电脑控制一个hexo博客"></a>多台电脑控制一个hexo博客</h2><h2 id="1-下载Git"><a href="#1-下载Git" class="headerlink" title="1.下载Git"></a>1.下载Git</h2><h2 id="2-下载Node-js"><a href="#2-下载Node-js" class="headerlink" title="2.下载Node.js"></a>2.下载Node.js</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></p>
<p>版本不要太高</p>
<h2 id="3-新电脑创建新的ssh密钥"><a href="#3-新电脑创建新的ssh密钥" class="headerlink" title="3.新电脑创建新的ssh密钥"></a>3.新电脑创建新的ssh密钥</h2><p>在Git-bash中</p>
<p><code>ssh-keygen -t rsa -C &#39;your_email@example.com&#39;</code></p>
<p>在github-&gt;<code>setting</code>-&gt;<code>SSH &amp;&amp; GPG keys</code>-&gt;<code>new ssh key</code></p>
<p>测试是否成功</p>
<p><code>ssh -T git@github.com</code></p>
<p>如果出现</p>
<pre><code>Hi username! You&#39;ve successfully authenticated, but GitHub does not 
provide shell access.
</code></pre><h3 id="3-1-设置用户信息"><a href="#3-1-设置用户信息" class="headerlink" title="3.1 设置用户信息"></a>3.1 设置用户信息</h3><pre><code class="lang-js">$ git config --global user.name &quot;用户名&quot;
$ git config --global user.email  &quot;你希望的邮箱名&quot;
</code></pre>
<h2 id="4-资源配置依赖"><a href="#4-资源配置依赖" class="headerlink" title="4. 资源配置依赖"></a>4. 资源配置依赖</h2><h3 id="4-1-更换淘宝镜像"><a href="#4-1-更换淘宝镜像" class="headerlink" title="4.1 更换淘宝镜像"></a>4.1 更换淘宝镜像</h3><pre><code>npm config set registry https://registry.npm.taobao.org
npm i -g express
</code></pre><h3 id="4-2-安装hexo"><a href="#4-2-安装hexo" class="headerlink" title="4.2 安装hexo"></a>4.2 安装hexo</h3><p><code>npm install -g hexo-cli</code></p>
<h3 id="4-3-利用package-json部署资源"><a href="#4-3-利用package-json部署资源" class="headerlink" title="4.3 利用package.json部署资源"></a>4.3 利用<code>package.json</code>部署资源</h3><pre><code class="lang-json">{
  &quot;name&quot;: &quot;hexo-site&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;private&quot;: true,
  &quot;hexo&quot;: {
    &quot;version&quot;: &quot;3.9.0&quot;
  },
  &quot;dependencies&quot;: {
    &quot;acorn&quot;: &quot;^7.1.1&quot;,
    &quot;core-js&quot;: &quot;^3.2.1&quot;,
    &quot;dependencies&quot;: &quot;0.0.1&quot;,
    &quot;eslint&quot;: &quot;^6.6.0&quot;,
    &quot;hexo&quot;: &quot;^3.9.0&quot;,
    &quot;hexo-abbrlink&quot;: &quot;^2.0.5&quot;,
    &quot;hexo-asset-image&quot;: &quot;0.0.1&quot;,
    &quot;hexo-deployer-git&quot;: &quot;^1.0.0&quot;,
    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,
    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,
    &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;,
    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,
    &quot;hexo-generator-json-content&quot;: &quot;^4.1.6&quot;,
    &quot;hexo-generator-searchdb&quot;: &quot;^1.0.8&quot;,
    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,
    &quot;hexo-less&quot;: &quot;^0.1.0&quot;,
    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,
    &quot;hexo-renderer-kramed&quot;: &quot;^0.1.4&quot;,
    &quot;hexo-renderer-less&quot;: &quot;^1.0.0&quot;,
    &quot;hexo-renderer-mathjax&quot;: &quot;^0.6.0&quot;,
    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,
    &quot;hexo-server&quot;: &quot;^0.3.3&quot;,
    &quot;hexo-symbols-count-time&quot;: &quot;^0.6.3&quot;,
    &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot;,
    &quot;peer&quot;: &quot;^0.2.10&quot;
  }
}
</code></pre>
<pre><code>npm install
</code></pre><h2 id="5-hexo提交"><a href="#5-hexo提交" class="headerlink" title="5.hexo提交"></a>5.hexo提交</h2><pre><code>hexo clean
hexo g
hexo d
</code></pre>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 配置Vue</title>
    <url>//9c6f56ad/</url>
    <content><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Auto-Close-Tag"><a href="#Auto-Close-Tag" class="headerlink" title="Auto Close Tag"></a>Auto Close Tag</h3><p>自动关闭标签</p>
<h3 id="background-cover"><a href="#background-cover" class="headerlink" title="background-cover"></a>background-cover</h3><p>可以设置壁纸</p>
<h3 id="BetterComments"><a href="#BetterComments" class="headerlink" title="BetterComments"></a>BetterComments</h3><p>注释可以变颜色，便于区分</p>
<p>默认五种颜色</p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gl5vwju72tj304r03xmxg.jpg" alt="img1"></p>
<h3 id="Bracket-Pair-Colorizer-2"><a href="#Bracket-Pair-Colorizer-2" class="headerlink" title="Bracket Pair Colorizer 2"></a>Bracket Pair Colorizer 2</h3><p>括号匹配并能标颜色</p>
<h3 id="Code-Spell-Checker"><a href="#Code-Spell-Checker" class="headerlink" title="Code Spell Checker"></a>Code Spell Checker</h3><p>检查错误单词，并给出相近单词</p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gl5w081g3lj307b08u3zu.jpg" alt="img2"></p>
<h3 id="EditorConfig-fot-VS-Code"><a href="#EditorConfig-fot-VS-Code" class="headerlink" title="EditorConfig fot VS Code"></a>EditorConfig fot VS Code</h3><p>让vscode支持.editorconfig文件</p>
<p>.editorconfig文件可以规范编码风格和设置</p>
<h4 id="在项目根目录建立-editorconfig文件"><a href="#在项目根目录建立-editorconfig文件" class="headerlink" title="在项目根目录建立.editorconfig文件"></a>在项目根目录建立<code>.editorconfig</code>文件</h4><pre><code class="lang-js">[*.{js,jsx,ts,tsx,vue}]
indent_style = space
indent_size = 2
trim_trailing_whitespace = true
insert_final_newline = true
</code></pre>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>对文件进行校验，并可在保存时自动修复错误</p>
<h4 id="在vscode配置文件中"><a href="#在vscode配置文件中" class="headerlink" title="在vscode配置文件中"></a>在vscode配置文件中</h4><pre><code class="lang-js">{
  // eslint配置项，保存时自动修复错误
  &quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll&quot;: true
  }
}
</code></pre>
<h4 id="在项目根目录建立-eslintrc-js文件"><a href="#在项目根目录建立-eslintrc-js文件" class="headerlink" title="在项目根目录建立.eslintrc.js文件"></a>在项目根目录建立<code>.eslintrc.js</code>文件</h4><pre><code class="lang-js">module.exports = {
  root: true,
  env: {
    node: true,
  },
  extends: [&#39;plugin:vue/essential&#39;, &#39;@vue/standard&#39;],
  parserOptions: {
    parser: &#39;babel-eslint&#39;,
  },
  rules: {
    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,
    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;error&#39; : &#39;off&#39;,
  },
}
</code></pre>
<h3 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h3><p>本地预览界面，右键html文件选择<code>Open with Live Seriver</code></p>
<h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h2><p>对<code>js html</code>文件格式化</p>
<h4 id="在项目根目录建立-prettierrc文件"><a href="#在项目根目录建立-prettierrc文件" class="headerlink" title="在项目根目录建立.prettierrc文件"></a>在项目根目录建立<code>.prettierrc</code>文件</h4><pre><code class="lang-js">{
  &quot;semi&quot;: false,
  &quot;singleQuote&quot;: true
}
</code></pre>
<h4 id="在VScode-配置文件中加入"><a href="#在VScode-配置文件中加入" class="headerlink" title="在VScode 配置文件中加入"></a>在VScode 配置文件中加入</h4><pre><code class="lang-js">// 保存时自动格式化代码
  &quot;editor.formatOnSave&quot;: true,
  // 默认使用prettier格式化支持的文件
  &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,
  // 指定 *.vue 文件的格式化工具为vetur，防止和prettier冲突
  &quot;[vue]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;octref.vetur&quot;
  },
  // 指定 *.js 文件的格式化工具为vscode自带，以符合ESLint规范
  &quot;[javascript]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;vscode.typescript-language-features&quot;
  }
</code></pre>
<h3 id="Vetur"><a href="#Vetur" class="headerlink" title="Vetur"></a>Vetur</h3><p>代码高亮，代码片段，Emmet语法支持，语法错误校验检查，格式化代码，代码提醒，对第三方UI框架支持</p>
<h4 id="在vscode配置文件中-1"><a href="#在vscode配置文件中-1" class="headerlink" title="在vscode配置文件中"></a>在vscode配置文件中</h4><pre><code class="lang-js">  // 将vetur的js格式化工具指定为vscode自带的
  &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;,
  // 移除js语句的分号
  &quot;javascript.format.semicolons&quot;: &quot;remove&quot;,
  // 在函数名后面加上括号，类似这种形式 foo () {}
  &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true
</code></pre>
<h3 id="Eva-Theme"><a href="#Eva-Theme" class="headerlink" title="Eva Theme"></a>Eva Theme</h3><p>Eva 主题</p>
<h2 id="我的配置文件"><a href="#我的配置文件" class="headerlink" title="我的配置文件"></a>我的配置文件</h2><pre><code class="lang-json">{
  &quot;editor.fontFamily&quot;: &quot;Cascadia Code&quot;,
  &quot;editor.fontSize&quot;: 20,
  &quot;editor.fontWeight&quot;: &quot;300&quot;,
  &quot;editor.fontLigatures&quot;: true,
  &quot;terminal.integrated.fontSize&quot;: 20,
  &quot;terminal.integrated.fontWeight&quot;: &quot;300&quot;,
  &quot;terminal.integrated.cursorStyle&quot;: &quot;underline&quot;,
  &quot;debug.console.fontSize&quot;: 18,
  &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;,
  &quot;explorer.confirmDelete&quot;: false,
  &quot;files.autoSave&quot;: &quot;onFocusChange&quot;,

  // 保存时自动格式化代码
  &quot;editor.formatOnSave&quot;: true,
  // eslint配置项，保存时自动修复错误
  &quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll&quot;: true
  },

  // 让vetur使用vs自带的js格式化工具，以便在函数前面加个空格
  &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;,
  &quot;javascript.format.semicolons&quot;: &quot;remove&quot;,
  &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,

  // 指定 *.vue 文件的格式化工具为vetur
  &quot;[vue]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;octref.vetur&quot;
  },

  // 指定 *.js 文件的格式化工具为vscode自带
  &quot;[javascript]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;vscode.typescript-language-features&quot;
  },

  // 默认使用prettier格式化支持的文件
  &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,

  &quot;better-comments.multilineComments&quot;: true,
  &quot;better-comments.highlightPlainText&quot;: false,
  &quot;cSpell.enableFiletypes&quot;: [&quot;vue&quot;, &quot;vue-html&quot;],
  &quot;workbench.colorTheme&quot;: &quot;Eva Dark Italic&quot;,
  &quot;explorer.confirmDragAndDrop&quot;: false,
  &quot;editor.tabSize&quot;: 2,
  &quot;backgroundCover.imagePath&quot;: &quot;e:\\picture\\2020-12-11\\wallhaven-e7ozz8.png&quot;,
  &quot;git.confirmSync&quot;: false,
  &quot;git.autofetch&quot;: true,
  &quot;backgroundCover.randomImageFolder&quot;: &quot;e:\\picture\\2020-12-07&quot;,
  &quot;backgroundCover.autoStatus&quot;: false,
  &quot;backgroundCover.opacity&quot;: 0.5,
  &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,
  &quot;git.enableSmartCommit&quot;: true,
  &quot;window.zoomLevel&quot;: 1
}
</code></pre>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一下利用tcp使得服务器与android客户端相连</title>
    <url>//b4b2d023/</url>
    <content><![CDATA[<h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><p>租一个简单的服务器，</p>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1gjxbgzkd7zj30k004baa5.jpg" alt="服务器"></p>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>首先将我们需要的端口打开</p>
<pre><code>firewall-cmd --zone=public --add-port=6666/tcp --permanent   # 开放6666端口
firewall-cmd --reload   # 配置立即生效
</code></pre><p>用<code>firewall-cmd --zone=public --list-ports</code> 查看一下是否开启</p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gjxbmaskt3j30u00vdk4g.jpg" alt></p>
<p>有时阿里云服务器的端口也得打开，这个自行百度即可。</p>
<h2 id="seriver-c"><a href="#seriver-c" class="headerlink" title="seriver.c"></a>seriver.c</h2><pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;

#define SERV_PORT 6666

char rbuf[1024];

int main() {
        int sockfd,clientfd, size, ret, on = 1;
        struct sockaddr_in saddr, raddr;

//      设置地址信息，ip信息
        size = sizeof(struct sockaddr_in);
        bzero(&amp;saddr, size);
        saddr.sin_family = AF_INET;
        saddr.sin_port = htons(SERV_PORT);
        saddr.sin_addr.s_addr = htonl(INADDR_ANY);

// 创建UDP套接字
        sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if(sockfd &lt; 0) {
                perror(&quot;Socket failed.&quot;);
                exit(1);
        }

//设置端口复用
        setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));

// 绑定地址信息，IP信息
        ret = bind(sockfd, (struct sockaddr*)&amp;saddr, sizeof(struct sockaddr));
        if(ret &lt; 0) {
                perror(&quot;sbind failed.&quot;);
                exit(2);
        }

        listen(sockfd, 128);

        socklen_t val = sizeof(struct sockaddr);
        puts(&quot;waiting connect...&quot;);
        clientfd = accept(sockfd, (struct sockaddr*)&amp;raddr, &amp;val);
        puts(&quot;get!&quot;);

// 循环接受客户端发来的信息
        while(1) {
                puts(&quot;waiting data....&quot;);
                read(clientfd, rbuf, sizeof(rbuf));
                printf(&quot;客户端传来数据: %s\n&quot;, rbuf);
                strncpy(rbuf, &quot;hello world too.\n&quot;, sizeof(&quot;hello world too.\n&quot;));
                write(clientfd, rbuf, sizeof(rbuf));
                printf(&quot;发送给客户端数据: %s&quot;, rbuf);
                bzero(rbuf, 50);

        }

        close(sockfd);
        close(clientfd);
        return 0;
}
</code></pre>
<h1 id="Android-客户端"><a href="#Android-客户端" class="headerlink" title="Android 客户端"></a>Android 客户端</h1><h2 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h2><p>应为tcp的服务端是用c语言写的，所以为了android能够连接，我使用了ndk，ndk具体的配置可以自行百度。</p>
<h2 id="网络权限"><a href="#网络权限" class="headerlink" title="网络权限"></a>网络权限</h2><p>因为要进行网络连接，所以我们必须在mainfests文件中申请网络权限。如果没有权限创建socket会直接失败。</p>
<p>在application上面加上一句即可</p>
<pre><code class="lang-java"> &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre>
<h2 id="layout文件"><a href="#layout文件" class="headerlink" title="layout文件"></a>layout文件</h2><pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/send_link&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;发送连接&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintHorizontal_bias=&quot;0.498&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        app:layout_constraintVertical_bias=&quot;0.374&quot; /&gt;

    &lt;TextView
        android:text=&quot;TextView&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@+id/send_link&quot;
        android:layout_alignStart=&quot;@+id/send_link&quot;
        android:layout_marginTop=&quot;69dp&quot;
        android:id=&quot;@+id/textView&quot;
        tools:ignore=&quot;MissingConstraints&quot; /&gt;


&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
<h2 id="MainActivity文件"><a href="#MainActivity文件" class="headerlink" title="MainActivity文件"></a>MainActivity文件</h2><pre><code class="lang-java">package com.example.test2;

import androidx.appcompat.app.AppCompatActivity;

import android.annotation.SuppressLint;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    // Used to load the &#39;native-lib&#39; library on application startup.
    static {
        System.loadLibrary(&quot;native-lib&quot;);
    }

    public EditText editText;

    public static native String linkTest();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // Example of a call to a native method
        Button button = findViewById(R.id.send_link);
        editText = findViewById(R.id.editText);
        button.setOnClickListener(new View.OnClickListener() {
            @SuppressLint(&quot;WrongConstant&quot;)
            @Override
            public void onClick(View v) {
                new Thread(new Runnable() { //网络连接必须在子线程中
                    @Override
                    public void run() {
                        String ret = linkTest();
                        Log.d(&quot;s&quot;, ret);
                        //Toast.makeText(getApplicationContext(), linkTest(), 1).show();
                    }
                }).start();
            }
        });
    }

}
</code></pre>
<h2 id="cpp文件"><a href="#cpp文件" class="headerlink" title="cpp文件"></a>cpp文件</h2><pre><code class="lang-c">#include &lt;jni.h&gt;
#include &lt;string&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;android/log.h&gt;

#define  LOG_TAG    &quot;mysocket&quot;
#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)

#define SERV_IP &quot;123.56.252.111&quot;
#define SERV_PORT 6666

extern &quot;C&quot;
JNIEXPORT jstring JNICALL
Java_com_example_test2_MainActivity_linkTest(JNIEnv *env, jclass clazz) {
    int cfd;
    struct sockaddr_in serv_addr;
    socklen_t serv_addr_len;

    cfd = socket(AF_INET, SOCK_STREAM, 0);
    if(cfd &lt; 0) {
        return env-&gt;NewStringUTF(&quot;socket failed.&quot;);
    }
    LOGI(&quot;socket successful&quot;);
    memset(&amp;serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(SERV_PORT);
    inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr);
    LOGI(&quot;connecting!&quot;);
    int ret = connect(cfd, (sockaddr *)&amp;serv_addr, sizeof(serv_addr));
    if(ret &lt; 0) {
        LOGI(&quot;connect failed.&quot;);
        return env-&gt;NewStringUTF(&quot;连接失败&quot;);
    }
    LOGI(&quot;connect successful&quot;);
    char buf[1024] = &quot;hello world\n&quot;;
    write(cfd, buf, sizeof(buf));
    bzero(buf, 1024);
    read(cfd, buf, sizeof(buf));

    return env-&gt;NewStringUTF(buf);
}
</code></pre>
<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>我们点击模拟器中的连接按钮，可以在android日志中发现连接成功，并成功相互发送数据</p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gjxcbubznej31yd07qq6a.jpg" alt></p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>连接服务器</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下远程服务器mysql连接</title>
    <url>//c700630f/</url>
    <content><![CDATA[<h2 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h2><p>因为项目需要一个数据库，所以就在阿里云哪里用云翼计划买了一个小型服务器，虽然小但是也够用</p>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1gf4t674wa9j30fv059dfs.jpg" alt="img1"></p>
<h2 id="centos-安装mysql"><a href="#centos-安装mysql" class="headerlink" title="centos 安装mysql"></a><code>centos</code> 安装<code>mysql</code></h2><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装<code>mysql</code></h3><pre><code class="lang-js">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
yum -y install mysql57-community-release-el7-10.noarch.rpm
yum -y install mysql-community-server
</code></pre>
<h3 id="设置数据库"><a href="#设置数据库" class="headerlink" title="设置数据库"></a>设置数据库</h3><h4 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动<code>mysql</code></h4><pre><code class="lang-js">systemctl start  mysqld.service
</code></pre>
<h4 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h4><pre><code class="lang-js">systemctl status mysqld.service
</code></pre>
<h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><p>先查看原始密码</p>
<pre><code class="lang-js">grep &quot;password&quot; /var/log/mysqld.log
</code></pre>
<p>利用原始密码进入数据库</p>
<pre><code class="lang-js">mysql -uroot -p
</code></pre>
<p>修改密码规则</p>
<pre><code class="lang-js">mysql&gt; set global validate_password_policy=0;
mysql&gt; set global validate_password_length=1;
</code></pre>
<p>修改密码</p>
<pre><code class="lang-js">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;
</code></pre>
<h2 id="windows-mysql安装"><a href="#windows-mysql安装" class="headerlink" title="windows mysql安装"></a><code>windows mysql</code>安装</h2><h3 id="下载-amp-解压"><a href="#下载-amp-解压" class="headerlink" title="下载 &amp; 解压"></a>下载 &amp; 解压</h3><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">链接</a></p>
<h3 id="配置系统变量"><a href="#配置系统变量" class="headerlink" title="配置系统变量"></a>配置系统变量</h3><p>找到<code>bin</code>目录的位置：<code>E:\Config\mysql\mysql-5.7.32-winx64\bin</code></p>
<p>在环境变量的<code>path</code>中加入路径</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="生成data文件"><a href="#生成data文件" class="headerlink" title="生成data文件"></a>生成<code>data</code>文件</h4><p>以管理员身份运行<code>cmd</code></p>
<p>进入<code>E:\Config\mysql\mysql-5.7.32-winx64\bin</code>中</p>
<p>执行命令：<code>mysqld --initialize-insecure --user=mysql</code> 在<code>E:\Config\mysql\mysql-5.7.32-winx64\</code>下和<code>bin</code>同级目录生成<code>data</code>目录</p>
<h4 id="安装mysql-1"><a href="#安装mysql-1" class="headerlink" title="安装mysql"></a>安装<code>mysql</code></h4><p>继续执行</p>
<pre><code class="lang-js">mysqld -install
</code></pre>
<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><pre><code class="lang-js">net start MySQL
</code></pre>
<h4 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录<code>mysql</code></h4><pre><code class="lang-js">mysql -u root -p
</code></pre>
<p>初始数据库没密码，直接回车</p>
<h4 id="修改密码-1"><a href="#修改密码-1" class="headerlink" title="修改密码"></a>修改密码</h4><p>执行</p>
<pre><code class="lang-js">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;
</code></pre>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>使用<code>ubuntu</code>下的命令就可以自动安装<code>mysql</code>数据库</p>
<pre><code class="lang-html">sudo apt-get install mysql-server
apt-get isntall mysql-client
sudo apt-get install libmysqlclient-dev
</code></pre>
<p>安装成功后输入下面指令</p>
<p><strong><code>sudo netstat -tap | grep mysq</code></strong></p>
<p>如果是下图这样</p>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1gf4tfwa2pcj30nf014dfp.jpg" alt="img2"></p>
<p>那么就成功安装了，下面就是通过<strong><code>mysql -u root -p</code></strong>就可以登录<code>mysql</code>数据库</p>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gf4tk9c4g8j30ji074aaa.jpg" alt="img3"></p>
<p><strong>注意，在第一次登录<code>mysql</code>时输入的密码即为你的初始密码，不输就是空</strong></p>
<h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><p>在<code>ubuntu</code>下，修改<strong><code>/etc/mysql/mysql.conf.d/mysqld.cnf</code></strong>文件，将</p>
<p><strong><code>bind-address = 127.9.0.1</code></strong>语句注释掉或者改成<strong><code>bind-address=0.0.0.0</code></strong></p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gf4tqpv8czj30gv09rweo.jpg" alt="img4"></p>
<p><strong><code>bind-address = 127.9.0.1</code></strong> 意味着只允许本地登录，而把他改成<strong><code>0.0.0.0</code></strong>就代表允许所有的<code>ip</code>登录</p>
<p>但是这还不够，当我们连接远程数据库时，会新建一个<code>root</code> 用户，但是这个<code>root</code>只允许本地登录，不允许远程登陆，我们可以通过</p>
<pre><code class="lang-sql">use mysql
select host, user from user;
</code></pre>
<p>来验证发现这个<strong><code>root</code></strong>的 <strong><code>host</code></strong>只有一个<strong><code>localhost</code></strong></p>
<p>这是我们要通过设置来使他允许远程用户登录</p>
<p>在<code>mysql</code> 中输入</p>
<pre><code class="lang-sql"># 允许所有root用户登录
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root用户密码&#39; WITH GRANT OPTION;
# 允许指定ip的root用户登录
GRANT ALL PRIVILEGES ON *.* TO root@&#39;指定的IP地址&#39; IDENTIFIED BY &#39;root用户密码&#39; WITH GRANT OPTION;
</code></pre>
<p>然后重载授权表</p>
<p><code>FLUSH PRIVILEGES;</code></p>
<p>这时我们再来验证一下root的权限</p>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1gf4wgkwzwaj309n05vdfr.jpg" alt="img5"></p>
<p>这时就应该可以连接上了</p>
<p><strong>但是</strong> ,如果这时还是连接不上，就可能是防火墙的问题，输入<code>ufw disable</code>把防火墙关闭</p>
<p><strong>如果</strong>还不行的话，就有可能是阿里云的问题了，因为我用的是一个轻量级的服务器，所以在防火墙中把端口3306打开即可</p>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gf4wnimwtxj30l206paa5.jpg" alt="img6"></p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>经过以上步骤<code>mysql</code>的远程连接基本上就可以搞定了</p>
<pre><code class="lang-js">mysql -h IP -u root -p
</code></pre>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gf4wpo7tfgj30in07d74g.jpg" alt="img7"></p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>连接MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取88ys视频exe版</title>
    <url>//581490d4/</url>
    <content><![CDATA[<h2 id="爬取88ys视频"><a href="#爬取88ys视频" class="headerlink" title="爬取88ys视频"></a>爬取88ys视频</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>点击dist中的<code>main.exe</code> 找到想下载的视频主页面</p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gcefjor7i5j31e50hdtg1.jpg" alt></p>
<p>粘贴到url文本框</p>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1gcefk892quj30g40apdgo.jpg" alt></p>]]></content>
      <categories>
        <category>Spider</category>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>爬视频</tag>
      </tags>
  </entry>
  <entry>
    <title>wallpaper 模拟登录</title>
    <url>//72810b67/</url>
    <content><![CDATA[<p>在模拟登录wallhaven是，发现了一些问题，用request.session登录并保存cookie并不奏效</p>
<p>所以决定自己手动保存cookie</p>
<h3 id="先是登录"><a href="#先是登录" class="headerlink" title="先是登录"></a>先是登录</h3><p>因为登录信息中有<code>_token</code>，所以要先get一下获取网页的<code>_token</code> ，并且用get到的cookie来请求登录</p>
<pre><code class="lang-py">    def __init__(self):
        self.get_url = &quot;https://wallhaven.cc/login&quot;
        self.post_url = &quot;https://wallhaven.cc/auth/login&quot;
        self.proxies = spider_proxy.SpiderProxy()
        self.data = {}
        self._token = &quot;&quot;
        self.cookies = {}
        self.Is = False

    # 1. 请求页面获得_token 和 cookie
    def get_html(self):
        response = requests.get(self.get_url, headers=self.proxies.header, proxies=self.proxies.proxy)
        response_data = response.content.decode(&#39;utf-8&#39;)

        self._token = re.findall(r&#39;&lt;meta name=&quot;csrf-token&quot; content=&quot;(.*?)&quot;&gt;&#39;, response_data, re.S)

        cookies = &quot;&quot;
        for cookie in response.cookies:
            cookies += cookie.name + &quot;=&quot; + cookie.value + &quot;;&quot;

        # 用header来携带cookie
        self.proxies.header[&#39;Cookie&#39;] = cookies

    # 2.装填data
    def combined_data(self):
        self.data = {
            &#39;_token&#39;: self._token,
            &#39;username&#39;: &#39;643719884@qq.com&#39;,
            &#39;password&#39;: &#39;dhl643719884&#39;
        }
</code></pre>
<p>这样可以登录，但是在用这个user-agent去请求数据是，不是登录后的状态，</p>
<p>抓包后发线登录以后的cookie和未登录的cookie只有remeber_web的差别</p>
<p>而remeber_web在请求登录的post的返回值里，那么</p>
<pre><code class="lang-py"># login以后的cookie请求
__cfduid=d7e60a37935c5d9c6f53f05ab1064e1681580787848; 
remember_web_59ba36addc2b2f9401580f014c7f58ea4e30989d=eyJpdiI6ImROQ29VNGRicnZsOW0wQW5BTzZVa1E9PSIsInZhbHVlIjoiTmNQT0h2TE03YW5yaUdhbWZDZnlQYlZzanN3UTV4aUdiMHh1bUl5cjVJMXdQbzIxYnF6bElYcFpmMERPY0ZcL3FnZ21xcU5WdXlvMlBBK21CeEs2K2FWV1pUK05sTmdDdFlHSWl4TlBwUHpuaEprV1dXYmZRbkZzWU1STjV6S3JONWsxNjBsekttbXFqd1BQTzhENlcwNzF0dVRvUit6eURxdHhrN1pZblo4U3lUMys2ekNLdTlXTllBXC82dkI3VUEiLCJtYWMiOiJkYmNiOTZiNDU3M2NjY2M3OGJjZWM4ZTBjZmJlZmIwMTBhMTM5MTcwMTA3ZDc1NjliNDM0ZmM1OWFkY2VhN2YwIn0%3D
_pk_ref.1.01b8=%5B%22%22%2C%22%22%2C1581400207%2C%22http%3A%2F%2Flocalhost%3A63342%2FPyCharnPython%2Fday04%2Fawewall.html%3F_ijt%3Dog5l1ar0obspirlv150bfq3d1o%22%5D
_pk_id.1.01b8=e6d2c9622d153c11.1580787918.21.1581400207.1581400207.
XSRF-TOKEN=eyJpdiI6IjE4NzVZTlQrXC9pWFBmVlFsMUFvVFpBPT0iLCJ2YWx1ZSI6Im91OUROUEFZVHlsNWJ5bjdLa2pyQkV5R0RYZmNMNVN1TkJ5bERSTmFWaGFGRjUyaDI0K09aYzVVTUhZYzhnM0oiLCJtYWMiOiI0MTgzZmMyYzg0YmYyYmE2ZjgxNTEzMDBjYjI1NjFhOGYyMDZhNmJlZjkyYzBlMzhhYTNmNzA0MjBlZDQ3MDZhIn0%3D
wallhaven_session=eyJpdiI6IjZQNVJcL3F0bXJhNndKUkc3QUVCTTZ3PT0iLCJ2YWx1ZSI6IjVSNHlRRjl0cU1sNEFMUGdCUkpFU0lOWXpZUjAzc1d4cHo1NnpLYlk2SU9kXC9zMldpekJKQ1NSMTI2aHIrWDJGIiwibWFjIjoiOWI3YjRlZGU0YTZiZWNkYjZmMWI4MGVlOGFhOThmNzdhOGUwZWQ2ODAxZjFjMGU4MzA1NDJiYjMwZDE3YzQ1OSJ9
</code></pre>
<pre><code class="lang-py"># 没有login的cookie请求
__cfduid=d7e60a37935c5d9c6f53f05ab1064e1681580787848
_pk_ref.1.01b8=%5B%22%22%2C%22%22%2C1581402095%2C%22http%3A%2F%2Flocalhost%3A63342%2FPyCharnPython%2Fday04%2Fawewall.html%3F_ijt%3Dog5l1ar0obspirlv150bfq3d1o%22%5D
_pk_ses.1.01b8=1
_pk_id.1.01b8=e6d2c9622d153c11.1580787918.22.1581402949.1581402095.
XSRF-TOKEN=eyJpdiI6InRCSDFCT2dvZTZDeXVjR0w0NzZRNGc9PSIsInZhbHVlIjoiY1dzU1J4cHdENzN4eGVuU0I0NmxcL3NCblgyOWdVWEs2dTZ6QTNadHA4OHhISnZHWTFFamNIZGpibmZJQTRPcWUiLCJtYWMiOiJiNmMwMjhmMGYzYmY0MGViMWU2M2VhNTNjMTI1YTY0NThiYjU0MWFiYjYxMzRmODRkMGE5OWE5NmFlNTVkNTBjIn0%3D
wallhaven_session=eyJpdiI6IkJoY1dITVJtQWJ4bzRqamJOVkxKeFE9PSIsInZhbHVlIjoiZjBXZUI3azVRWFAwY2tZeDlHakc1Nm5sSTZFUWVLT2FsT2JFVm5VUXQ0YmszYzVwMk9HcXlaV2R5YXpheG5lMCIsIm1hYyI6IjRjNzk1M2Q4NmE1ZDI4MjAwZDY2NDczNmRlZDVjYmVlN2Y2ZDA0NjYxOTI5NTZkYWM5OWY5MTY5MDQ2YTg4NWUifQ%3D%3D
</code></pre>
<p>我们就直接组装一个cookie</p>
<pre><code class="lang-py"># 3. 组装cookie
    def combined_cookie(self):
        response = requests.post(self.post_url, headers=self.proxies.header, proxies=self.proxies.proxy, data=self.data)

        # 这里拿到的cookie是相对比较齐全的cookie，主要用这个cookie来组装
        post_cookies = response.request.headers[&#39;Cookie&#39;]
        post_cookies_list = post_cookies.split(&quot;; &quot;)

        # 这里cookie只要__cfduid
        temp_cookie = self.proxies.header[&#39;Cookie&#39;]
        temp_cookie_list = temp_cookie.split(&quot;;&quot;)

        # 组装
        self.cookies.update(__cfduid = temp_cookie_list[0].split(&#39;=&#39;)[1])
        for cookie in post_cookies_list:
            self.cookies[cookie.split(&#39;=&#39;)[0]] = cookie.split(&#39;=&#39;)[1]

        # header pop掉Cookie
        self.proxies.header.pop(&#39;Cookie&#39;)

    # 4.登录
    def post_html(self):
        response = requests.get(self.post_url, headers=self.proxies.header, proxies=self.proxies.proxy, cookies=self.cookies)
        print(response)
        if response.status_code == 200:
            print(&quot;Cookies获取成功&quot;)
            self.Is = True
        else:
            print(&quot;Cookies获取失败&quot;)

    def update(self):
        self.__init__()
        self.get_html()
        self.combined_data()
        self.combined_cookie()
        self.post_html()
</code></pre>
<p>这样我们就得到了登陆后访问toplist的页面</p>
<p>完整项目地址: <a href="https://github.com/Mug-9/Python-Spider" target="_blank" rel="noopener">Mug-9/Python-Spider: Spider (github.com)</a></p>
<h3 id="session-登录"><a href="#session-登录" class="headerlink" title="session 登录"></a>session 登录</h3><p>这里不可行,其他地方可行</p>
<pre><code class="lang-py">import requests
import sys

#登录时需要POST的数据
data = {
    data
    }

#设置请求头
headers = {&#39;User-agent&#39;:&#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36&#39;}

#登录时表单提交到的地址（用开发者工具可以看到）
login_url = &#39;login_url&#39;

#构造Session
session = requests.Session()

#在session中发送登录请求，此后这个session里就存储了cookie
#可以用print(session.cookies.get_dict())查看
resp = session.post(login_url, data)

#登录后才能访问的网页
url = &#39;url&#39;

#发送访问请求
resp = session.get(url)

print(resp.content.decode(&#39;utf-8&#39;))
</code></pre>]]></content>
      <categories>
        <category>Spider</category>
      </categories>
      <tags>
        <tag>模拟登录</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫爬取压缩过的数据</title>
    <url>//757817fb/</url>
    <content><![CDATA[<p>在爬取bilibili的历史记录是，发现出现了<em>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0x8b in position 1: invalid start byte</em> 错误，后来发现是因为<code>data = response.read().decode(&quot;utf-8&quot;)</code>这一句的data是压缩后的数据，无法正常解析后来对<code>data</code>进行解码就可以了</p>
<pre><code class="lang-py">import urllib.request
import urllib.parse
from io import BytesIO
import gzip
import user_agent_list

url = &#39;https://www.bilibili.com/account/history&#39;

random_user_agent = user_agent_list.getheaders()
request = urllib.request.Request(url)
request.add_header(&quot;User-Agent&quot;, random_user_agent)
response = urllib.request.urlopen(request)
data = response.read()
buf = BytesIO(data)
zip = gzip.GzipFile(fileobj=buf)
data = zip.read().decode(&#39;utf-8&#39;)
with open(&quot;cookies.html&quot;, &quot;w&quot;, encoding=&#39;utf-8&#39;) as f:
    f.write(data)
</code></pre>]]></content>
      <categories>
        <category>Spider</category>
      </categories>
      <tags>
        <tag>爬虫报错处理</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫爬取免费代理</title>
    <url>//28d5d8e8/</url>
    <content><![CDATA[<p>使用python爬取网站，可以用handler来隐藏user-agent，和使用高匿的代理ip，下面就是用不同的user-agent来爬取免费代理</p>
<p>首先要有一个user-agent的列表，我把它放在同一目录下然后import导入</p>
<pre><code class="lang-py">import requests
import user_agent_list
import re
import random


class SpiderProxy():
    def __init__(self):
        self.url = [&quot;https://www.kuaidaili.com/free/inha/1/&quot;, &quot;https://www.7yip.cn/free/?action=china&amp;page=2&quot;,
                    &quot;https://www.7yip.cn/free/?action=china&amp;page=3&quot;, ]
        self.header = user_agent_list.getheaders()
        self.proxy = {}
        self.proxies_list = []
        self.run()

    def get_proxies_list(self, url):
        try:
            response = requests.get(url, headers=self.header, timeout=3)
            response_data = response.content.decode(&#39;utf-8&#39;)

            ip_list = re.findall(r&#39;&lt;td data-title=&quot;IP&quot;&gt;(.*?)&lt;/td&gt;&#39;, response_data, re.S)
            port_list = re.findall(r&#39;&lt;td data-title=&quot;PORT&quot;&gt;(.*?)&lt;/td&gt;&#39;, response_data, re.S)
            type_list = re.findall(r&#39;&lt;td data-title=&quot;类型&quot;&gt;(.*?)&lt;/td&gt;&#39;, response_data, re.S)

            self.proxies_list = []

            for index in range(len(ip_list)):
                self.proxies_list.append(&quot;{\&#39;%s\&#39;:\&#39;%s:%s\&#39;}&quot; % (type_list[index], ip_list[index], port_list[index]))

        except Exception as e:
            print(e)

        # for tmp_proxy in tmp_list:
        #     proxy = eval(tmp_proxy)
        #     response = requests.get(&quot;www.baidu.com&quot;, headers=self.header, proxies=proxy)
        #     if response.status_code == 200:
        #         self.proxies_list.append(tmp_proxy)

    def get_proxy(self):
        while 1:
            self.proxy = eval(random.choice(self.proxies_list))
            try:
                response = requests.get(&quot;http://www.baidu.com&quot;, headers=self.header, proxies=self.proxy, timeout=3)
                if response.status_code == 200:
                    return
            except Exception as e:
                print(&quot;getProxy ------&gt; ERROR&quot;, e)

    def run(self):
        for url in self.url:
            self.get_proxies_list(url)
</code></pre>
<p>项目地址：<a href="https://github.com/Mug-9/Python-Spider/tree/master/爬取代理" target="_blank" rel="noopener">Python-Spider/爬取代理 at master · Mug-9/Python-Spider (github.com)</a></p>]]></content>
      <categories>
        <category>Python</category>
        <category>Spider</category>
      </categories>
      <tags>
        <tag>爬代理</tag>
      </tags>
  </entry>
  <entry>
    <title>杭电多校第七场</title>
    <url>//8f3d60e0/</url>
    <content><![CDATA[<h2 id="J-Just-Repeat"><a href="#J-Just-Repeat" class="headerlink" title="J: Just Repeat"></a>J: Just Repeat</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>小C和小Q打牌，两个人轮流出牌，小C先出，小C手中有n张牌，小Q有m张牌，两个人知道对方手中有什么牌，如果对手已经出过了某个数字的牌，那么自己就不能再出这种数字的牌，而对方可以一直出，问最后谁先不能出牌。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先对于双方都有的牌，我们肯定是要封对面尽量多的牌同时自己能出的牌也尽量多，我们我们就把这两个条件加一起把牌排一个序贪心拿即可，</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e5 + 7;
const int inf = 0x3f3f3f3f;
typedef pair&lt;int, int&gt; pis;

int a[maxn], b[maxn];
int n, m, p, cnt, mod;
unordered_map&lt;int, int&gt; mp;
int num[2][maxn&lt;&lt;1];
vector&lt;int&gt; vec[maxn&lt;&lt;1];

int read(){ 
    int ans=0; char last=&#39; &#39;,ch=getchar();
    while(ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) {
        last=ch;
        ch=getchar();
    }
    while(ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) {
        ans=ans*10+ch-&#39;0&#39;; 
        ch=getchar();
    }
    if(last==&#39;-&#39;) ans=-ans; 
    return ans;
}

unsigned long long k1, k2;
unsigned long long rng() {
    unsigned long long k3 = k1, k4 = k2;
    k1 = k4;
    k3 ^= k3 &lt;&lt; 23;
    k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26);
    return k2 + k4;
}

int gai(int x) {
    if(!mp[x]) mp[x] = ++cnt;   
    return mp[x];
}

int main() { 
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --) {
        mp.clear();
        for (int i = 1; i &lt;= cnt; i ++) num[0][i] = num[1][i] = 0;
        cnt = 0;
        scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;p);
        int sumn = n, summ = m;
        if(p == 1) {
            for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
            for (int i = 1; i &lt;= m; i ++) scanf(&quot;%d&quot;, &amp;b[i]);
        }else {
            scanf(&quot;%lld %lld %d&quot;, &amp;k1, &amp;k2, &amp;mod);
            for (int i = 1; i &lt;= n; i ++) a[i] = rng() % mod;
            scanf(&quot;%lld %lld %d&quot;, &amp;k1, &amp;k2, &amp;mod);
            for (int i = 1; i &lt;= m; i ++) b[i] = rng() % mod;
        }
        for (int i = 1; i &lt;= n; i ++) 
            num[0][gai(a[i])] ++;
        for (int i = 1; i &lt;= m; i ++)
            num[1][gai(b[i])] ++;
        int Max = 0;
        for (int i = 1; i &lt;= cnt; i ++) {
            if(num[0][i] &amp;&amp; num[1][i]) {
                sumn -= num[0][i];
                summ -= num[1][i];
                int sumc = num[0][i] + num[1][i]; 
                vec[sumc].push_back(num[0][i]);
                Max = max(Max, sumc);
            }
        }
        int cur = 0;
        for (int i = Max; i &gt;= 1; i --) {
            for (int v: vec[i]) {
                if(!cur) sumn += v;
                else summ += i - v;
                cur ^= 1;
            }
            vec[i].clear();
        }
        if(sumn &gt; summ) printf(&quot;Cuber QQ\n&quot;);
        else printf(&quot;Quber CC\n&quot;);
    } 
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces EduRound 74</title>
    <url>//b223976b/</url>
    <content><![CDATA[<h3 id="E-Keyboard-Purchase"><a href="#E-Keyboard-Purchase" class="headerlink" title="E: Keyboard Purchase"></a>E: Keyboard Purchase</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一个有小写字母组成的字符串，让你给每个字母编号，使得$\sum\limits<em>{i=1}^{n}|S_i-S</em>{i-1}|$的值最小</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>  因为字母种类很小，所以我们可以用类似状压来记录中间值，具体的是$dp[(1&lt;&lt;m)]$来记录当前状态出现的字母种类与还未出现的字母种类的距离。</p>
<p>我们现在先想象一个键盘，$dp[i]$的二进制表示就是键盘前几个的键，那么$dp[i]$的转移就是由$dp[i^(1&lt;&lt;j)]$新加了一位j转移得来：</p>
<pre><code class="lang-c">for (int i = 1; i &lt; (1&lt;&lt;m); i ++) {
        dp[i] = 0x3f3f3f3f;
        for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) 
            if((i&gt;&gt;j)&amp;1) dp[i] = min(dp[i], dp[i^(1&lt;&lt;j)]);
    }
</code></pre>
<p>得到的就是当前状态下的最小花费，</p>
<p>那么这样的话，原来的$dp[i^(1&lt;&lt;j)]$的状态不确定的这一位已经确定，那么其他还尚未却动的键与当前已经确定的键之间的距离要$+1$，</p>
<pre><code class="lang-c">for (int i = 1; i &lt; (1&lt;&lt;m); i ++) {
        dp[i] = 0x3f3f3f3f;
        for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) 
            if((i&gt;&gt;j)&amp;1) dp[i] = min(dp[i], dp[i^(1&lt;&lt;j)]);
        for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) 
            if((i&gt;&gt;j)&amp;1) 
                for (int k = 0; k &lt; m; k ++) 
                    if(!((i&gt;&gt;k)&amp;1)) dp[i] += adj[j][k];
    }
</code></pre>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e5 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;
typedef pair&lt;int, int&gt; pis;

int dp[(1&lt;&lt;21)];
int adj[30][30];

int main() { 
    int n, m;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    string st;
    cin &gt;&gt; st;
    for (int i = 1; i &lt; st.size(); i ++) {
        adj[st[i]-&#39;a&#39;][st[i-1]-&#39;a&#39;] ++;
        adj[st[i-1]-&#39;a&#39;][st[i]-&#39;a&#39;] ++;
    }
    for (int i = 1; i &lt; (1&lt;&lt;m); i ++) {
        dp[i] = 0x3f3f3f3f;
        for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) 
            if((i&gt;&gt;j)&amp;1) dp[i] = min(dp[i], dp[i^(1&lt;&lt;j)]);
        for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) 
            if((i&gt;&gt;j)&amp;1) 
                for (int k = 0; k &lt; m; k ++) 
                    if(!((i&gt;&gt;k)&amp;1)) dp[i] += adj[j][k];
    }
    printf(&quot;%d\n&quot;, dp[(1&lt;&lt;m)-1]);
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第十场</title>
    <url>//b961061/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一个随机排列的数列，问前缀和大于$a$的时候小于$b$的概率</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gblwgobtobj30x10iqwjr.jpg" alt="img1"></p>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1gblwgqivrcj30wt0icq7t.jpg" alt="img2"></p>
<p>大意就是枚举最后一次抽的牌的点数，找在剩下的$n-1$个牌中，前$i$个牌的前缀和范围在$[a-x,min(a,b-x)]$的概率</p>
<p>概率是$\frac{i!(n-i-1)!}{n!}$，这个概率可以预处理出来。</p>
<p>然后就是用可逆背包和滚动数组来求dp</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 510;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;
typedef pair&lt;int, int&gt; pis;

double dp[2][maxn][maxn], p[maxn];
int x[maxn];

int main() { 
    int n, a, b;
    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;a, &amp;b);
    dp[0][0][0] = 1;
    for (int i = 1; i &lt;= n; i ++) {
        scanf(&quot;%d&quot;, &amp;x[i]);
        memcpy(dp[i&amp;1], dp[(i&amp;1)^1], sizeof(dp[0]));
        for (int j = 1; j &lt;= n; j ++) 
            for (int k = x[i]; k &lt;= b; k ++) 
                dp[i&amp;1][j][k] += dp[(i&amp;1)^1][j-1][k-x[i]];
    }
    p[1] = 1./n;
    for (int i = 2; i &lt;= n; i ++)
        p[i] = p[i-1] * (i-1) / (n-i+1);
    double ans = 0;
    for (int i = 1; i &lt;= n; i ++) {
        for (int j = 1; j &lt;= n; j ++) 
            for (int k = x[i]; k &lt;= b; k ++)
                dp[n&amp;1][j][k] -= dp[n&amp;1][j-1][k-x[i]];
        for (int j = 0; j &lt; n; j ++)
            for (int k = max(0, a-x[i]+1); k &lt;= a &amp;&amp; k + x[i] &lt;= b; k ++) 
                ans += dp[n&amp;1][j][k] * p[j+1];
        for (int j = n; j &gt;= 1; j --) 
            for (int k = b; k &gt;= x[i]; k --) 
                dp[n&amp;1][j][k] += dp[n&amp;1][j-1][k-x[i]];
    }
    printf(&quot;%.15f\n&quot;, ans);
    return 0;
}
</code></pre>
<h2 id="H-Wood-Processing"><a href="#H-Wood-Processing" class="headerlink" title="H: Wood Processing"></a>H: Wood Processing</h2><p><a href="http://www.orzff.cn/f1b7e3b7/" target="_blank" rel="noopener">http://www.orzff.cn/f1b7e3b7/</a></p>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>2019ACM-ICPC南昌网络赛</title>
    <url>//4e0518cb/</url>
    <content><![CDATA[<h2 id="H-The-Nth-Item"><a href="#H-The-Nth-Item" class="headerlink" title="H: The Nth Item"></a>H: The Nth Item</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$F(0)=0,F(1)=1$</p>
<p>$F(n)= 3\times F(n-1)+2\times F(n-2)(n\ge 2)$</p>
<p>求第n项，n个询问，强制在线</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>好像直接1e6进制矩阵快速幂就可以直接过，预先打个1e6的表，但这个好像是卡过，多交几次就会T掉</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e6;
const int ll mod = 998244353;

struct Matrix{
    ll mat[2][2];

    Matrix() {memset(mat, 0, sizeof(mat));};

    void init() {
        mat[0][0] = mat[1][1] = 1;
    }

    void init(ll a, ll b) {
        mat[0][0] = 0; mat[0][1] = b;
        mat[1][0] = 1; mat[1][1] = a;
    }

    void operator = (Matrix x) {
        for (int i = 0; i &lt;= 1; i ++)
            for (int j = 0; j &lt;= 1; j ++)
                mat[i][j] = x.mat[i][j];
    }

};

Matrix operator * (Matrix x, Matrix y) {
    Matrix t;
    for (int i = 0; i &lt;= 1; i ++)
        for (int j = 0; j &lt;= 1; j ++)
            for (int k = 0; k &lt;= 1; k ++)
                t.mat[i][j] = (t.mat[i][j] + x.mat[i][k] * y.mat[k][j]) % mod;
    return t;
}

Matrix pre[4][2*maxn+10];

ll Ksm(ll b) {
    Matrix t; t.init();
    int cnt = 0;
    while(b &amp;&amp; cnt &lt; 3) {
        ++ cnt;
        ll pt = b % maxn;
        if(cnt == 3) pt = b;
        t = t * pre[cnt][pt];
        b /= maxn;
    }
    Matrix ans; 
    ans.mat[0][0] = 0; ans.mat[0][1] = 1;
    ans = ans * t;
    return ans.mat[0][0];
}

void init() {
    Matrix t; t.init(3, 2);
    pre[1][1] = t; pre[1][0].init();
    for (int i = 2; i &lt;= maxn; i ++) pre[1][i] = pre[1][i-1] * pre[1][1];
    pre[2][1] = pre[1][maxn]; pre[2][0].init();
    for (int i = 2; i &lt;= maxn; i ++) pre[2][i] = pre[2][i-1] * pre[2][1];
    pre[3][1] = pre[2][maxn]; pre[3][0].init();
    for (int i = 3; i &lt;= 2* maxn; i ++) pre[3][i] = pre[3][i-1] * pre[3][1];
}

int main() {
    init();
    ll n, q;
    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;q);
    ll ans = 0;
    for (int i = 1; i &lt;= n; i ++) {
        ll a = Ksm(q);
        q = q ^ (a * a);
        ans ^= a;
    }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gblvbmhd8ij30h0010mwz.jpg" alt></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>还有一种解法，通过打表得知询问$q$是由循环节的，最后在进行大约$1e6$次后，会有一个长度为$2$的循环节，我们就直接暴力找循环节，时间上好像比上面快一点</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const ll mod = 998244353;

struct Matrix{
    ll mat[2][2];

    Matrix() {memset(mat, 0, sizeof(mat));};

    void init() {
        mat[0][0] = mat[1][1] = 1;
    }

    void init(ll a, ll b) {
        mat[0][0] = 0; mat[0][1] = b;
        mat[1][0] = 1; mat[1][1] = a;
    }

    void operator = (Matrix x) {
        for (int i = 0; i &lt;= 1; i ++)
            for (int j = 0; j &lt;= 1; j ++)
                mat[i][j] = x.mat[i][j];
    }

};

Matrix operator * (Matrix x, Matrix y) {
    Matrix t;
    for (int i = 0; i &lt;= 1; i ++)
        for (int j = 0; j &lt;= 1; j ++)
            for (int k = 0; k &lt;= 1; k ++)
                t.mat[i][j] = (t.mat[i][j] + x.mat[i][k] * y.mat[k][j]) % mod;
    return t;
}

ll Ksm(ll b) {
    Matrix x; x.init(3, 2);
    Matrix t; t.init();
    while(b) {
        if(b &amp; 1) t = t * x;
        x = x * x;
        b &gt;&gt;= 1;
    }
    Matrix ans;
    ans.mat[0][0] = 0; ans.mat[0][1] = 1;
    ans = ans * t;
    return ans.mat[0][0];
}
map&lt;ll, int&gt; mp;

int main() {
    ll n, q;
    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;q);
    ll ans = 0, l, r, loop=-1;
    for (int i = 1; i &lt;= n; i ++) {
        if(mp[q]) {
            loop = i-1;
            l = q;
            ll a = Ksm(q);
            r = q ^ (a * a);
            break;
        }
        mp[q] = 1;
        ll a= Ksm(q);
        q = q ^ (a * a);
        ans = ans ^ a;
    }
    if(loop!=-1) {
        ll dis = n - loop;
        if(dis % 4 == 3) ans = ans ^ Ksm(r);
        if(dis % 4 == 2) ans = ans ^ Ksm(l) ^ Ksm(r);
        if(dis % 4 == 1) ans = ans ^ Ksm(l);
    }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gblvbjcjr2j30gt01aweb.jpg" alt="loop"></p>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>南昌</tag>
        <tag>题解</tag>
        <tag>网络赛</tag>
      </tags>
  </entry>
  <entry>
    <title>特征方程</title>
    <url>//ea13e7c5/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>求二阶常系数线性齐次递推数列$f<em>n=a\times f</em>{n-1} + b \times f_{n-2}$的通项公式</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>先解出特征方程$x^2-a\times x - b = 0$，两根分别是$x_1,x_2$</p>
<p>如果$x_1 != x_2$ 则$f_n=A\times x_1^n+B\times x_2^n$</p>
<p>如果$x_1=x_2$ 则$f_n=(A+B\times n)\times x_1^n$</p>
<p>（$A,B$可以通过$f_0,f_1$求出）</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>斐波那契数列$f<em>n=f</em>{n-1}+f_{n-2}$</p>
<p>求解$x^2-x-1=0$</p>
<p>$x_1=\frac{1+\sqrt{5}}{2},x_2=\frac{1-\sqrt{5}}{2}$</p>
<p>$f_0=A\times x_1^0+B\times x_2^0=0$   </p>
<p>$f_1=A\times x_1^1+B\times x_2^1=1$</p>
<p>$A=\frac{\sqrt{5}}{5}, B=\frac{-\sqrt{5}}{5}$</p>
<p>所以$f_n=\frac{\sqrt{5}}{5} \times (\frac{1+\sqrt{5}}{2})^n+\frac{-\sqrt{5}}{5}\times (\frac{1+\sqrt{5}}{2})^n$</p>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>特征方程</tag>
      </tags>
  </entry>
  <entry>
    <title>Min_25筛</title>
    <url>//ecec6bcc/</url>
    <content><![CDATA[<h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><p>在$O(\frac{n^{\frac{3}{4}}}{\log n})$时间复杂度内，来求一类完全积性函数的前缀和 $\sum\limits_{i=1}^{n}f(i)$</p>
<p>要求是$f(p)[p\in prime]$是一个关于p的简单多项式并且$f(p^e)$可以快速算出</p>
<h2 id="如何求"><a href="#如何求" class="headerlink" title="如何求"></a>如何求</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>我们可以先对$i$按照质数非质数分类</p>
<p>$\sum\limits<em>{i=1}^{n}f(i)=\sum\limits</em>{1\le p\le n} f(p) + \sum\limits_{i=1 ||i \notin prime}^nf(i)$</p>
<p>因为$f(i)$是完全积性函数，所以我们进一步把后面拆分，枚举每一个合数的最小质因子和最小质因子的次幂</p>
<p>$\sum\limits<em>{i=1}^{n}f(i)=\sum\limits</em>{1\le p\le n}f(p)+\sum\limits<em>{1\le p^e\le n \&amp; 1\le p \le \sqrt n}f(p^e)(\sum\limits</em>{1\le i \le \lfloor\frac{n}{p^e}\rfloor \&amp; min(i)&gt; p} f(i))$      $min(i)$代表$i$的最小质因子,</p>
<p>上式代表我们把合数的最小质因子以及次幂数提出来,计算那些最小质因子大于$p$的合数的值</p>
<h3 id="G-函数"><a href="#G-函数" class="headerlink" title="$G$函数"></a>$G$函数</h3><p>上式中我们要枚举$[1,n]$的每一个质数，但是n的范围可以很大， 这样就没法用线性筛筛出所有质数</p>
<p>但是我们可以考虑一个$DP$，我们令$g(n,j) = \sum\limits_{i=1}^{n}h(i)[i\in prime || min(i)&gt;p_j]$</p>
<p>其中$h(i)$是一个在质数处于$f(i)$取值相同的一个完全积性函数</p>
<p>也可以理解成原$f(i)$的所以值都参照$[i\in prime]$时的取值，把所有自然数都当成质数</p>
<p>$g(n,j)$代表$i$为质数或者$min(i)&gt;p_j$时的$h(i)$的前缀和</p>
<p>然后我们来考虑转移，怎么由$g(n,j-1)$转移到$g(n,j)$ ，因为$j$的增大，那么可满足条件的$h(i)$数量减小，</p>
<p>所以我们通过减掉一些不满足条件的$h(i)$来转移，通过观察可以发现，那些不满足条件的恰好就是最小质因子为</p>
<p>$p_j$的合数,也就是减掉$g(\frac{n}{p_j},j-1)-g(p_j-1,p_j)$，后面是减掉质数的部分，因为减掉的都是小于$p_j$的质数，这些质数已经在前面的遍历中减过了一次，不必再减</p>
<p>那么$g(n,j)=g(n,j-1)-p_j^k(g(\frac{n}{p_j},j-1)-g(p_j-1,j-1))$</p>
<p>注意后面的$g(p_j-1,j-1)$ 其实就是$h(i)$在前$j-1$个质数处的前缀和，因为$p_j\le \sqrt n$，所以我们可以用线性筛</p>
<p>筛出来，但是$n$还是很大，我们无法$DP$到$n$</p>
<p>但是因为$p_j$的范围是$\sqrt n$，而$g(n)$由所有的$g(\frac{n}{p_j})$转移而来，所以我们只要计算这$\sqrt n$ 范围内的$h(i)$即可</p>
<p>我们对下表进行离散化用两个数组来存储</p>
<p>以洛谷P5325为例</p>
<p>$g(x)=x^2,h(x)=x$</p>
<pre><code class="lang-c">void GetW(long long n) {
    for (long long i = 1, j; i &lt;= n; i = j + 1) {
        j = n / (n / i);
        w[++m] = n / i;
        long long t = w[m] % Mod;
        g[m] = t * (t + 1) % Mod * ((2LL * t + 1) % Mod) % Mod * inv_6 % Mod;
        g[m] --;
        h[m] = t * (t + 1) % Mod * inv_2 % Mod;
        h[m] --;
        if(w[m] &lt;= sqr) id1[w[m]] = m;
        else id2[n/w[m]] = m;
    }
}

void GetG(long long n) {
    for (long long i = 1; i &lt;= tot; i ++) {
        for (long long j = 1; j &lt;= m &amp;&amp; prim[i] * prim[i] &lt;= w[j]; j ++) {
            long long d = w[j] / prim[i];
            long long id = d &lt;= sqr ? id1[d] : id2[n/d];
            g[j] = Sup(g[j], prim[i] * prim[i] % Mod * ((g[id] - sumg[i-1] + Mod) % Mod) % Mod);
            h[j] = Sup(h[j], prim[i] * ((h[id] - sumh[i-1] + Mod) % Mod) % Mod);
        }
    }
}
</code></pre>
<p>这样我们就求出来了$[1,n]$中所有$h(i)$在质数处的和，$g(n)$</p>
<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>我们设$S(n,j)=\sum\limits_{i=1}^{n}f(i)[min(i) \ge p_j]$</p>
<p>那么$S(n,j)=g(n)-\sum\limits<em>{i=1}^{j-1}f(p_i)+\sum\limits</em>{p_k^e\le n\&amp; k&gt; x}f(p_k^e)(S(\frac{n}{p_k^e}, k)+[e!=1])$</p>
<p>这样跟求$g(n)$的$dp$类似,答案就是$S(n,1)+f(1)$</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="洛谷P5325"><a href="#洛谷P5325" class="headerlink" title="洛谷P5325"></a>洛谷P5325</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>定义$f(x)$, 且$f(p^k)=p^k(p^k-1)$，$p$是一个质数,求$\sum\limits_{i=1}^{n}f(i)$,对$1e9+7$取模</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>当$p$为质数时 $f(p)=p(p-1)=p^2-p$</p>
<p>设$g(x)=x^2,h(x)=x,f(x)=g(x)-h(x)$</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e6 + 5;
const int inf = 0x3f3f3f3f;
const int Mod = 1e9 + 7;
const double eps = 1e-8;
typedef pair&lt;int, int&gt; psi;
#define inv_2 (Mod+1)/2
#define inv_6 (Mod+1)/6
long long sqr, m, w[maxn], g[maxn], h[maxn];
long long sumg[maxn], sumh[maxn], id1[maxn], id2[maxn];
long long prim[maxn], tot;
bool mark[maxn];

long long Add(long long a, long long b) {
    return (a + b) % Mod;
}

long long Sup(long long a, long long b) {
    return (a - b + Mod) % Mod;
}

long long Pow(long long a, long long b) {
    long long res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % Mod;
        a = a * a % Mod;
        b &gt;&gt;= 1;
    }
    return res;
}

void init(long long n) {
    mark[1] = 1;
    for (long long i = 2; i &lt;= n; i ++) {
        if(!mark[i]) {
            prim[++tot] = i;
            sumg[tot] = (sumg[tot-1] + i * i) % Mod;
            sumh[tot] = (sumh[tot-1] + i) % Mod;
        }
        for (long long j = 1; j &lt;= tot; j ++) {
            if(i * prim[j] &gt; n) break;
            mark[i * prim[j]] = 1;
            if(i % prim[j] == 0) break;
        }
    }
}

void GetW(long long n) {
    for (long long i = 1, j; i &lt;= n; i = j + 1) {
        j = n / (n / i);
        w[++m] = n / i;
        long long t = w[m] % Mod;
        g[m] = t * (t + 1) % Mod * ((2LL * t + 1) % Mod) % Mod * inv_6 % Mod;
        g[m] --;
        h[m] = t * (t + 1) % Mod * inv_2 % Mod;
        h[m] --;
        if(w[m] &lt;= sqr) id1[w[m]] = m;
        else id2[n/w[m]] = m;
    }
}

void GetG(long long n) {
    for (long long i = 1; i &lt;= tot; i ++) {
        for (long long j = 1; j &lt;= m &amp;&amp; prim[i] * prim[i] &lt;= w[j]; j ++) {
            long long d = w[j] / prim[i];
            long long id = d &lt;= sqr ? id1[d] : id2[n/d];
            g[j] = Sup(g[j], prim[i] * prim[i] % Mod * ((g[id] - sumg[i-1] + Mod) % Mod) % Mod);
            h[j] = Sup(h[j], prim[i] * ((h[id] - sumh[i-1] + Mod) % Mod) % Mod);
        }
    }
}

long long S(long long x, long long y, long long n) {
    if(x &lt;= prim[y-1] || x &lt;= 1) return 0;
    long long id = x &lt;= sqr ? id1[x] : id2[n/x];
    long long res = (g[id] - h[id] + Mod - sumg[y-1] + sumh[y-1] + Mod) % Mod;
    for (long long i = y; i &lt;= tot &amp;&amp; prim[i] * prim[i] &lt;= x; i ++) {
        long long t = prim[i];
        for (long long j = 1; t &lt;= x; j ++, t = t * prim[i]) {
            long long p1 = t % Mod;
            res = Add(res, p1 * (p1 - 1) % Mod * (S(x/t, i+1, n) + (j != 1)) % Mod);
        }
    }
    return res % Mod;
}

int main(int argc, char *args[]) {
    long long n;
    scanf(&quot;%lld&quot;, &amp;n);
    sqr = sqrt(n);
    init(sqr);
    GetW(n);
    GetG(n);
    printf(&quot;%lld\n&quot;, (S(n, 1, n) + 1) % Mod);
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第四场</title>
    <url>//db92c5b8/</url>
    <content><![CDATA[<h2 id="E-triples-ll"><a href="#E-triples-ll" class="headerlink" title="E.triples ll"></a>E.triples ll</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>让你用$n$个3的倍数，把$a$或出来,问你有几种方案，对998244353取模</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在二进制中$1,4,16,\mod 3余1$, 而 $2,8,32 \mod 3余2$ </p>
<p>首先如果$a$中为$1$的二进制位在$b$中也都为$1$，那么就称$a$是$b$的子集</p>
<p>我们用$dp[i][j]$来表示二进制位$mod$ $3$ 余$1$的个数为$i$,$mod$ $3$ 余$2$的个数为$j$并且所有是3的倍数的子集个数</p>
<p>我们可以先一个$(logn)^4$求出所有的$dp$值</p>
<pre><code class="lang-c">void Fac() {
    for (int i = 0; i &lt; maxn; i ++) C[i][0] = 1;
    for (int i = 1; i &lt; maxn; i ++) 
        for (int j = 1; j &lt;= i; j ++) 
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
}

void init() {
    Fac();
    for (int x = 0; x &lt; maxn; x ++) 
        for (int y = 0; y &lt; maxn; y ++) 
            for (int i = 0; i &lt;= x; i ++)
                for (int j = 0; j &lt;= y; j ++) 
                    if((i+2*j)%3==0) dp[x][y] = (dp[x][y] + C[x][i] * C[y][j] % mod) % mod;
    dp[0][0] = 1;
}
</code></pre>
<p>如果要求或出来的结果是$a$的子集，那么方案数就是$(a的子集的个数)^n$</p>
<p>但是题目要求或出来的结果是$a$,那我们就要容斥一下了</p>
<p>打个比方，现在$a$的$\mod2$的个数为$1$，$\mod1$的个数为$2$</p>
<p>那么$dp[2][1]$所代表的是$<2,1>$的子集的个数，但有些子集在相或$n$次以后得不到a，这时候就要减掉那些不能或到$a$的子集 </2,1></p>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1gblwj39lltj307s06oweg.jpg" alt="img1"></p>
<p>$dp[2][1]$就像上图中由 A-E,​A-D,A-C,B-E,B-D,B-C 组成，而能或出来$a$的只有A-E,那么我们就要把其余不满足的减掉，也就是减掉$dp[1][1]+dp[2][0]$,发现减多了，我们要加上$dp[1][0]+dp[0][1]$，后面就跟容斥一样，多写几个样例就会发现当$(num1+num2-i-j)\mod2$时是减,其他是加。</p>
<p>注意：减的时候减掉的是不符合个数的$n$次幂</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int maxn = 70;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;

ll C[maxn][maxn], dp[maxn][maxn];
int cnt[2], o;

ll Ksm(ll a, ll b) {
    ll ret = 1;
    while(b) {
        if(b &amp; 1) ret = ret * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return ret;
}

void Fac() {
    for (int i = 0; i &lt; maxn; i ++) C[i][0] = 1;
    for (int i = 1; i &lt; maxn; i ++) 
        for (int j = 1; j &lt;= i; j ++) 
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
}

void init() {
    Fac();
    for (int x = 0; x &lt; maxn; x ++) 
        for (int y = 0; y &lt; maxn; y ++) 
            for (int i = 0; i &lt;= x; i ++)
                for (int j = 0; j &lt;= y; j ++) 
                    if((i+2*j)%3==0) dp[x][y] = (dp[x][y] + C[x][i] * C[y][j] % mod) % mod;
    dp[0][0] = 1;
}

int main() {
    init();
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --) {
        ll n, a;
        scanf(&quot;%lld %lld&quot;, &amp;n, &amp;a);
        cnt[0] = cnt[1] = o = 0;
        while(a) {
            if(a &amp; 1) cnt[o] ++;
            o ^= 1; a /= 2;
        }
        ll ans = 0;
        for (int i = 0; i &lt;= cnt[0]; i ++) 
            for (int j = 0; j &lt;= cnt[1]; j ++) {
                ll f = C[cnt[0]][i] * C[cnt[1]][j] % mod * Ksm(dp[i][j], n) % mod;
                if((cnt[0] + cnt[1] - i - j) &amp; 1) f *= -1;
                ans = (ans + f + mod) % mod; 
            }        
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化dp</title>
    <url>//f1b7e3b7/</url>
    <content><![CDATA[<p>具体可以参考这篇博客<a href="https://www.cnblogs.com/Judge/p/9551035.html" target="_blank" rel="noopener">https://www.cnblogs.com/Judge/p/9551035.html</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="斜率"><a href="#斜率" class="headerlink" title="斜率"></a>斜率</h3><p>斜率优化$dp$，听名字就知道是用来优化$dp$的</p>
<p>当我们在推导$dp$公式的时候，如果我们推出来的$dp$转移方程类似为：</p>
<p>$dp[i] = \min\limits<em>{x=1}^{x&lt;i}$  $or$  $\max\limits</em>{x=1}^{x&lt;i}$ ${dp[x] + f(x,i)}$  $f(x,i)是一个关于x与i的函数$</p>
<p>拿去最小值来说</p>
<p>我们考虑两个决策点$k&lt;j&lt;i$并且$j$比$k$要优</p>
<p>我们我们可以列一个不等式 $dp[j]+f(j,i)\leq dp[k]+f(k,i)$</p>
<p>展开如果可以把式子化成类似$\frac{y_j-y_k}{x_j-x_k}\leq k_i$，那么我们如果如果把每个点$(x_i,y_i)$看成一个坐标，那么</p>
<p>就表示$(x_j,y_j)$与$(x_k,y_k)$的斜率$\leq k_i$, 这样我们可以得到真正有用的点组成了一个凸包的形状</p>
<h3 id="为什么是个凸包？"><a href="#为什么是个凸包？" class="headerlink" title="为什么是个凸包？"></a>为什么是个凸包？</h3><p>当我们去最小值是，我们有一下这么几个点</p>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gblx1fca58j307v06d0sp.jpg" alt="img1"></p>
<p>我们维护一个下凸壳，那么我们找的最小值的直线一定是沿着下凸壳的边缘</p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gblx1htpwyj30bs08jq32.jpg" alt="img2"></p>
<p>所以说不处于凸壳上的点是没有意义的</p>
<p>另外：最小值维护下凸壳，最大值维护上凸壳</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="求斜率"><a href="#求斜率" class="headerlink" title="求斜率"></a>求斜率</h3><p>一般来说能推出斜率表达式的都可以用斜率优化$dp$</p>
<p>我们已经把式子化成这么一个形式$\frac{y_j-y_k}{x_j-x_k}\leq k_i$ ,那么我们求斜率可以这么写</p>
<p>如果斜率单调就用移指针，不单调就二分答案</p>
<p>以HDU 3507为例：</p>
<pre><code class="lang-c">ll getUp(ll j) {
    return dp[j] + sum[j] * sum[j];
}

ll getDown(ll j) {
    return 2 * sum[j];
}

double Calc(ll x, ll y) {
    if(getDown(x) == getDown(y)) return -1e9; //加一下防止除零的情况
    return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y));
}
</code></pre>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>当我们化成的这个式子的$\frac{y_j-y_k}{x_j-x_k}\leq k_i$ 的$k_i$是单调的，那么我们可以用单调队列来维护这个凸壳，并且队首是最优解</p>
<p>因为我们维护一个单调的队列，所以当我们在队列里面加点时，根据凸壳的单调性我们可以这么写</p>
<pre><code class="lang-c">while(head &lt; tail &amp;&amp; Calc(i, q[tail]) &lt;= Calc(q[tail], q[tail-1])) tail --;
            q[++tail] = i;
</code></pre>
<p>而如果存在$k&lt;j&lt;i$并且$j$比$k$优，的情况，也就是$\frac{y_j-y_k}{x_j-x_k}\leq k_i$ </p>
<p>我们在队首把$k$踢出去,因为$k$已经不是最优的</p>
<pre><code class="lang-c">while(head &lt; tail &amp;&amp; Calc(q[head+1], q[head]) &lt;= sum[i])
                head ++;
</code></pre>
<p>这样我们就可以用单调队列去维护一个单调的凸壳，并且单调队列里面的队首就是最优情况</p>
<h3 id="二分单调栈"><a href="#二分单调栈" class="headerlink" title="二分单调栈"></a>二分单调栈</h3><p>当我们化成的这个式子的$\frac{y_j-y_k}{x_j-x_k}\leq k_i$ 的$k_i$不是单调的，那么我们可以用单调栈来维护这个凸壳</p>
<p>因为凸壳是单调的，所以我们要找的这个$k_i$可以用二分来查找</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="HDU-3507-Print-Article"><a href="#HDU-3507-Print-Article" class="headerlink" title="HDU 3507 Print Article"></a>HDU 3507 Print Article</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>有一个$C<em>i$序列，你可以把序列分为几段，每段的权值为$(\sum\limits</em>{i=1}^{k}C_i)^2+M$，</p>
<p>求出最小的权值和</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>很容易想到转移方程$dp[i] = \min\limits_{x=1}^{x&lt;i}{dp[x] + m + (sum[i] - sum[x])^2}$</p>
<p>我们假设存在一个$k&lt;j&lt;i$并且$j$比$k$要优</p>
<p>那么$dp[j]+m+(sum[i]-sum[j]^2)\leq dp[k]+m+(sum[i]-sum[k])^2$</p>
<p>移项并合并同类项后：</p>
<p>$\frac{dp[j]+sum[j] \times sum[j] - (dp[k]+sum[k]\times sum[k])}{2(sum[j]-sum[k])}\le sum[i]]$</p>
<p>我们设$Y=dp[x]-sum[x],X=2\times sum[x]$</p>
<p>那么式子可以化成:$\frac{Y(j)-Y(k)}{X(j)-X(k)}\le sum[i]$</p>
<p>因为是$sum[i]$是递增的，所以我们可以用单调队列维护一个下凸壳</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const ll maxn = 5e5 + 7;
const ll inf = 0x3f3f3f3f;
const ll mod = 1e9 + 7;
const double eps = 0.0000000001;
typedef pair&lt;ll, ll&gt; pis;

ll dp[maxn], q[maxn];
ll sum[maxn];

ll head, tail, n, m;

ll getDp(ll i, ll j) {
    return dp[j] + m + (sum[i] - sum[j]) * (sum[i] - sum[j]);
}

ll getUp(ll j) {
    return dp[j] + sum[j] * sum[j];
}

ll getDown(ll j) {
    return 2 * sum[j];
}

double Calc(ll x, ll y) {
    if(getDown(x) == getDown(y)) return -1e9;
    return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y));
}

int main() { 
    while(~scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m)) {
        for (ll i = 1; i &lt;= n; i ++)
            scanf(&quot;%lld&quot;, &amp;sum[i]);
        sum[0] = dp[0] = 0;
        for (ll i = 1; i &lt;= n; i ++)
            sum[i] += sum[i-1];
        head = tail = 1;
        for (ll i = 1; i &lt;= n; i ++) {
            while(head &lt; tail &amp;&amp; Calc(q[head+1], q[head]) &lt;= 1.0 * sum[i])
                head ++;
            dp[i] = getDp(i, q[head]);
            while(head &lt; tail &amp;&amp; Calc(i, q[tail]) &lt;= Calc(q[tail], q[tail-1])) tail --;
            q[++tail] = i;
        }
        printf(&quot;%lld\n&quot;, dp[n]);
    }
    return 0;
}
</code></pre>
<h3 id="洛谷-P4072-征途"><a href="#洛谷-P4072-征途" class="headerlink" title="洛谷 P4072 征途"></a>洛谷 P4072 征途</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>序列分割，给你n个数字，你把序列分割成m个段，每一段的的方差为$v$</p>
<p>输出最小的每一段的之和$\times m^2$</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>提前声明一下， 下面的$c_i$都是一段路的距离之和，而不是单条路的距离，所以是$m$段而不是$n$段</p>
<p>$s^2=\frac{(\frac{\sum\limits<em>{i=1}^{m}c_i}{n}-c_1)^2+(\frac{\sum\limits</em>{i=1}^{m}c<em>i}{m}-c_2)^2+…+(\frac{\sum\limits</em>{i=1}^{m}c_i}{m}-c_n)^2}{m}$</p>
<p>$s^2=\frac{(\frac{\sum\limits<em>{i=1}^{m}c_i}{m})^2-2\times \frac{\sum\limits</em>{i=1}^{m}c<em>i}{m}\times c_1+c_1^2+(\frac{\sum\limits</em>{i=1}^{m}c<em>i}{m})^2-2\times \frac{\sum\limits</em>{i=1}^{m}c<em>i}{m}\times c_2+c_2^2+…+(\frac{\sum\limits</em>{i=1}^{m}c<em>i}{m})^2-2\times \frac{\sum\limits</em>{i=1}^{m}c_i}{m}\times c_n+c_n^2}{m}$</p>
<p>$s^2=\frac{m\times (\frac{\sum\limits<em>{i=1}^{m}c_i}{m})^2-2\times \frac{(\sum\limits</em>{i=1}^{m}c<em>i)^2}{m}+(\sum\limits</em>{i=1}^{m}c_i^2)}{m}$</p>
<p>$s^2=\frac{\frac{(\sum\limits<em>{i=1}^{m}c_i)^2}{m}-2\times \frac{(\sum\limits</em>{i=1}^{m}c<em>i)^2}{m}+(\sum\limits</em>{i=1}^{m}c_i^2)}{m}$</p>
<p>$s^2=\frac{-\frac{(\sum\limits<em>{i=1}^{m}c_i)^2}{m}+(\sum\limits</em>{i=1}^{m}c_i^2)}{m}$</p>
<p>$s^2\times m^2=-(\sum\limits<em>{i=1}^{n}c_i)^2+m\times (\sum\limits</em>{i=1}^{n}c_i^2)$</p>
<p>我们发现前面一项是一个常数，而$s^2\times m^2$最小是在$\sum\limits_{i=1}^{m}c_i^2$最小时</p>
<p>这样我们在进行$dp$转移的时候,我们用$sum[x] = \sum\limits_{i=1}^{x}val[i]$    $val[x]$时每一条路的长度</p>
<p>$dp[i] = \min{dp[x] + (sum[i]-sum[x])^2}$</p>
<p>按照以往的套路，存在$k&lt;j&lt;i$并且$j$比$k$要优</p>
<p>$dp[j]+(sum[i]-sum[j])^2\le dp[k]+(sum[i]+sum[k])^2$</p>
<p>$dp[j]+sum[j]^2-(dp[k]+sum[k]^2)\le2\times sum[i]sum[j]-2\times sum[i]sum[k]$</p>
<p>$\frac{dp[j]+sum[j]^2-(dp[k]+sum[k]^2)}{2\times(sum[j]]-sum[k])}\le sum[i]$</p>
<p>这样斜率就推出来了，因为$sum[i]$是个递增的值，所以我们可以用单调队列来维护凸壳</p>
<p>然后用一个滚动数组来记录最优值</p>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;

ll sum[maxn], g[maxn], val[maxn];
ll q[maxn], dp[maxn];

ll getDp(ll i, int j) {
    return g[j] + (val[i] - val[j]) * (val[i] - val[j]);
}

ll getUp(int j) {
    return g[j] + val[j] * val[j];
}

ll getDown(int j) {
    return 2 * val[j];
}

double Calc(int x, int y) {
    if(getDown(x) == getDown(y)) return -1e9;
    return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y));
}

int main() {
    int n, m;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i ++) {
        scanf(&quot;%lld&quot;, &amp;val[i]);
        val[i] += val[i-1];
        g[i] = val[i] * val[i]; 
   }
    for (int t = 1; t &lt; m; t ++) {
        int head, tail;
        head = tail = 1;
        for (int i = 1; i &lt;= n; i ++) {
            while(head &lt; tail &amp;&amp; Calc(q[head+1], q[head]) &lt;= val[i])
                head ++;
            dp[i] = getDp(i, q[head]);
            while(head &lt; tail &amp;&amp; Calc(i, q[tail]) &lt;= Calc(q[tail], q[tail-1]))
                tail --;
            q[++tail] = i;
        }
        for (int i = 1; i &lt;= n; i ++)  g[i] = dp[i];   
    }
    printf(&quot;%lld\n&quot;, m * dp[n] - val[n] * val[n]);

    return 0;
}
</code></pre>
<p>这道题貌似可以用WQS加斜率dp来写，下次来补一下</p>
<h3 id="洛谷P2365-任务安排"><a href="#洛谷P2365-任务安排" class="headerlink" title="洛谷P2365 任务安排"></a>洛谷P2365 任务安排</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>N个任务排成一个序列，你把任务分组完成，每个任务的费用是完成时间乘一个费用系数</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>我们先设计dp转移方程,因为我们在转移的时候还要考虑前面用了几组,所以我们在转移的时候直接把后面的</p>
<p>费时S加上,</p>
<p>dp转移的时候时间和花费用前缀和维护</p>
<p>$dp[i] = min{dp[x] + time[i] \times (cost[i] - cost[x])+S\times (cost[n] - cost[x])}$</p>
<p>按照以往套路,</p>
<p>$dp[j]+time[i]\times(cost[i]-cost[j])+S\times(cost[n] - cost[j])\le dp[k]+time[i]\times(cost[i]-cost[k])+S\times(cost[n] - cost[k])$</p>
<p>$dp[j]-dp[k]-S\times cost[j]+S\times cost[k]\le time[i]\times (cost[j]-cost[k])$</p>
<p>$\frac{dp[j]-S\times cost[j]-(dp[k]-S\times cost[k])}{cost[j]-cost[k]}\le time[i]$</p>
<p>然后用斜率$dp$就直接写了</p>
<pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const ll maxn = 1e5 + 5;
const ll inf = 0x3f3f3f3f;
const ll mod = 1e9+7;

ll t[maxn], c[maxn];
ll dp[maxn], q[maxn];
ll n, S;

ll getDp(ll i, ll j) {
    return dp[j] + t[i] * (c[i] - c[j]) + S * (c[n] - c[j]);
}

ll getUp(ll i) {
    return dp[i]-S*c[i];
}

ll getDown(ll i) {
    return c[i];
}

double Clac(int x, int y) {
    return 1.0 * (getUp(x) - getUp(y))/(getDown(x) - getDown(y));
}

int main() {
    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;S);
    for (ll i = 1; i &lt;= n; i ++) {
        scanf(&quot;%lld %lld&quot;, &amp;t[i], &amp;c[i]);
        t[i] += t[i-1];
        c[i] += c[i-1];
    }
    ll head, tail;
    head = tail = 1;
    for (int i = 1; i &lt;= n; i ++) {
        while(head &lt; tail &amp;&amp; Clac(q[head+1], q[head]) &lt;= t[i])
            head ++;
        dp[i] = getDp(i, q[head]);
        while(head &lt; tail &amp;&amp; Clac(i, q[tail]) &lt;= Clac(q[tail], q[tail-1]))
            tail --;
        q[++tail] = i;
    }
    printf(&quot;%lld\n&quot;, dp[n]);
    return 0;
}
</code></pre>
<h3 id="洛谷-P4360-锯木厂选址"><a href="#洛谷-P4360-锯木厂选址" class="headerlink" title="洛谷 P4360 锯木厂选址"></a>洛谷 P4360 锯木厂选址</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>从山顶到山底运n棵老树，运一颗树的费用是树的重量乘上距离，为了不浪费决定在山腰上见两个锯木厂，问最小的运输费用</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>我们把树的重量求一个前缀和 $sum[]$，到山底的距离求一个后缀和$dis[]$,所有树运到山底的花费$totsum$</p>
<p>因为只有两个锯木厂，所以我们可以直接写一下$dp$转移</p>
<p>$dp[i] = min{totsum-dis[x]\times sum[x]-(sum[i]-sum[x])\times dis[i])}$</p>
<p>套路：</p>
<p>$totsum-dis[j]\times sum[j]-(sum[i]-sum[j])\times dis[i])\leq totsum-dis[k]\times sum[k]-(sum[i]-sum[k])\times dis[i])$</p>
<p>$-dis[j]\times sum[j]+dis[k]\times sum[k]\le dis[i]\times (-sum[j]+sum[k])$</p>
<p>$\frac{dis[j]\times sum[j]-dis[k]\times sum[k]}{sum[j]-sum[k]}\ge dis[i]$  $(因为sum[j]大于sum[k]所以要变号)$</p>
<p>直接套</p>
<pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int maxn = 1e5 + 5;
const ll inf = 0x7ffffffffffll;
const int mod = 1e9+7;

ll dis[maxn], sum[maxn];
ll dp[maxn], g[maxn];
ll q[maxn], totsum=0;

ll getDp(int i, int j) {
    return totsum - dis[j] * sum[j] - dis[i] * (sum[i] - sum[j]);
}

ll getUp(int i) {
    return dis[i] * sum[i];
}

ll getDown(int i) {
    return sum[i];
}

double Clac(int x, int y) {
    return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y));
}

int main() {
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i ++) {
        scanf(&quot;%lld %lld&quot;, &amp;sum[i], &amp;dis[i]);
        sum[i] += sum[i-1];
        totsum += sum[i] * dis[i];
    }
    for (int i = n; i &gt;= 1; i --) dis[i] += dis[i+1]; 
    int head, tail;
    ll ans = inf;
    head = tail = 1;
    for (int i = 1; i &lt;= n; i ++) {
        while(head &lt; tail &amp;&amp; Clac(q[head+1], q[head]) &gt; dis[i])
            head ++;
        dp[i] = getDp(i, q[head]);
        while(head &lt; tail &amp;&amp; Clac(i, q[tail]) &gt;= Clac(q[tail], q[tail-1])) 
            tail --;
        q[++tail] = i;
    }
    for (int i = 1; i &lt;= n; i ++) ans = min(ans, dp[i]);
    printf(&quot;%lld\n&quot;, ans);
    return 0; 
}
</code></pre>
<h3 id="洛谷-P5504-柠檬"><a href="#洛谷-P5504-柠檬" class="headerlink" title="洛谷 P5504 柠檬"></a>洛谷 P5504 柠檬</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>一串贝壳，每个贝壳都有一个值$s_0$你可以选择连续的一段把他变成柠檬，柠檬的个数是$s_0t^2$,$t$是区间柠檬值为$s_0$的个数</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>首先，我们要变的贝壳区间肯定是首尾值相同，然后我们可以对每个相同值得柠檬求一个前缀和</p>
<p>$dp[i] = max{dp[x-1] + val<a href="sum[i]-sum[x]+1">i</a>^2}$</p>
<p>套：</p>
<p>$dp[j-1]+val<a href="sum[i]-sum[j]+1">i</a>^2\le dp[k-1]+val<a href="sum[i]-sum[k]+1">i</a>^2$</p>
<p>$\frac{dp[j-1]-dp[k-1] + val[j]sum[j]^2-val[k]sum[k]^2-2val[i]sum[j]+2val[i]sum[k]}{sum[j]-sum[k]}\le 2val[i]sum[i]$</p>
<p>我们发现$2val[i]sum[i]$对于每一类柠檬都是单调的，所以可以直接移指针如果斜率不单调就要在凸壳上二分了</p>
<h4 id="AC代码（移指针）"><a href="#AC代码（移指针）" class="headerlink" title="AC代码（移指针）"></a>AC代码（移指针）</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const ll maxn = 1e5 + 5;
const ll inf = 0x3f3f3f3f;
const ll mod = 1e9+7;

ll last[maxn];
ll c[maxn], s[maxn];
vector&lt;ll&gt; q[maxn];
ll top[maxn];
ll dp[maxn];

ll getUp(ll i) {
    return dp[i-1] - 2 * s[i] * c[i] + c[i] * s[i] * s[i];
}

ll getDown(ll i) {
    return s[i];
}

double Calc(ll x, ll y) {
    return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y));
}

int main() {
    ll n;
    scanf(&quot;%lld&quot;, &amp;n);

    for (ll i = 1; i &lt;= n; i ++) {
        scanf(&quot;%lld&quot;, &amp;c[i]);
        s[i] = s[last[c[i]]] + 1;
        last[c[i]] = i;
    }

    for (ll i = 1; i &lt;= n; i ++) {
        if(last[c[i]]) q[c[i]].push_back(i);
        last[c[i]] = 0;
    }

    for (ll i = 1; i &lt;= n; i ++) {
        ll p = c[i];
        while(top[p] &gt; 1 &amp;&amp; Calc(q[p][top[p]-1], q[p][top[p]]) &lt;= Calc(q[p][top[p]], i)) {
            --top[p];
            q[p].pop_back();
        }
        ++top[p]; q[p].push_back(i);
        while(top[p] &gt; 1 &amp;&amp; Calc(q[p][top[p]-1], q[p][top[p]]) &lt;= 2*p*s[i]) {
            --top[p];
            q[p].pop_back();
        }
        dp[i] = dp[q[p][top[p]]-1] + (s[i] - s[q[p][top[p]]]+1) * (s[i]-s[q[p][top[p]]]+1) * p;

    }
    printf(&quot;%lld\n&quot;, dp[n]);
    return 0;
}
</code></pre>
<h4 id="AC代码（二分）"><a href="#AC代码（二分）" class="headerlink" title="AC代码（二分）"></a>AC代码（二分）</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const ll maxn = 1e5 + 5;
const ll inf = 0x3f3f3f3f;
const ll mod = 1e9+7;

ll last[maxn];
ll c[maxn], s[maxn];
vector&lt;ll&gt; q[maxn];
ll top[maxn];
ll dp[maxn];

ll getUp(ll i) {
    return dp[i-1] - 2 * s[i] * c[i] + c[i] * s[i] * s[i];
}

ll getDown(ll i) {
    return s[i];
}

double Calc(ll x, ll y) {
    if(getDown(x) == getDown(y)) return -1e9;
    return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y));
}

ll find(ll x) {
    ll p = c[x];
    ll l = 2, r = top[p];
    ll ans = 1;
    while(l &lt;= r) {
        ll m = (l + r) &gt;&gt; 1;
        if(Calc(q[p][m], q[p][m-1]) &gt; 2*p*s[x]) {
            ans = m;
            l = m + 1;
        }else r = m - 1;
    }
    return ans;
}

int main() {
    ll n;
    scanf(&quot;%lld&quot;, &amp;n);
    for (ll i = 1; i &lt;= n; i ++) {
        scanf(&quot;%lld&quot;, &amp;c[i]);
        s[i] = s[last[c[i]]] + 1;
        last[c[i]] = i;
    }
    for (ll i = 1; i &lt;= n; i ++) {
        if(last[c[i]]) q[c[i]].push_back(i);
        last[c[i]] = 0;
    }
    for (ll i = 1; i &lt;= n; i ++) {
        ll p = c[i];
        while(top[p] &gt; 1 &amp;&amp; Calc(q[p][top[p]-1], q[p][top[p]]) &lt;= Calc(q[p][top[p]], i)) {
            --top[p];
            q[p].pop_back();
        }
        ++top[p]; q[p].push_back(i);
        int ans = find(i);
        dp[i] = dp[q[p][ans]-1] + (s[i] - s[q[p][ans]] + 1) * (s[i]-s[q[p][ans]] + 1) * p;
    }
    printf(&quot;%lld\n&quot;, dp[n]);
    return 0;
}
</code></pre>
<h3 id="2019牛客多校第十场-J-Wood-Processing"><a href="#2019牛客多校第十场-J-Wood-Processing" class="headerlink" title="2019牛客多校第十场 J.Wood Processing"></a>2019牛客多校第十场 J.Wood Processing</h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>把n块木板求成高度相同的k块，求浪费的最小</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>可以说是斜率dp的模板题</p>
<p>我们把高度从高到低排序，那么$dp$转移式就是</p>
<p>$dp[i]=max{dp[x]+(sum[i]-sum[x])\times h[i]}$ $sum$是宽的前缀和</p>
<p>我们假设$j&gt;k$并且$j$比$k$优</p>
<p>$dp[j]+(sum[i]-sum[j])\times h[i] &gt;= dp[k]+(sum[i]-sum[k])\times h[i]$</p>
<p>$\frac{dp[j]-dp[k]}{sum[j]-sum[k]}\ge h[i]$</p>
<h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int maxn = 5005;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;
typedef pair&lt;int, int&gt; pis;

struct Node{
    ll p, h, w;
}node[maxn][2];
struct Plan{
    ll h, w;
}plan[maxn];
int n, k;
ll ans = 0;
ll dp[maxn], q[maxn], g[maxn];

bool cmp(Plan a, Plan b) {
    return a.h &gt; b.h;
}

ll getUp(int j) {
    return g[j]; 
}

ll getDown(int i) {
    return plan[i].w;
}

double Cal(int x, int y) {
    return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y));
}

ll getDp(int x, int i) {
    return g[x] + (plan[i].w - plan[x].w) * plan[i].h; 
}

void solve() {
    int head, tail;
    head = tail = 1;
    for (int i = 1; i &lt;= n; i ++) {
        while(head &lt; tail &amp;&amp; Cal(q[head+1], q[head]) &gt;= plan[i].h) head ++;
        dp[i] = getDp(q[head], i);
        while(head &lt; tail &amp;&amp; Cal(i, q[tail]) &gt;= Cal(q[tail], q[tail-1])) tail --;
        q[++tail] = i;
    }
    for (int i = 1; i &lt;= n; i ++) g[i] = dp[i];
}

int main() {
    scanf(&quot;%d %d&quot;, &amp;n, &amp;k);
    ll sum = 0;
    for (int i = 1; i &lt;= n; i ++) {
        scanf(&quot;%lld %lld&quot;, &amp;plan[i].w, &amp;plan[i].h);
        sum += plan[i].w * plan[i].h;
    }
    sort(plan + 1, plan + 1 + n, cmp);
    for (int i = 1; i &lt;= n; i ++) plan[i].w += plan[i-1].w;
    for (int i = 1; i &lt;= k; i ++) solve();
    printf(&quot;%lld\n&quot;, sum-dp[n]);
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列与逆序对</title>
    <url>//ea46ca8a/</url>
    <content><![CDATA[<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m＝n时所有的排列情况叫n的全排列。</p>
<h2 id="逆序列"><a href="#逆序列" class="headerlink" title="逆序列"></a>逆序列</h2><h3 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h3><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。</p>
<h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><p>一个排列中逆序的总数就称为这个排列的逆序数。</p>
<h3 id="奇偶排列"><a href="#奇偶排列" class="headerlink" title="奇偶排列"></a>奇偶排列</h3><p>逆序数为偶数的排列称为偶排列；逆序数为奇数的排列称为奇排列</p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="给排列，求逆序数"><a href="#给排列，求逆序数" class="headerlink" title="给排列，求逆序数"></a>给排列，求逆序数</h3><p>这个问题比较简单，直接对每个数字求一下逆序数，相加就可以了。</p>
<p>可以用线段树，树状数组等优化</p>
<h3 id="根据逆序数推排列数"><a href="#根据逆序数推排列数" class="headerlink" title="根据逆序数推排列数"></a>根据逆序数推排列数</h3><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>给定一个n元排列，它的逆序数存在且唯一,那么我们求一下已知一个n元排列的逆序数为m，这样的n元排列有多少？</p>
<p>我们用$f(n,m)$表示逆序数为m的n元排列的个数</p>
<h4 id="前提知识1"><a href="#前提知识1" class="headerlink" title="前提知识1"></a>前提知识1</h4><h5 id="对任意n-gt-2且0-lt-m-lt-C-n-2-时-f-n-m-gt-1；当m-gt-C-n-2-时-f-n-m-0"><a href="#对任意n-gt-2且0-lt-m-lt-C-n-2-时-f-n-m-gt-1；当m-gt-C-n-2-时-f-n-m-0" class="headerlink" title="对任意n&gt;=2且0&lt;=m&lt;=$C_n^2$时$f(n,m)$&gt;=1；当m&gt;$C_n^2$时,$f(n,m)$=0"></a>对任意n&gt;=2且0&lt;=m&lt;=$C_n^2$时$f(n,m)$&gt;=1；当m&gt;$C_n^2$时,$f(n,m)$=0</h5><p>$f(2,0)=1,f(2,1)=1,f(2,2)=0$</p>
<p>易证</p>
<h4 id="前提知识2"><a href="#前提知识2" class="headerlink" title="前提知识2"></a>前提知识2</h4><h5 id="f-n-m-f-n-C-n-2-m"><a href="#f-n-m-f-n-C-n-2-m" class="headerlink" title="$f(n,m)=f(n,C_n^2-m)$"></a>$f(n,m)=f(n,C_n^2-m)$</h5><p>对于一个逆序数为m的n元排列，$a<em>1,a_2,a_3,…a_n$，那么$a_n,a</em>{n-1},a_{n-2}…a_1$的逆序数为$C_n^2-m$</p>
<p>反过来同理</p>
<h4 id="前提知识3"><a href="#前提知识3" class="headerlink" title="前提知识3"></a>前提知识3</h4><h5 id="f-n-1-m-f-n-m-f-n-m-1-…-f-n-m-n"><a href="#f-n-1-m-f-n-m-f-n-m-1-…-f-n-m-n" class="headerlink" title="$f(n+1,m)=f(n,m)+f(n,m-1)+…+f(n,m-n)$"></a>$f(n+1,m)=f(n,m)+f(n,m-1)+…+f(n,m-n)$</h5><p>考虑由$a<em>1,a_2,…a_n$组成的排列，那么我们在其中加上$a</em>{n+1}（a<em>{n+1}&gt;{a_1,a_2,…a_n}）$的话，$a</em>{n+1}$ 可以放在排列中的任意一个位置</p>
<p>放在末尾对逆序列没有影响，那么$f(n+1,m)+=f(n,m)$，放在首位的话逆序对增加$n$那么$f(n+1,m)+=f(n,m-n)$,以此类推，放在排列中的其他位置就是$f(n+1,m)=f(n,m-i)$</p>
<p>那么$f(n+1,m)=f(n,m)+f(n,m-1)+f(n,m-2)+…+f(n,m-n)$</p>
<h4 id="前提知识4"><a href="#前提知识4" class="headerlink" title="前提知识4"></a>前提知识4</h4><h5 id="f-n-0-f-n-C-n-2-1"><a href="#f-n-0-f-n-C-n-2-1" class="headerlink" title="$f(n,0)=f(n,C_n^2)=1$"></a>$f(n,0)=f(n,C_n^2)=1$</h5><h4 id="前提知识5"><a href="#前提知识5" class="headerlink" title="前提知识5"></a>前提知识5</h4><h5 id="f-n-1-f-n-C-n-2-1-n-1"><a href="#f-n-1-f-n-C-n-2-1-n-1" class="headerlink" title="$f(n,1)=f(n,C_n^2-1)=n-1$"></a>$f(n,1)=f(n,C_n^2-1)=n-1$</h5><p>$f(n,1)=f(n-1,1)+f(n-1,0)=f(n-1,1)+1$</p>
<h4 id="前提知识6"><a href="#前提知识6" class="headerlink" title="前提知识6"></a>前提知识6</h4><h5 id="f-n-2-f-n-C-n-2-2-C-n-2-1-n-gt-2"><a href="#f-n-2-f-n-C-n-2-2-C-n-2-1-n-gt-2" class="headerlink" title="$f(n,2)=f(n,C_n^2-2)=C_n^2-1(n&gt;2)$"></a>$f(n,2)=f(n,C_n^2-2)=C_n^2-1(n&gt;2)$</h5><p>由3，4，5可知</p>
<p>$f(n,2)=f(n-1,2)+f(n-1,1)+f(n-1,0)=f(n-1,2)+n-1$</p>
<p>根据$f(2,2)=0$可证</p>
<p>同理：</p>
<p>$f(n,3)=C_n^3-C_n^2-C_n^1(n&gt;3)$</p>
<p>$f(n,4)=C_n^4+2C_n^3-C_n^1(n&gt;4)$</p>
<p>$f(n,5)=C_n^4+3C_n^4+2C_n^3-C_n^2+1(n&gt;5)$</p>
<p>$….$</p>
<h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>给定逆序数，求满足此逆序数的最小排序</p>
<h4 id="前提知识1-1"><a href="#前提知识1-1" class="headerlink" title="前提知识1"></a>前提知识1</h4><p>对于n的全排列，在它完全倒序的时候逆序数最多</p>
<h4 id="前提知识2-1"><a href="#前提知识2-1" class="headerlink" title="前提知识2"></a>前提知识2</h4><p>对于一个形如$1,2,3,…,i-1,i,n,…,i+1$的排列$q$，在数$n$前保证首项为1，且严格以公差为1递增而数n以后排列任意的数列</p>
<p>当数$n$之后是递减的时候$q$的逆序数最多，$t=C_{n-i}^{2}$</p>
<p>排列$q$是出现逆序对为$t$的最小排列</p>
<h4 id="前提知识3-1"><a href="#前提知识3-1" class="headerlink" title="前提知识3"></a>前提知识3</h4><p>我们把数$n$之后的第$k$小数与数$n$的前一个数(即$i$)交换，然后是数$n$后面保持逆序，这样得到的新排列的逆序对数为</p>
<p>$t=C_{n-i}^2+k$,且这个排列是逆序数$t$的最小排列</p>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第九场</title>
    <url>//8ea435a5/</url>
    <content><![CDATA[<h2 id="A-The-Power-of-Fibonacci"><a href="#A-The-Power-of-Fibonacci" class="headerlink" title="A:  The Power of Fibonacci"></a>A:  The Power of Fibonacci</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你n,m,求$\sum\limits_{i=1}^{n}F_i^m \mod 1e9，F$是斐波那契数列 </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先斐波那契数列在模意义下是有循环节的，而在$1e9$下的循环节有太大，</p>
<p>所以我们把$1e9$分为两个互质数字的乘积$512*1953125$,而在这两个模下的循环节是可以接受的</p>
<p>然后我们分别算出一个结果用中国剩余定理求出答案就行了</p>
<p>注意快速幂模的时候有模$1e9$不然会T，可能是别的模数取模次数太多造成的超时</p>
<p><code>做完我傻了</code></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long    
const int Mod = 1000000000;
int Ksm(int a, int b, int p) {
    int res = 1;
    while(b) {
        if(b &amp; 1) res = 1ll * res * a % p;
        a = 1ll * a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}
const int maxn = 1e7+5;
int mod[2] = {512, 1953125};
int f[maxn], ans[2] = {0, 0};

int ex_gcd(int a, int b, int &amp;x, int &amp;y) {
    if(!b) {
        x = 1; y = 0;
        return a;
    }
    int d = ex_gcd(b, a%b, x, y);
    int t = x;
    x = y;
    y = t - a/b*y;
    return d;
}

int inv(int a, int p) {
    int x, y;
    ex_gcd(a, p, x, y);
    return (x % p + p) % p;
}

int main() { 
    int n, m;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int k = 0; k &lt;= 1; k ++) {
        int j = 2;
        f[0] = 0; f[1] = 1;
        for (; ; j ++) {
            f[j] = (f[j-1] + f[j-2]) % mod[k];
            if(f[j] == 0 &amp;&amp; f[j-1] == 1) break;
        }
        for (int i = 0; i &lt; j; i ++) {
            int nr = n/j;
            if(n % j &gt;= i) nr ++;
            ans[k] = (ans[k] + 1ll * Ksm(f[i], m, Mod) * nr) % mod[k];
        }
    }
    int Inv = inv(mod[0], mod[1]);
    ll res = 1ll * (ans[1] - ans[0] + Mod) % Mod * mod[0] * Inv + ans[0];
    printf(&quot;%d\n&quot;, res%Mod);
    return 0;
}
</code></pre>
<h2 id="B-Quadratic-equation"><a href="#B-Quadratic-equation" class="headerlink" title="B: Quadratic equation"></a>B: Quadratic equation</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>$x+y\equiv b\mod p, x\cdot y\equiv c \mod p$</p>
<p>求$x,y$</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>二次剩余基础题，可惜我不会</p>
<p>根据初中知识我们可以化成这样$(x-\frac{b}{2})^2\equiv \frac{b^2-4c}{4} \mod p$</p>
<p>下面就是验证$\frac{b^2-4c}{4}$是否是模$p$下的二次剩余,模板题</p>
<pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e5 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;
typedef pair&lt;int, int&gt; pis;

struct T{
    ll p, d;
};

ll Ksm(ll a, ll b, ll p) {
    ll res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}

ll w;
//二次域乘法
T Mul_er(T a, T b, ll p) {
    T ans;
    ans.p = (a.p * b.p + a.d * b.d % p * w % p) % p;
    ans.d = (a.p * b.d % p + a.d * b.p % p) % p;
    return ans;
}
//二次域快速幂
T Ksm_er(T a, ll b, ll p) {
    T ans;
    ans.p = 1; ans.d = 0;
    while(b) {
        if(b &amp; 1) ans = Mul_er(ans, a, p);
        a = Mul_er(a, a, p);
        b &gt;&gt;= 1;
    }
    return ans;
} 
//求勒让德符号
ll Legendre(ll a, ll p) {
    return Ksm(a, (p-1)&gt;&gt;1, p);
}

ll Recever(ll a, ll p) {
    a %= p;
    if(a &lt; 0) a += p;
    return a;
}

ll solve(ll n, ll p) {
    if(n % p == 0) return 0;
    if(p == 2) return 1;
    if(Legendre(n, p) + 1 == p) return -1;
    ll a = -1, t;
    while(1) {
        a = rand() % p;
        t = a * a - n;
        w = Recever(t, p);
        if(Legendre(w, p) + 1 == p) break;
    }
    T tmp;
    tmp.p = a; tmp.d = 1;
    T ans = Ksm_er(tmp, (p+1)&gt;&gt;1, p);
    return ans.p;
}

int main() { 
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --) {
        ll b, c;
        scanf(&quot;%lld %lld&quot;, &amp;b, &amp;c);
        ll t = ((b * b - 4 * c) % mod + mod) % mod;
        ll x = solve(t, mod);
        if(x == -1) {
            puts(&quot;-1 -1&quot;);
            continue;
        }
        x = (x + b) % mod * Ksm(2, mod-2, mod) % mod;
        ll y = (b - x + mod) % mod;
        if(x &gt; y) swap(x, y);
        printf(&quot;%lld %lld\n&quot;, x, y);
    }
    return 0;
}
</code></pre>
<h2 id="C-Inversions-of-all-permutations"><a href="#C-Inversions-of-all-permutations" class="headerlink" title="C: Inversions of all permutations"></a>C: Inversions of all permutations</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>$\sum\limits_{r_i is a permutation of {a_i}}b^{t(r_i)}\mod 1e9+7$</p>
<p>求$b$的序列$a$的全排列的逆序对次幂之和</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对于一个没有重复数字的序列，其逆序数为</p>
<pre><code>1: 1
2: 1 1
3: 1 2 2 1
4: 1 3 5 6 5 3 1
</code></pre><p><code>3:1 2 2 1</code></p>
<p>代表长度为$3$的序列的逆序数为$0$的有$1$个，逆序数为$1$的有$2$个，逆序数为$3$的有$2$个，逆序数为$3$的有$3$个</p>
<p>我们用$dp$来代表答案，那么长度为$3$的答案就是$dp[3]=b^0+2b^1+2b^2+b^3$</p>
<p>而$dp$转移是有规律的$dp[i] = dp[i-1]\times \sum\limits_{j=0}^{i-1}b^j$</p>
<p>而对于有重复数字的序列，其结果就是$\frac{dp[n]}{\prod dp[重复次数]}$</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e5 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;
typedef pair&lt;int, int&gt; pis;

ll dp[maxn], cnt[maxn], pre[maxn];

ll Ksm(ll a, ll b) {
    ll res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}

int main() { 
    int n, b;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;b);
    dp[0] = 1;
    for (int i = 1; i &lt; maxn; i ++) dp[i] = 1ll * dp[i-1] * b % mod;
    for (int i = 1; i &lt; maxn; i ++) dp[i] = dp[i] + dp[i-1] % mod;
    pre[1] = 1;
    for (int i = 2; i &lt; maxn; i ++) pre[i] = 1ll * pre[i-1] * dp[i-1] % mod;
    ll sum = pre[n];
    for (int i = 1; i &lt;= n; i ++) {
        int x;
        scanf(&quot;%d&quot;, &amp;x);
        cnt[x] ++;
    }
    for (int i = 0; i &lt; maxn; i ++) {
        if(cnt[i] &gt; 1) 
            sum = 1ll * sum * Ksm(pre[cnt[i]], mod-2) % mod;
    }
    printf(&quot;%lld\n&quot;, sum);
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>二次剩余</title>
    <url>//98066e3c/</url>
    <content><![CDATA[<h2 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于$P, n$ 如果存在$x$使得 $x^2 \equiv n \mod P$ 则称$n$是模$P$意义下的二次剩余</p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>对于$x^2\equiv n(mod p)$ 总共有$\frac{p-1}{2}$ 个n能使得方程有解</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>考虑所有的$x^2$ ,如果存在两个不同的数字$1&lt; u,v &lt; p$,$u^2\equiv v^2(\mod p)$ ,那么显然$(u^2-v^2)\mod p==0$</p>
<p>即$(u+v)(u-v)\mod p == 0$ ，那么就只能是$u+v\equiv 0(\mod p)$，两个数字相互对应，所有共有$\frac{p-1}{2}$个不同的平方</p>
<h2 id="勒让德符号"><a href="#勒让德符号" class="headerlink" title="勒让德符号"></a>勒让德符号</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p> $(\frac{a}{p})= \begin{cases} 1, &amp; a在模p意义下是二次剩余\ -1，&amp; a在模p意义下是非二次剩余 \ 0, &amp; a\equiv 0 (mod p) \end{cases}$ </p>
<h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><p>$(\frac{a}{p})\equiv a^{\frac{p-1}{2}}(\mod p)$</p>
<h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>1.若$a$是模p下的二次剩余，那么存在$x^2\equiv a (\mod p)$ ,那么$x^{p-1}\equiv a^{\frac{p-1}{2}}\equiv (\frac{a}{p})\equiv 1(\mod p)$ 根据费马小定理</p>
<p>在$a$是模$p$意义下的二次剩余时$x^{p-1} \equiv 1(\mod p)$显然成立</p>
<p>2.若$a$是模$p$意义下的非二次剩余,那么跟上面同理，显然不存在$x^{p-1}\equiv -1(\mod p)$</p>
<p>3.当$a\equiv 0(\mod p)$显然满足</p>
<h2 id="开根复数域"><a href="#开根复数域" class="headerlink" title="开根复数域"></a>开根复数域</h2><p>我们先定义一个数域$\mathsf{F_p}$定义为$0$到$p-1$这$p$个数在模$p$意义下加减乘除构成的集合</p>
<p>数域$\mathsf{F_{p^2}}$定义为一个开根的复数域，即如果一个$a^2-n$不能开根$(勒让德符号(\frac{a}{p})=-1)$ ，那么我们加上一个复数域</p>
<p>就可以开根,(类似$\sqrt{-1}$我们加上一个复数域就可以开根)，我们另这个不能开根的数字$\sqrt{a^2-n}$为复数域的”虚数单位元”$(类似\sqrt{-1})$ 并设它为$w$ ,那么则任意一个复数域的数字都可以表示为$a+bw$($a$是实部，$b$是虚部，$w$是虚数单位元)  </p>
<p>$\mathsf{F_{p^2}}$数域满足不同复数域的所有四则运算</p>
<p> <img src="二次剩余/img1.jpg" alt="img1"></p>
<h3 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a>定理</h3><p>$w^p\equiv -w(\mod p)$</p>
<h4 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h4><p>$w^p\equiv w\cdot w^{p-1} \equiv w\cdot (w^2)^{\frac{p-1}{2}}\equiv w\cdot (a^2-n)^{\frac{p-1}{2}} \equiv -w (\mod p)$</p>
<h3 id="定理-3"><a href="#定理-3" class="headerlink" title="定理"></a>定理</h3><p>$(a+b)^n\equiv a^n+b^n(\mod n)(n \in P)$</p>
<h4 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h4><p>有二项式定理可知: $(a+b)^n\equiv \sum\limits_{i=0}^{n}C_n^ia^ib^{n-i}(\mod n)$</p>
<p>因为n是一个质数，所以除了$i=0,i=n$时，其他的$C_n^i$是无法别消除这能模$p$模成$0$</p>
<h2 id="二次剩余证明"><a href="#二次剩余证明" class="headerlink" title="二次剩余证明"></a>二次剩余证明</h2><p>我们首先随机出来一个$a$,使得$(\frac{a^2-n}{p})$为-1，也就是不能开根，然后我们把他定义为复数域的单位根</p>
<p>$w=\sqrt{a^2-n}$</p>
<p>那么我们求$x^2\equiv n(\mod p)$</p>
<p>$x^2\equiv n\equiv a^2-(a^2-n)\equiv a^2-w^2$</p>
<p>$\equiv (a-w)(a+w)\equiv (a^p+w^p)(a+w)(a满足费马小定理 a^{p-1}\equiv 1(\mod p))$</p>
<p>$\equiv (a+w)^p(a+w)\equiv (a+w)^{p+1}$</p>
<p>$所以x\equiv (a+w)^{\frac{p+1}{2}}$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-c">struct T{
    long long p, d;
};

long long Ksm(long long a, long long b, long long p) {
    long long res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}

long long w;
//二次域乘法
T Mul_er(T a, T b, long long p) {
    T ans;
    ans.p = (a.p * b.p + a.d * b.d % p * w % p) % p;
    ans.d = (a.p * b.d % p + a.d * b.p % p) % p;
    return ans;
}
//二次域快速幂
T Ksm_er(T a, long long b, long long p) {
    T ans;
    ans.p = 1; ans.d = 0;
    while(b) {
        if(b &amp; 1) ans = Mul_er(ans, a, p);
        a = Mul_er(a, a, p);
        b &gt;&gt;= 1;
    }
    return ans;
} 
//求勒让德符号
long long Legendre(long long a, long long p) {
    return Ksm(a, (p-1)&gt;&gt;1, p);
}

long long Recever(long long a, long long p) {
    a %= p;
    if(a &lt; 0) a += p;
    return a;
}

long long solve(long long n, long long p) {
    if(n % p == 0) return 0;
    if(p == 2) return 1;
    if(Legendre(n, p) + 1 == p) return -1;
    long long a = -1, t;
    while(1) {
        a = rand() % p;
        t = a * a - n;
        w = Recever(t, p);
        if(Legendre(w, p) + 1 == p) break;
    }
    T tmp;
    tmp.p = a; tmp.d = 1;
    T ans = Ksm_er(tmp, (p+1)&gt;&gt;1, p);
    return ans.p;
}
ll x = solve(n, p);
x==-1无解，否则
x和p-x都是合法解
</code></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第八场</title>
    <url>//f46914fa/</url>
    <content><![CDATA[<h2 id="J-Just-Jump"><a href="#J-Just-Jump" class="headerlink" title="J:Just Jump"></a>J:Just Jump</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个长度为L的路径，你起始点在0号点，每次最少移动d步，而且在$t_i$时刻$p_i$点会遭遇攻击</p>
<p>问你到达L点有多少种方法</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先不考虑攻击，到达L点的方法就是一个简单dp  $dp[n]=dp[0]+dp[1]+dp[2]+..+dp[n-d]$</p>
<p>可以用前缀和维护一下，这样dp的复杂度就是O(L)</p>
<p>那么考虑攻击的时候呢，一个明显的思路就是我们已经用dp算出了总的方法数，</p>
<p>那么我们把受到攻击是的路线减去就是不受攻击到达L的方法数</p>
<p>那么当我们在$(t_i,p_i)$受到攻击的方法数是多少呢，我们先把攻击按照位置从小到大排序，时间从小到大排序</p>
<p>首先我们肯定是从$[0,p_i-d]$这些点数转移来的，并且前面的$t_i-1$步每次最少走d步</p>
<p>那么我们在减去$(t<em>i-1)(d-1)$就变成从最少有1步，那么就是从$[1,p_i-d-(t_i-1)(d-1)]$找$t_i-1$个点，也就是组合数$C</em>{p_i-t_id+t_i-1}^{t_i-1}$ </p>
<p>但是现在又有了一个问题，就是用$C_{p_i-t_id+t_i-1}^{t_i-1}$ 来计算</p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gblvpbk8kyj30lg06pq37.jpg" alt="img1"></p>
<p>我们计算了0—&gt;D的所有路径，但是其中包括了从C到D的路径，而这部分路径因为C的被攻击所以是无效的（C被攻击的时间小于D，C在D之前被攻击），所以我们要减去（C—&gt;D）这部分路径</p>
<p>这样我们就把从0开始$t<em>i$时刻到达攻击点$p_i$ 的路径数$f[i]$全部算了出来，那么结果就是$dp[L]-=\sum\limits</em>{i=1}^{m}f[i]*dp[L-node[i].p]$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int maxn = 1e7;
const int mod = 998244353;
ll Fac[maxn+5], inv[maxn+5], f[3005];
ll pref[maxn+5], sum[maxn+5];
ll L, d, m;

struct Node{
    ll t, p;
    bool friend operator &lt; (Node a, Node b) {
        if(a.p == b.p) return a.t &lt; b.t;
        return a.p &lt; b.p;
    }
}node[3005];

ll Ksm(ll a, ll b) {
    ll res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}

void init() {
    Fac[0] = 1;
    for (int i = 1; i &lt;= maxn; i ++)
        Fac[i] = (Fac[i-1]*i) % mod;
    inv[maxn] = Ksm(Fac[maxn], mod-2);
    for (int i = maxn-1; i &gt;= 0; i --)
        inv[i] = inv[i+1] * (i+1) % mod;
}

ll Calc(ll t, ll p) {
    if(p-t*d+t-1 &lt; t-1) return 0;
    return Fac[p-t*d+t-1]*inv[t-1]%mod*inv[p-t*d]%mod;
}

int main() {
    init();
    scanf(&quot;%lld %lld %lld&quot;, &amp;L, &amp;d, &amp;m); 
    for (int i = 1; i &lt;= m; i ++) 
        scanf(&quot;%lld %lld&quot;, &amp;node[i].t, &amp;node[i].p);
    sort(node+1, node+1+m);
    for (int i = 1; i &lt;= m; i ++) {
        f[i] = Calc(node[i].t, node[i].p);
        for (int j = 1; j &lt; i; j ++) 
            if(node[i].t &gt; node[j].t) 
                f[i] = (f[i] - f[j]*Calc(node[i].t-node[j].t, node[i].p-node[j].p)%mod + mod) % mod;
    }
    sum[0] = 1; pref[0] = 1;
    for (int i = 1; i &lt;= L; i ++) {
        if(i &lt; d) sum[i] = 0;
        else sum[i] = pref[i-d];
        pref[i] = (pref[i-1]+sum[i]) % mod;
    }
    ll ans = sum[L];
    for (int i = 1; i &lt;= m; i ++) 
        ans = (ans - f[i] * sum[L-node[i].p] % mod + mod) % mod;
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第七场</title>
    <url>//68238393/</url>
    <content><![CDATA[<h2 id="H-Pair"><a href="#H-Pair" class="headerlink" title="H:Pair"></a>H:Pair</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你3个数字$A,B,C$,让你计算$1\leq x\leq A,1\leq y\leq B$,并且$(x$ $and$ $y)&gt;C$或者$(x$ $xor$ $y)&lt;C$ 这样的</p>
<p>$<x,y>$有多少对</x,y></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很像数位dp，枚举二进制的每一位，4种状态分别是（A临界，B临界，A$and$B临界，A$xor$B临界）</p>
<p>这样直接数位dp可以算出有多少对不满足条件，然后用总数减去</p>
<p>因为$x,y&gt;1$,所有要在数位dp算出的结果中减去x为0时和y为0时的数量</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
ll dp[35][2][2][2][2];
int num_a[35], num_b[35], num_c[35];

void GetNum(ll a, ll b, ll c) {
    memset(num_a, 0, sizeof(num_a));
    memset(num_b, 0, sizeof(num_b));
    memset(num_c, 0, sizeof(num_c));
    num_a[0] = 0;
    while(a) {
        num_a[++num_a[0]] = a % 2;
        a /= 2;
    }
    num_b[0] = 0;
    while(b) {
        num_b[++num_b[0]] = b % 2;
        b /= 2;
    }
    num_c[0] = 0;
    while(c) {
        num_c[++num_c[0]] = c % 2;
        c /= 2;
    }
}

ll dfs(int pos, int a, int b, int an, int xo) {
    if(!pos) return 1;
    if(dp[pos][a][b][an][xo] != -1) return dp[pos][a][b][an][xo];
    int ua = a ? num_a[pos] : 1;
    int ub = b ? num_b[pos] : 1;
    int uan = an ? num_c[pos] : 1;
    int uxo = xo ? num_c[pos] : 0;
    ll ret = 0;
    for (int i = 0; i &lt;= ua; i ++) 
        for (int j = 0; j &lt;= ub; j ++) 
            if((i&amp;j) &lt;= uan &amp;&amp; (i^j) &gt;= uxo) 
                ret += dfs(pos-1, a&amp;&amp;(i==ua), b&amp;&amp;(j==ub), an&amp;&amp;((i&amp;j)==uan), xo&amp;&amp;((i^j)==uxo));
    return dp[pos][a][b][an][xo] = ret;
}

int main() {
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --) {
        ll a, b, c;
        scanf(&quot;%lld %lld %lld&quot;, &amp;a, &amp;b, &amp;c);
        GetNum(a, b, c);
        memset(dp, -1, sizeof(dp));
        ll ans = dfs(32, 1, 1, 1, 1) - max(0ll, a-c+1) - max(0ll, b-c+1);
        cout &lt;&lt; a*b-ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h2 id="I-Chessboard"><a href="#I-Chessboard" class="headerlink" title="I:Chessboard"></a>I:Chessboard</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给你一个N，M，然后你可以任意构造一个 k * k的矩阵，使得矩阵内每个元素最少是M，且任意不同行不同列的 k 个元素总和不超过N且都相同，问有多少种构造方法。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gblwd83vbfj311u0l5aee.jpg" alt="img1"></p>
<p>我们枚举$k$，我们可以把每个元素减去$M$，那么就相当于$N$减去$ k \times M$,简化问题并且不影响答案</p>
<p><strong><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gblwddv055j311p0lan1w.jpg" alt="img2"></strong></p>
<p>构造两个矩阵$Ai,Bi $对于这两个矩阵，我们可知他们前面的系数和为$T$则满足结果  等价于将$T$ 分成$2\times k$份($a$，$b$各有$k$个)采用隔板法 （将$T$ 转换成$1$排，每两个$1$之间有一个隔间，那么$k \times 2 + T$有$k \times 2 - 1 +T$个​隔间，我们选择$k \times 2 - 1$个隔间就可以把这些$1$分成$k \times 2$份</p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gblwdgjpqdj311x0l7afj.jpg" alt="img3"></p>
<p>为什么会算重，我们拿$T=3,k=2$来举个例子，比如$a_1=1,a_2=2,b_1=0,b_2=0$</p>
<p>那这个矩阵就是长这个样子</p>
<p>$\begin{bmatrix} a_1+b_1 &amp;a_1+b_2 \\ a_2+b_1 &amp;a_2+b_2 \end{bmatrix}$ $==&gt;$ $\begin{bmatrix} 1 &amp; 1\ 2 &amp;2 \end{bmatrix}$</p>
<p>跟$\begin{bmatrix} a_1-1+b_1+1 &amp;a_1-1+b_2+1\ a_2-1+b_1+1 &amp;a_2-1+b_2+1 \end{bmatrix}$ $==&gt;$ $\begin{bmatrix} 1 &amp; 1\ 2 &amp;2 \end{bmatrix}$</p>
<p>是相同的，也就是当$a_i$全部减1，而$b_i$全部加1时，跟原来的矩阵相同，所以这就重复了,那去重也就是这样去</p>
<p>PS:这篇博客其实是我扒<a href="https://blog.csdn.net/henucm/article/details/99730917" target="_blank" rel="noopener">CM大佬</a>的=^=</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int maxn = 1e5 + 5;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;

ll fac[maxn], inv[maxn];

ll Ksm(ll a, ll b, ll p) {
    ll res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}

void Fac() {
    fac[0] = 1;
    for (int i = 1; i &lt; maxn; i ++) 
        fac[i] = (fac[i-1] * i) % mod;
    inv[maxn-1] = Ksm(fac[maxn-1], mod-2, mod);
    for (int i = maxn-2; i &gt;= 0; i --)
        inv[i] = inv[i+1] * (i+1) % mod;
}

ll C(int n, int m) {
    if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0;
    return fac[n] * inv[m] % mod * inv[n-m] % mod;
}

int main() {
    Fac();
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while(T --) {
        int n, m;
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        ll ans = 0;
        for (int k = 1; k * m &lt;= n; k ++) {
            int tt = n - k*m;
            for (int t = 0; t &lt;= tt; t ++) {
                ans += C(t+k+k-1, k+k-1);
                if(t &gt;= k) ans -= C(t+k-1, k+k-1);
                ans = (ans % mod + mod) % mod;
            }
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre>
<h2 id="K-Function"><a href="#K-Function" class="headerlink" title="K:Function"></a>K:Function</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>$csl(p,x)= \begin{cases} 3e+1 &amp; x=p^e\&amp; p\in prime \&amp; p = a^2+b^2\1 &amp; x=p^e \&amp; p!= a^2+b^2\0 &amp; others\end{cases}$</p>
<p>$tl(p,x)=\max\limits_{d|x}csl(p,d)$</p>
<p>求$S=\sum\limits<em>{i=1}^{n}\prod\limits</em>{p} tl(p,i)$</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>可得知</p>
<p>$tl(p,x)=\begin{cases}3e+1&amp; x=p^e\&amp; p\in prime \&amp;p=a^2+b^2 \1 &amp; others\end{cases}$</p>
<p>$f(x)=\prod\limits_{d|n}\begin{cases}3e+1&amp; x=p^e\&amp; p\in prime \&amp;p=a^2+b^2 \1 &amp; others\end{cases}$</p>
<p>答案就是$f(i)$的前缀和,即$S=\sum\limits_{i=1}^{n}f(i)$</p>
<p>我们先不考虑$p=a^2+b^2$，考虑$i$为质数时的情况$f(i)=3+1$</p>
<p>$i$为质数次幂的情况$f(p^e)=3e+1$</p>
<p>这样可以快速算出i为质数和i的质数次幂的情况</p>
<p>可以用$min_25$筛来求这个前缀和</p>
<p>那么现在我们来考虑$p=a^2+b^2$这个限制，因为$min_25$筛由构造一个函数，把所有数字看成质数，</p>
<p>我们可以设$h[i][4]$，来代表i以前由多少数字余数为$0，1，2，3$，通过dp可以得到有多少质数余数为$0，1，2，3$</p>
<p>因为费马二次定理，我们知道模$4$与$1$的可以分解成$a^2+b^2$，而模$4$余$3$的一定不行，那么质数部分我们就都算出来了，下面的合数部分就用$min_25$筛就好了</p>
<h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e5 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;
typedef pair&lt;int, int&gt; pis;

ll sum[maxn][4], prime[maxn], tot, h[maxn][4];
ll w[maxn], m, id1[maxn], id2[maxn];
ll sqr;
bool vis[maxn];

ll f(ll p, ll e) {
    if(p % 4 == 1) return 3 * e + 1;
    return 1;
}

ll init(ll n) {
    for (int i = 0; i &lt; 4; i ++) sum[0][i] = 0;
    for (int i = 1; i &lt;= n; i ++) vis[i] = 0;
    vis[1] = 1; tot = 0;
    for (int i = 2; i &lt;= n; i ++) {
        if(!vis[i]) {
            prime[++tot] = i;
            for (int j = 0; j &lt; 4; j ++) 
                sum[tot][j] = sum[tot-1][j] + (i % 4 == j);
        }
        for (int j = 1; j &lt;= tot; j ++) {
            if(i * prime[j] &gt; n) break;
            vis[i*prime[j]] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}

void getW(ll n) {
    m = 0;//离散下标
    for (ll l = 1, r; l &lt;= n; l = r + 1) {
        r = n/(n/l);
        w[++m] = n/l;//把所有数字当成质数
        h[m][1] = w[m] / 4 + (w[m] % 4 &gt;= 1) - 1;
        h[m][2] = w[m] / 4 + (w[m] % 4 &gt;= 2);
        h[m][3] = w[m] / 4 + (w[m] % 4 &gt;= 3);
        h[m][4] = w[m] / 4;
        if(w[m] &lt;= sqr) id1[w[m]] = m;
        else id2[n/w[m]] = m;
    }
}

void getG(ll n) {//dp都质数模4的个数
    for (ll i = 1; i &lt;= tot; i ++) {
        for (ll j = 1; j &lt;= m &amp;&amp; prime[i] * prime[i] &lt;= w[j]; j ++) {
            ll d = w[j] / prime[i];
            ll id = d &lt;= sqr ? id1[d] : id2[n/d];
            for (int r = 0; r &lt; 4; r ++) 
                h[j][r*prime[i]%4] = h[j][r*prime[i]%4] - h[id][r] + sum[i-1][r];
        }
    }
}

ll S(ll x, ll y, ll n) {
    if(x &lt;= prime[y-1] || x &lt;= 1) return 0;
    ll id = x &lt;= sqr ? id1[x] : id2[n/x];
    ll ans = h[id][3] - sum[y-1][3] + 4 * (h[id][1] - sum[y-1][1]);//模4余1的值为4，余3的值为1
    if(y == 1) ans ++;
    for (ll i = y; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= x; i ++) {
        ll t = prime[i];
        for (int j = 1; t &lt;= x; j ++, t = t * prime[i]) 
            ans = ans + f(prime[i], j) * (S(x/t, i+1, n) + (j != 1));
    }
    return ans;
}

int main() { 
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --) {
        ll n;
        scanf(&quot;%lld&quot;, &amp;n);
        sqr = sqrt(n);
        init(sqr);
        getW(n);
        getG(n);
        printf(&quot;%lld\n&quot;, S(n, 1, n) + 1);//S(n,1,n)+f(1)
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第五场</title>
    <url>//b40c00ff/</url>
    <content><![CDATA[<h2 id="B-generator-1"><a href="#B-generator-1" class="headerlink" title="B:generator 1"></a>B:generator 1</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你$x<em>0,x_1,a,b, x_i=ax</em>{i-1}+bx_{i-2}$让你求出$x_n$</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>典型的矩阵快速幂，但是n的范围太大，所以得快速幂得用十进制快速幂</p>
<pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e6 + 5;
ll mod;

struct Matrix{
    ll mat[2][2];

    Matrix() {memset(mat, 0, sizeof(mat));};

    void init() {
        mat[0][0] = mat[1][1] = 1;
    }

    void init(ll a, ll b) {
        mat[0][0] = 0; mat[0][1] = b;
        mat[1][0] = 1; mat[1][1] = a;
    }

    void operator = (Matrix x) {
        for (int i = 0; i &lt;= 1; i ++)
            for (int j = 0; j &lt;= 1; j ++)
                mat[i][j] = x.mat[i][j];
    }

};

void Print(Matrix x) {
    for (int i = 0; i &lt;= 1; i ++) {
        for (int j = 0; j &lt;= 1; j ++)
            cout &lt;&lt; x.mat[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
}

Matrix operator * (Matrix x, Matrix y) {
    Matrix t;
    for (int i = 0; i &lt;= 1; i ++)
        for (int j = 0; j &lt;= 1; j ++)
            for (int k = 0; k &lt;= 1; k ++)
                t.mat[i][j] = (t.mat[i][j] + x.mat[i][k] * y.mat[k][j]) % mod;
    return t;
}

Matrix Ksm(Matrix x, ll b) {
    //cout &lt;&lt; b &lt;&lt; endl;
    Matrix t; t.init();
    while(b) {
        if(b &amp; 1) t = t * x;
        x = x * x;
        b &gt;&gt;= 1;
    }
    //Print(t);
    return t;
}


int main() {
    ll x0, x1, a, b;
    scanf(&quot;%lld %lld %lld %lld&quot;, &amp;x0, &amp;x1, &amp;a, &amp;b);
    char s[maxn];
    scanf(&quot;%s%lld&quot;, s, &amp;mod);
    int len = strlen(s);
    reverse(s, s+len);
    Matrix t, ans; t.init(a, b);
    ans.mat[0][0] = x0; ans.mat[0][1] = x1;
    Matrix res;
    res.init();
    for (int i = 0; i &lt; len; i ++) {
        res = res * Ksm(t, s[i]-&#39;0&#39;);
        t = Ksm(t, 10);
       // Print(res);
       // Print(t);
    }
    ans = ans * res;
    printf(&quot;%lld\n&quot;, ans.mat[0][0]);
    return 0;
}
</code></pre>
<h2 id="C-generator-2"><a href="#C-generator-2" class="headerlink" title="C:generator 2"></a>C:generator 2</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有这么一个递推式$x<em>i=(a\cdot x</em>{i-1}+b)\mod p$，让你求$v$在$[1,n-1]$中第一次出现的位置</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为递推式模$p$，所以$x$的循环节一定小于$p$，</p>
<p>而$x$又是这种形式$x_n=a(a(a(ax+b)+b)+b)+b$ </p>
<p>所以我们的任务就变成$A^{m} \equiv v\mod p$求最小的$m$</p>
<p>${A^1=x,A^2=(ax+b),A^3=a(ax+b)+b,A^4=a(a(ax+b)+b)+b)+b}$</p>
<p>而$A^m\equiv v\mod p$明显可以用BSGS</p>
<p>但是BSGS的一个使用条件能不能求出$A^{-i*S}$</p>
<p>但是我们怎么求出$A^{-i*S}$呢</p>
<p>正常的加是乘a加b，那么除就是除a减$\frac{b}{a}$</p>
<p>举个例子:</p>
<p>$x_0=x,x_1=ax+b,x_2=a(ax+b)+b,x_3=a(a(ax+b)+b)+b$</p>
<p>我们从$x_3$降到$x_1$,$x_3$先除$a$再减去$\frac{b}{a}$变成$x_2$，然后再除$a$减去$\frac{b}{a}$变成$x_1$</p>
<p>那我们从$A^{2S+j}$降到$A^{S+j}$只需要进行$S$次操作即可</p>
<p>这样我们就可以用BSGS了</p>
<p>跟BSGS的步骤差不多，我们可以把式子化成 $A^{i*S+j}\equiv v\mod p$</p>
<p>我们可以预处理出来$A^S$ ，然后遍历找到一个$A^j\equiv v<em>A^{-i</em>S}\mod p$</p>
<p>也就是说在这个式子中$A^{-i*S}$不是一个值，而是一种操作，把$v$所代表的次数降下$S$</p>
<p>$x_0=1,x_1=2*1+1,x_2=,x_4=15,x_5=31$</p>
<p>因为我们已经预处理了一个$A^S$,那么在我们遍历$i$的过程中每次降下一个$S$，知道找到或者找不到</p>
<p>用Hash存一下$A^j$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
typedef pair&lt;int, int&gt;pis;
const int limit = 1e6;
pis d[limit+6];
int vals[limit+6], pos[limit+6];

int Ksm(ll a, int b, int p) {
    ll res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}

int inv(int a, int p) { return Ksm(a, p-2, p); }

void solve() {
    ll n, x0, a, b, p; int Q;
    scanf(&quot;%lld %lld %lld %lld %lld %d&quot;, &amp;n, &amp;x0, &amp;a, &amp;b, &amp;p, &amp;Q);
    if(!a) {
        while(Q --) {
            int v; scanf(&quot;%d&quot;, &amp;v);
            if(v == x0) printf(&quot;0\n&quot;);
            else if(v == b) printf(&quot;1\n&quot;);
            else printf(&quot;-1\n&quot;);
        }
        return ;
    }
    d[0] = {x0, 0};
    for (int i = 1; i &lt;= limit; i ++) {
        int val = (a*d[i-1].first+b) % p;
        d[i] = {val, i};
    }
    sort(d, d+limit+1);
    int cnt = 0;
    for (int i = 0; i &lt;= limit; i ++) {
        vals[cnt] = d[i].first; pos[cnt++] = d[i].second;
        while(d[i].first == d[i+1].first &amp;&amp; i+1 &lt;= limit) i++;
    }
    int inv_a = inv(a, p);
    int inv_b = (p-b) % p * inv_a % p; 
    ll aa = 1, bb = 0;
    for (int i = 0; i &lt;= limit; i ++) {
        aa = aa * inv_a % p;
        bb = (bb * inv_a + inv_b) % p;
    }
    while(Q --) {
        int v; scanf(&quot;%d&quot;, &amp;v);
        int it = lower_bound(vals, vals+cnt, v) - vals;
        if(it &lt; cnt &amp;&amp; vals[it] == v) {
            if(pos[it] &lt; n) printf(&quot;%d\n&quot;, pos[it]);
            else printf(&quot;-1\n&quot;);
            continue;
        }
        int m = p/(limit+1) + 3, flag = 0;
        for (int i = 1; i &lt;= m; i ++) {
            v = (aa * v + bb) % p;
            it = lower_bound(vals, vals+cnt, v) - vals;
            if(it&lt;cnt &amp;&amp; vals[it] == v) {
                flag = 1;
                int res = i*(limit+1)+pos[it];
                if(res&gt;=n) res = -1;
                printf(&quot;%d\n&quot;, res);
                break;
            }
        }
        if(!flag) printf(&quot;-1\n&quot;);
    }
}

int main() {
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while(T --) solve();
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第二场</title>
    <url>//3bd8/</url>
    <content><![CDATA[<h3 id="A-Eddy-Walker"><a href="#A-Eddy-Walker" class="headerlink" title="A:Eddy Walker"></a>A:Eddy Walker</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一个n的点的环，一开始从0号点开始，每次可以前进1或者后退1，问第一次站在m号点的时候已经遍历完所有点的概率，求出前缀概率积</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一：</p>
<p>暴力打表找规律</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

double p[10];
bool vis[10];
int n;

bool Check() {
    for (int i = 0; i &lt; n; i ++)
        if(!vis[i]) return false;
    return true; 
}

void dfs(int idx, double px) {
    if(px &lt; 1e-10) return ;
    vis[idx] = 1;
    if(!Check()) {
        int nxt = (idx+1)%n;
        int tmp = vis[nxt];
        vis[nxt] = 1;
        dfs(nxt, px*0.5);
        vis[nxt] = tmp;
        nxt = (idx-1+n)%n;
        tmp = vis[nxt];
        vis[nxt] = 1;
        dfs(nxt, px*0.5);
        vis[nxt] = tmp;
    }else p[idx] += px;
}


int main() {
    for (n = 1; n &lt;= 7; n ++) {
        printf(&quot;n: %d\n&quot;, n);
        memset(p, 0, sizeof(p));
        memset(vis, 0, sizeof(vis));
        dfs(0, 1);
        for (int i = 0; i &lt; n; i ++) {
            printf(&quot;i: %d, p: %lf\n&quot;, i, p[i]);
        }
    }
    return 0;
}
</code></pre>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gblvqxupfjj304g08ymx5.jpg" alt="img1"></p>
<p>这是打表的结果，可以发现结果与m无关(当m&gt;0时)而且近似为$\frac{1}{n-1}$</p>
<p>二：<br>数学分析:<br>因为是最后站在一个非0的位置上，而每个非零的点的最后一次到达的概率是相同的，所以是$\frac{1}{n-1}$</p>
<h3 id="B-Eddy-Walker2"><a href="#B-Eddy-Walker2" class="headerlink" title="B:Eddy Walker2"></a>B:Eddy Walker2</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>现在是给你一条链，从0点出发，一个最多走k步，每一步的概率都是$\frac{1}{k}$ ,问最后走到n的概率</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>根据题意可以写出一个递推式子：</p>
<p>$dp[i] = \frac{1}{k}\sum\limits_{i=1}^{k}dp[n-i]$</p>
<p>如果n很小的话，可以直接用dp来写，但是n的大小是$1e^{9}$，所以我们就得用BM直接套板子线性递推</p>
<p>但是有一个问题，就是n可能为无穷，我们可以这样来写，</p>
<p>我们每次行动的移动记录期望是$\frac{1}{k}\sum\limits_{i=1}^{k}i=\frac{(k+1)k}{2k}=\frac{k+1}{2}$ ,也就是每行动一次大概移动$\frac{k+1}{2}$ ，而我们移动到n的次数可能为m次，那么移动的距离期望就是$\frac{(k+1)m}{2}$ 而n在其中，在这$\frac{(k+1)m}{2}$个点中，我们一共会走m个点，那么就是n在这m个点之间的概率$\frac{1}{m}$ , 期望就是$m$  ,而在整体的概率就是$\frac{m}{\frac{(k+1)m}{2}}=\frac{2}{k+1}$ </p>
<p>$dp[i]=\begin{cases} \frac{1}{k}\cdot (dp[i-1]+dp[i-2]+…+dp[i-k]),i&gt;=k\ \frac{2}{k+1},i=\infty \\end{cases}$</p>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const ll mod = 1e9 + 7;
#define sz(x) ((int)(x).size())
typedef vector&lt;ll&gt; VI;

ll Ksm(ll a, ll b) {
    ll res = 1; a %= mod;
    assert(b &gt;= 0);
    while(b) {
        if(b &amp; 1) res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}

int _, n;
namespace Linear_Seq{
    const int N = 10010;
    ll res[N], base[N], _c[N], _md[N];
    vector&lt;int&gt; Md;

    void Mul(ll *a, ll *b, int k) {
        for (int i = 0; i &lt; k+k; i ++) _c[i] = 0;
        for (int i = 0; i &lt; k; i ++)
            if(a[i]) for (int j = 0; j &lt; k; j ++)
                _c[i+j] = (_c[i+j] + a[i]*b[j]) % mod;
        for (int i = k + k - 1; i &gt;= k; i --)
            if(_c[i]) for (int j = 0; j &lt; sz(Md); j ++)
                _c[i-k+Md[j]] = (_c[i-k+Md[j]] - _c[i] * _md[Md[j]]) % mod;
        for (int i = 0; i &lt; k; i ++)
            a[i] = _c[i];
    }

    int solve(ll n, VI a, VI b) {
        ll ans = 0, pnt = 0;
        int k = sz(a);
        assert(sz(a) == sz(b));
        for (int i = 0; i &lt; k; i ++) _md[k-1-i] = -a[i];
        _md[k] = 1; Md.clear();
        for (int i = 0; i &lt; k; i ++) 
            if(_md[i]) Md.push_back(i);
        for (int i = 0; i &lt; k; i ++) res[i] = base[i] = 0;
        res[0] = 1;
        while((1ll&lt;&lt;pnt) &lt;= n) pnt ++;
        for (int p = pnt; p &gt;= 0; p --) {
            Mul(res, res, k);
            if((n&gt;&gt;p) &amp; 1) {
                for (int i = k-1; i &gt;= 0; i --) res[i+1] = res[i];
                res[0] = 0;
                for (int j = 0; j &lt; sz(Md); j ++)
                    res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod;
            }
        }
        for (int i = 0; i &lt; k; i ++) ans = (ans + res[i] * b[i]) % mod;
        if(ans &lt; 0) ans += mod;
        return ans;
    }

    VI BM(VI s) {
        VI C(1, 1), B(1, 1);
        int L = 0, m = 1, b = 1;
        for (int n = 0; n &lt; sz(s); n ++) {
            ll d = 0;
            for (int i = 0; i &lt; L + 1; i ++) d = (d + (ll)C[i] * s[n-i]) % mod;
            if (d == 0) ++m;
            else if(2 * L &lt;= n) {
                VI T = C;
                ll c = mod - d * Ksm(b, mod-2) % mod;
                while(sz(C) &lt; sz(B) + m) C.push_back(0);
                for (int i = 0; i &lt; sz(B); i ++) C[i+m] = (C[i+m] + c * B[i]) % mod;
                L = n + 1 - L; B = T;
                b = d; m = 1;
            }else {
                ll c = mod - d * Ksm(b, mod-2) % mod;
                while(sz(C) &lt; sz(B) + m) C.push_back(0);
                for (int i = 0; i &lt; sz(B); i ++) C[i+m] = (C[i+m] + c * B[i]) % mod;
                ++ m;
            }
        }
        return C;
    }

    int Gao(VI a, ll n) {
        VI c = BM(a);
        c.erase(c.begin());
        for (int i = 0; i &lt; sz(c); i ++) c[i] = (mod-c[i]) % mod;
        return solve(n, c, VI(a.begin(), a.begin()+sz(c)));
    }
};
using namespace Linear_Seq;

void solve() {
    ll n, k;
    scanf(&quot;%lld %lld&quot;, &amp;k, &amp;n);
    if(n == 0) {
        printf(&quot;1\n&quot;);
        return ;
    }else if(n == -1) {
        printf(&quot;%lld\n&quot;, 2 * Ksm(k+1, mod-2) % mod);
        return ;
    }
    VI dp(3*k, 0), v;
    dp[0] = 1;
    v.push_back(1);
    for (int i = 1; i &lt;= k; i ++) {
        for (int j = 0; j &lt; i; j ++)
            dp[i] = (dp[i] + dp[j]) % mod;
        dp[i] = dp[i] * Ksm(k, mod-2) % mod;
        v.push_back(dp[i]);
    }
    for (int i = k+1; i &lt;= 2 * k; i ++) {
        for (int j = 1; j &lt;= k; j ++)
            dp[i] = (dp[i] + dp[i-j]) % mod;
        dp[i] = dp[i] * Ksm(k, mod-2) % mod;
        v.push_back(dp[i]);
    }
    printf(&quot;%lld\n&quot;, Gao(v, n));
}

int main() {
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while(T --)
        solve();
    return 0;
}
</code></pre>
<h3 id="E-MAZE"><a href="#E-MAZE" class="headerlink" title="E:MAZE"></a>E:MAZE</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给你一个NxM的地图，0表示可走，1表示不可走，</p>
<p>有$Q$次询问，可能会对某一位置取反，可能问你从$(1,a)$到$(n,b)$有多少走法</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>因为题目 要求不能往回走，所以如果我们从下面开始走，那么我们在横向移动是就不能改变方向，然后向上走</p>
<p>我们先用$dp$来考虑一下做法：设$dp[i][j]$是经由下面$dp[i-1][j]$走过来的走法数，那么从左边或右边走过来的方法数呢，我们可以在最后在加一层，那么$dp[0][j]$就加上了第1层左右到达$dp[1][j]$的方法数</p>
<p>那么$dp[i][j] = sum(dp[i-1][j]+dp[i-1][j-1] + … dp[i-1][j-k])+sum(dp[i-1][j+1]+dp[i-1][j+2]+…+dp[i-1][j+k])$</p>
<p>$dp[i][j]$由$i-1$层，$i$的左边第一个1和$i$的右边第一个1，这么一段区间里的$dp$值转移过来</p>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gblvr084gfj30c401tgld.jpg" alt="img2"></p>
<p>比如这样一个2X6的地图,</p>
<p>$dp[1][3]=dp[2][2]+dp[2][3]+dp[2][4]+d[2][5]$</p>
<p>$dp[1][4]=dp[2][2]+dp[2][3]+dp[2][4]+d[2][5]$</p>
<p>由于上一层的每个值都是有下面的值组成，那么我们就可以构造出一个矩阵</p>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1gblvr2ih74j306b04la9u.jpg" alt="img3"><br>这样我们就能从第$i$层转移到第$i-1$层了</p>
<p>现在来考虑地图修改的情况</p>
<p>这n个矩阵我们可以用一个线段树来维护，地图修改时用线段树来修改矩阵就行了</p>
<h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long

const int maxn = 5e4 + 5;
const int mod = 1e9+7;
char c[maxn][15];
int dp[maxn][15];

int N, M, Q;

struct Maze {
    int maze[15][15];

    Maze() {memset(maze, 0, sizeof(maze));}

    void init() {for (int i = 0; i &lt; 15; i ++) maze[i][i] = 1;}

    Maze friend operator * (Maze a, Maze b) {
        Maze c;
        for (int i = 0; i &lt; M; i ++)
            for (int j = 0; j &lt; M; j ++)
                for (int k = 0; k &lt; M; k ++)
                    c.maze[i][j] = (c.maze[i][j] + 1ll * a.maze[i][k] * b.maze[k][j]) % mod;
        return c;
    }

};

struct Seg{
    Maze w[maxn&lt;&lt;2];

    void Build(int rt, int l, int r) {
        if(l == r) {
            for (int i = 0; i &lt; M; i ++) {
                if(c[l][i] == &#39;0&#39;) {
                    for (int j = i; j &gt;= 0; j --)
                        if(c[l-1][j] == &#39;1&#39;) break;
                        else w[rt].maze[j][i] = 1;
                    for (int j = i; j &lt; M; j ++)
                        if(c[l-1][j] == &#39;1&#39;) break;
                        else w[rt].maze[j][i] = 1;
                }
            }
            return ;
        }
        int m = (l + r) &gt;&gt; 1;
        Build(rt*2, l, m);
        Build(rt*2+1, m+1, r);
        w[rt] = w[rt*2] * w[rt*2+1];
    }

    void Updata(int rt, int l, int r, int pos) {
        if(l == r) {
            for (int i = 0; i &lt; M; i ++)
                for (int j = 0; j &lt; M; j ++)
                    w[rt].maze[i][j] = 0;
            for (int i = 0; i &lt; M; i ++) {
                if(c[l][i] == &#39;0&#39;) {
                    for (int j = i; j &gt;= 0; j --)
                        if(c[l-1][j] == &#39;1&#39;) break;
                        else w[rt].maze[j][i] = 1;
                    for (int j = i; j &lt; M; j ++)
                        if(c[l-1][j] == &#39;1&#39;) break;
                        else w[rt].maze[j][i] = 1;
                }
            }
            return ;
        }
        int m = (l + r) &gt;&gt; 1;
        if(pos &lt;= m) Updata(rt*2, l, m, pos);
        else Updata(rt*2+1, m+1, r, pos);
        w[rt] = w[rt*2] * w[rt*2+1];
    }

    void Updata(int pos) {
        Updata(1, 1, N, pos);
    }

}seg;

int main() {
    scanf(&quot;%d %d %d&quot;, &amp;N, &amp;M, &amp;Q);
    for (int i = 0; i &lt; N; i ++) scanf(&quot;%s&quot;, c[i]);
    for (int i = 0; i &lt; M; i ++) c[N][i] = &#39;0&#39;;
    seg.Build(1, 1, N);
    //seg.Print(1, 1, N);
    while(Q --) {
        int op, a, b;
        scanf(&quot;%d %d %d&quot;, &amp;op, &amp;a, &amp;b);
        if(op == 1) {
            if(c[a-1][b-1] == &#39;0&#39;) c[a-1][b-1] = &#39;1&#39;;
            else c[a-1][b-1] = &#39;0&#39;;
            if(a &gt; 1) seg.Updata(a-1);
            seg.Updata(a);
        } else {
            Maze ans = seg.w[1];
            Maze t1;
            t1.maze[0][a-1] = 1;
            t1 = t1 * ans;
            printf(&quot;%d\n&quot;, t1.maze[0][b-1]);
        }
    }  

    return 0;

}
</code></pre>
<h3 id="F-Partition-problen"><a href="#F-Partition-problen" class="headerlink" title="F:Partition problen"></a>F:Partition problen</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给你2N个人，每对人如果不在同一队的话，有一个竞争值，你要把这些人分为人数相等的两个队，使得竞争值最大</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>直接暴力</p>
<h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">//队友代码：
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long 
const int maxn = 1e5 + 5;
vector&lt;int&gt; a, b;
int c[30][30];
int n;
ll ans = 0;

void dfs(int idx, ll cur) {
    if(idx == 2 * n + 1) {
        ans = max(ans, cur);
        return ;
    }
    ll sum = 0;
    if(a.size() &lt; n) {
        a.push_back(idx);
        sum = 0;
        for (int &amp;v: b) sum += c[idx][v];
        dfs(idx+1, cur+sum);
        a.pop_back(); 
    }
    if(b.size() &lt; n) {
        b.push_back(idx);
        sum = 0;
        for (int &amp;v: a) sum += c[idx][v];
        dfs(idx + 1, cur + sum);
        b.pop_back();
    }
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= 2*n; i ++)
        for (int j = 1; j &lt;= 2*n; j ++)
            scanf(&quot;%d&quot;, &amp;c[i][j]);
    dfs(1, 0);
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>
<h3 id="H-Second-Large-Rectangle"><a href="#H-Second-Large-Rectangle" class="headerlink" title="H:Second Large Rectangle"></a>H:Second Large Rectangle</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给你一个NXM的矩阵，只有01组成，求第二大的全为1的子矩阵</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>单调栈求最大子矩阵，在过程中就也求出了第二大的子矩阵，然后第一大的宽减一，高减一，和第二大的比较输出最大的</p>
<p>单调栈求最大子矩阵的方法：</p>
<p>逐层遍历，对于每一层求出一个h[]，h表示以此层为底1的高度</p>
<p>比如：<br><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gblvr4t3iuj305502a0sh.jpg" alt="img4"></p>
<p>这样一个矩阵,h为：</p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gblvr776j5j308802qjr5.jpg" alt="img5"></p>
<p>这样对于每一层就变成一个求最大矩阵的形式，</p>
<p>对于每一层用单调栈求出最大矩阵，注意要记得去重，像上图中的第二层，第二列，第三列，第四列求出的是同一个矩阵，不去重的话无法跟第二大的比较，去重很简单，就记录一下，左边界和上边界即可，</p>
<h4 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long 
const int maxn = 1e3+5;
const int inf = 0x3f3f3f3f;
typedef pair&lt;int, int&gt; pis;

struct Pis{
  int res, x, h;

  bool friend operator &lt; (Pis a, Pis b) {
    return a.res &gt; b.res;
  } 
};

char c[maxn][maxn];
int maz[maxn][maxn], h[maxn];
int pre[maxn], suf[maxn];
stack&lt;pis&gt; sta;
int n, m;
map&lt;pis, int&gt; mp;
vector&lt;Pis&gt; ans;

void getPS() {
    while(!sta.empty()) sta.pop();
    sta.push(pis{-inf, 0});
    for (int j = 1; j &lt;= m; j ++) {
      while(h[j] &lt;= sta.top().first) sta.pop();
      pre[j] = sta.top().second+1;
      sta.push(pis{h[j], j});
    }
    while(!sta.empty()) sta.pop();
    sta.push(pis{-inf, m+1});
    for (int j = m; j &gt;= 1; j --) {
      while(h[j] &lt;= sta.top().first) sta.pop();
      suf[j] = sta.top().second-1;
      sta.push(pis{h[j], j});
    }
}

void getH(int i) {
    for (int j = 1; j &lt;= m; j ++)
      if(maz[i][j]) h[j] += 1;
      else h[j] = 0;
}

int main() {
  scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
  for (int i = 1; i &lt;= n; i ++)
    scanf(&quot;%s&quot;, c[i]+1);
  for (int i = 1; i &lt;= n; i ++)
    for (int j = 1; j &lt;= m; j ++)
      maz[i][j] = c[i][j] - &#39;0&#39;;
  for (int i = 1; i &lt;= n; i ++) {
      getH(i); getPS();
      mp.clear();
      for (int i = 1; i &lt;= m; i ++) {
        if(!mp[pis{pre[i], h[i]}]) {
          mp[pis{pre[i], h[i]}] = 1;
          int sum = (suf[i]-pre[i]+1) * h[i];
          ans.push_back(Pis{sum, pre[i], h[i]});
        }
      }
  }  
  sort(ans.begin(), ans.end());
  if(ans.size() &lt;= 1) printf(&quot;0\n&quot;);
  else {
    int tx = ans[0].res/ans[0].h, ty = ans[0].h;
    printf(&quot;%d\n&quot;, max(ans[1].res, max(tx*(ty-1), (tx-1)*ty)));
  }
  return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客多校第一场</title>
    <url>//aba2/</url>
    <content><![CDATA[<h3 id="A-Equivalent-Prefixes"><a href="#A-Equivalent-Prefixes" class="headerlink" title="A. Equivalent Prefixes"></a>A. Equivalent Prefixes</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>两个序列相等的条件是RMQ(u,l,r) = RMQ(u,l,r)，($1\leq l \leq r\leq m$) ,RMQ(u,l,r)代表序列u，的任意区间(l,r）的最小值的序号，求一个最大的P，使得$\lbrace a_1, a_2,…a_p \rbrace$和$\lbrace b_1,b_2,…b_p \rbrace$相等</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们假设$last_a[i]= max\lbrace j|j&lt;i \&amp;\&amp; a_j&lt;a_i\rbrace$ ,也就是$a_i$左边序号最大的小于$a_i$的数字的位置，</p>
<p>我们用单调栈去求这个last，求得以后</p>
<p>那么我们求序列[1,r]的RMQ，就是找到last[r],last[last[r]],last[last[last[r]],的值</p>
<p>如果两个序列的last数组相同，那么就证明$RMQ(a,l,r)=RMQ(b,l,r)$</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e5 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;
typedef pair&lt;int, int&gt; pis;

int a[maxn], b[maxn];
int lasta[maxn], lastb[maxn];

stack&lt;pis&gt; sta;

int main() { 
    int n;
    while(~scanf(&quot;%d&quot;, &amp;n)) {
        for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
        for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;b[i]);
        while(!sta.empty()) sta.pop();
        sta.push(pis{0, 0});
        for (int i = 1; i &lt;= n; i ++) {
            while(sta.top().first &gt; a[i]) sta.pop();
            lasta[i] = sta.top().second;
            sta.push((pis{a[i], i})); 
        }
        while(!sta.empty()) sta.pop();
        sta.push(pis{0, 0});
        for (int i = 1; i &lt;= n; i ++) {
            while(sta.top().first &gt; b[i]) sta.pop();
            lastb[i] = sta.top().second;
            sta.push((pis{b[i], i})); 
        }
        int cnt = 0;
        for (int i = 1; i &lt;= n; i ++) {
            if(lasta[i] == lastb[i]) cnt ++;
            else break;
        }
        cout &lt;&lt; cnt &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h3 id="B-Integration"><a href="#B-Integration" class="headerlink" title="B.Integration"></a>B.Integration</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>已知$\int_0^{\infty}\frac{1}{1+x^2}dx=\frac{\pi}{2}$</p>
<p>求：$\frac{1}{\pi}\int<em>0^{\infty}\frac{1}{\prod\limits</em>{i=1}^{n}(a_i^2+x^2)}dx$</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>我们先算$\frac{1}{\prod\limits<em>{i=1}^{n}(a_i^2+x^2)}$<br>$=\frac{1}{a_1^2+x^2}  \frac{1}{a_2^2+x^2}\frac{1}{\prod\limits</em>{i=3}^{n}a<em>i^2+x^2}\<br>=\frac{1}{(a_2^2-a_1^2)}(\frac{1}{a_1^2+x^2}-\frac{1}{a_2^2+x^2})\frac{1}{\prod\limits</em>{i=3}^{n}a<em>i^2+x^2}\<br>=\frac{1}{(a_2^2-a_1^2)}(\frac{1}{a_1^2+x^2}-\frac{1}{a_2^2+x^2})\frac{1}{a_3^2+x^2}\frac{1}{\prod\limits</em>{i=4}^{n}a<em>i^2+x^2}\<br>=\frac{1}{(a_2^2-a_1^2)}(\frac{1}{a_1^2+x^2}\frac{1}{a_3^2+x^2}-\frac{1}{a_2^2+x^2}\frac{1}{a_3^2+x^2})\frac{1}{\prod\limits</em>{i=4}^{n}a<em>i^2+x^2}\<br>=\frac{1}{(a_2^2-a_1^2)}(\frac{1}{(a_1^2-a_3^2)}(\frac{1}{a_3^2+x^2}-\frac{1}{a_1^2+x^2})-\frac{1}{(a_3^2-a_2^2)}(\frac{1}{a_2^2+x^2}-\frac{1}{a_3^2+x^2}))\frac{1}{\prod\limits</em>{i=4}^{n}a<em>i^2+x^2}\<br>=(\frac{1}{a_2^2-a_1^2}\frac{1}{a_3^2-a_1^2})\frac{1}{a_1^2+x^2}+(\frac{1}{a_1^2-a_2^2}\frac{1}{a_3^2-a_2^2})\frac{1}{a_2^2+x^2}+(\frac{1}{a_1^2-a_3^2}\frac{1}{a_2^2-a_3^2})\frac{1}{a_3^2+x^2}\<br>=…\<br>=\sum\limits</em>{i=1}^{n}\frac{1}{\prod\limits<em>{j=1,j!=i}^{n}(a_j^2-a_i^2)}\frac{1}{a_i^2+x^2}$<br>我们设$c_i=\prod\limits</em>{j=1,j!=i}^{n}(a<em>j^2-a_i^2)$<br>$原式=\sum\limits</em>{i=1}^{n}\frac{1}{c<em>i}\frac{1}{a_i^2+x^2}$<br>那么<br>$\frac{1}{\pi}\int_0^{\infty}\frac{1}{\prod\limits</em>{i=1}^{n}(a<em>i^2+x^2)}dx\<br>=\frac{1}{\pi}\int_0^{\infty}\sum\limits</em>{i=1}^{n}\frac{1}{c<em>i}\frac{1}{a_i^2+x^2}\<br>=\frac{1}{\pi}\sum\limits</em>{i=1}^{n}\frac{1}{c<em>i}\int_0^{\infty}\frac{1}{a_i^2+x^2}\<br>=\frac{1}{\pi}\sum\limits</em>{i=1}^{n}\frac{1}{c<em>i}\frac{\pi}{2a_i}\<br>=\sum\limits</em>{i=1}^{n}\frac{1}{2c_ia_i}$</p>
<h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e5 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;
typedef pair&lt;int, int&gt; pis;

ll a[maxn], b[maxn];
int n;

ll ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) {
    if(!b) {
        x = 1; y = 0;
        return a;
    }
    ll d = ex_gcd(b, a % b, x, y);
    ll t = x;
    x = y; y = t - a / b * y;
    return d;
}

ll getInv(ll a, ll p) {
    ll x, y;
    ex_gcd(a, p, x, y);
    x = ((x % p) + p) % p;
    return x;
}

ll solve(ll x, int idx) {
    ll res = x;
    for (int i = 1; i &lt;= n; i ++) {
        if(i == idx) continue;
        res *= (b[i] - b[idx] + mod) % mod;
        res %= mod;
    }
    return getInv(res, mod);
}

int main() { 
    while(~scanf(&quot;%d&quot;, &amp;n)) {
        for (int i = 1; i &lt;= n; i ++) {
            scanf(&quot;%lld&quot;, &amp;a[i]);
            b[i] = a[i] * a[i] % mod;
        }
        ll ans = 0;
        for (int i = 1; i &lt;= n; i ++)
            ans = (ans + solve(a[i], i)) % mod;
        printf(&quot;%lld\n&quot;, ans * getInv(2, mod) % mod);
    }
    return 0;
}
</code></pre>
<h3 id="C-Euclidean-Distance"><a href="#C-Euclidean-Distance" class="headerlink" title="C:Euclidean Distance"></a>C:Euclidean Distance</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给你一些点$(\frac{a<em>1}{m},\frac{a_2}{m},…,\frac{a_n}{m})$,让你找一些$p_i$,使得$\sum\limits</em>{i=1}^{n}(p<em>i-a_i)^2$最小,$p_i$满足$\sum\limits</em>{i=1}^{n}p_i=1,p_i&gt;=0$</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>听说题解是用拉格朗日乘子法，但我也不会，<br>我看到有别人用的是贪心<br>因为所有的$a_i$都是除以m的，所以我们把$a_i$和$p_i$都乘以m，那么我们就变成了用m步使得面积最小（负数的面积不能变小只能变大）</p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gblwpw02trj30ex0bp747.jpg" alt="img1"><br>那么贪心的做法就是把大的尽量的变小，因为是排过序的，所以前面的要比后面的大。<br>每次都试着把前i-1块变得跟第i块平齐，如果不能就把前(i-1)块全部减小$\frac{k}{i-1}$,保持前面的平齐<br><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gblwpylruqj30dy0b1mx7.jpg" alt="img2"></p>
<h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 5e5 + 5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;

ll a[maxn];

bool cmp(ll a, ll b) {
    return a &gt; b;
}

ll gcd(ll a, ll b) {
    return !b ? a : gcd(b, a % b);
}

int main() {
    ll n, m;
    while(~scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m)) {
        for (int i = 1; i &lt;= n; i ++) 
            scanf(&quot;%lld&quot;, &amp;a[i]);
        sort(a + 1, a + n + 1, cmp);
        ll k = m;
        for (int i = 2; i &lt;= n; i ++) {
            if(k &gt; (a[i-1] - a[i]) * (i-1)) {
                k -= 1ll * (a[i-1] - a[i]) * (i-1);
            }else {
                for (int j = 1; j &lt;= i-1; j ++) 
                    a[j] = 1ll* (i-1) * a[i-1] - k;
                for (int j = i; j &lt;= n; j ++)
                    a[j] = 1ll * a[j] * (i-1);
                m = 1ll * m * (i-1);
                k = 0;
                break;
            }
        }
        if(k) {
            for (int i = 1; i &lt;= n; i ++) 
                a[i] = 1ll * (a[n] * n) - k;
            m = 1ll * m * n;
        }
        ll ans = 0; 
        for (int i = 1; i &lt;= n; i ++) 
            ans = (ans + 1ll * a[i] * a[i]);
        m = 1ll * m * m;
        ll k1 = gcd(ans, m);
        ans /= k1;
        m /= k1;
        if(m == 1) printf(&quot;%lld\n&quot;, ans);
        else printf(&quot;%lld/%lld\n&quot;, ans, m);
    }
    return 0;
}
</code></pre>
<h3 id="E-ABBA"><a href="#E-ABBA" class="headerlink" title="E:ABBA"></a>E:ABBA</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给你n个AB和m个BA，问你能构造出多少个长度为(n+m)*2并且能组成n个AB和B个BA的串</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>如果我们把A看做-1，B看成1，那么构成串的前缀和应该在[-n,m]，如果不在就是不合法的串<br>然后我们在用dp[i][j]来表示构成串的前i+j位中有i个A,j个B，那么我们考虑dp[i][j]—&gt;(dp[i+1][j],dp[i][j+1])<br>转移是只需要判断(dp[i+1][j],dp[i][j+1])是否合法即可</p>
<h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 2e3 + 5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;

ll dp[maxn][maxn];

int main() {
    int n, m;
    while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF) {
        for (int i = 0; i &lt;= n + m; i ++)
            for (int j = 0; j &lt;= n + m; j ++)
                dp[i][j] = 0;
        dp[0][0] = 1;
        for (int i = 0; i &lt;= n+m; i ++) {
            for (int j = max(0, i-n); j &lt;= min(n+m, i+m); j ++) {
                if(i) dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod;
                if(j) dp[i][j] = (dp[i][j] + dp[i][j-1]) % mod;
            }
        }
        printf(&quot;%lld\n&quot;, dp[n+m][n+m]);
    }
    return 0;
}
</code></pre>
<h3 id="H-XOR"><a href="#H-XOR" class="headerlink" title="H:XOR"></a>H:XOR</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给你一堆数，让你找他们子集xor和位0的的子集的大小之和</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>明显的线性集问题,首先我们要知道一堆数字组成线性集，</p>
<p>可以范围线性集外的数字和线性集内的数字，线性集内的数字可以xor出线性集外的所有子集</p>
<p>因为是问子集大小的和，所以我们可以转化成求每个数字的贡献</p>
<p>分为两种：我们设数字总数为$n$,线性集大小为$r$</p>
<p>1.线性集外数字的贡献：</p>
<p>因为线性集内的数字能把线性集外的所有子集xor出来。</p>
<p>我们枚举线性集外的每一个数字$x$，那么如果线性集内的数字能把$x$xor出来那么，$x$对应的</p>
<p>线性集外的子集大小就为$2^{n-r-1}$,即这个数字的贡献就为$2^{n-r-1}$</p>
<p>2.线性集内的数字的贡献：</p>
<p>对剩下的n-1个数字做一次线性集，看是否能把$x$xor出来，能xor出来贡献就为$2^{n-r-1}$，不能就为0</p>
<h4 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e5 + 7;
const int inf = 0x3f3f3f3f;
const int mod = 1e9 + 7;
typedef pair&lt;int, int&gt; pis;

ll a[maxn];
bool vis[maxn];
vector&lt;int&gt; vec;

struct LB{
    ll b[65], cnt = 0;
    bool flag;

    void init() {
        memset(b, 0, sizeof(b));
        flag = false;
        cnt = 0;
    }

    void ins(ll x) {
        for (int i = 62; i &gt;= 0; i --)
            if(x &gt;&gt; i) {
                if(!b[i]) { b[i] = x; cnt ++; return ; }
                x ^= b[i];
            }
            flag = true;
    }

    bool Fin(ll x) {
        if(x == 0 &amp;&amp; flag) return true;
        for (int i = 62; i &gt;= 0; i --) {
            if(x &gt;&gt; i) {
                x ^= b[i];
            }
        }
        return x == 0;
    }
}A, B, C;

ll Ksm(ll a, ll b) {
    ll res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}

int main() {
    int n;
    while(~scanf(&quot;%d&quot;, &amp;n)) {
        A.init(); B.init(); vec.clear();
        for (int i = 1; i &lt;= n; i ++) {
            scanf(&quot;%lld&quot;, &amp;a[i]);
            if(!A.Fin(a[i])) {
                A.ins(a[i]);
                vec.push_back(i);
            }else B.ins(a[i]);
        }
        ll r = A.cnt;
        if(n == r) {
            cout &lt;&lt; 0 &lt;&lt; endl;
            continue;
        }
        ll base = Ksm(2, n-r-1);
        ll sum = base * (n-r) % mod;
        for (auto &amp;it: vec) {
            ll x = a[it];
            for (int i = 0; i &lt;= 62; i ++)
                C.b[i] = B.b[i];
            C.flag = B.flag;
            for (auto &amp;it2: vec)
                if(it != it2) C.ins(a[it2]);
            if(C.Fin(x)) sum = (sum + base) % mod;
        }
        printf(&quot;%lld\n&quot;, sum);
    }
    return 0;
}
</code></pre>
<h3 id="I-Points-Division"><a href="#I-Points-Division" class="headerlink" title="I:Points Division"></a>I:Points Division</h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>给你n个点，把点划分成A,B两部分，规定$i\in A$ and $j\in B$  and $x_j \leq x_i$ and $y_i\leq y_j$</p>
<p>求最后$\sum\limits<em>{i\in A}a_i+\sum\limits</em>{j\in B}b_j$ 的最大值</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>我们发现$A$位于左上角，$B$位于右上角，$AB$边界时一条不下降的折线,所以我们可以沿着这条折线进行$dp$，</p>
<p>我们规定折线上的点全是$B$上的点。</p>
<p>首先我们先把纵坐标离散化，然后用$dp[i]$来表示当高度为i时最大值为多少</p>
<p>然后我们来求每一个点对结果的贡献，</p>
<p>对于一个点$i$,有两种情况:</p>
<p>​        一：这个点不在折线上，那么大于$y_i$并且在折线上面的点$j$，$i$相当于位于$B$，那么$i$对于$j$的贡献就是$b_i$,对于那些小于$y_i$并且在折线上面的点$k$，$i$相当于位于$A$，那么$i$对$k$的贡献就是$a_i$,</p>
<p>​        二：这个点在折线上，$dp[i]$就由从$1到i-1$的点的最大值+$b<em>i$ 也就是$dp[i] = \max\limits</em>{1\leq j &lt; i} dp[j] + b_i$ </p>
<p>大体思路就是这样，因为我们要对区间操作，所以要用一个线段树来维护一下</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>因为我们默认折线上的点全是属于$B$的点，这就导致不会有$A=P$ and $B=\emptyset$的情况，但是我们在点中加入一个$(0,0)$的点，因为$1\leq x_i, y_i\leq 10^9$那么所有的点都位于$(0,0)$上面，对$(0,0)$的贡献就是$B=\emptyset$的值</p>
<h4 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h4><pre><code class="lang-c">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int maxn = 1e5 + 5;

struct Node{
    ll x, y, a, b;

    bool friend operator &lt; (Node a, Node b) {
        if(a.x == b.x) return a.y &gt; b.y;
        return a.x &lt; b.x;
    }

}node[maxn];
ll ty[maxn];

struct Seg{
    ll dp[maxn&lt;&lt;2], lazy[maxn&lt;&lt;2];

    void Build(int rt, int l, int r) {
        if (l == r) {
            dp[rt] = 0;
            lazy[rt] = 0;
            return ;
        }
        lazy[rt] = 0; dp[rt] = 0;
        int m = (l + r) &gt;&gt; 1;
        Build(rt&lt;&lt;1, l, m);
        Build(rt&lt;&lt;1|1, m+1, r);
    }

    void down(int rt) {
        lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt];
        dp[rt&lt;&lt;1] += lazy[rt]; dp[rt&lt;&lt;1|1] += lazy[rt];
        lazy[rt] = 0;
    }

    void Updata(int rt, int l, int r, int L, int R, ll v) { //区间更新
        if(l &gt;= L &amp;&amp; r &lt;= R) {
            dp[rt] += v;
            lazy[rt] += v;
            return ;
        }
        if(lazy[rt]) down(rt);
        int m = (l + r) &gt;&gt; 1;
        if(L &lt;= m) Updata(rt&lt;&lt;1, l, m, L, R, v);
        if(R &gt; m) Updata(rt&lt;&lt;1|1, m+1, r, L, R, v);
        dp[rt] = max(dp[rt&lt;&lt;1], dp[rt&lt;&lt;1|1]);
    }

    void Updata(int rt, int l, int r, int w, ll v) { //单点更新
        if(l == r) {
            dp[rt] = max(dp[rt], v);
            return ;
        }
        if(lazy[rt]) down(rt);
        int m = (l + r) &gt;&gt; 1;
        if(w &lt;= m) Updata(rt&lt;&lt;1, l, m, w, v);
        else Updata(rt&lt;&lt;1|1, m+1, r, w, v);
        dp[rt] = max(dp[rt&lt;&lt;1], dp[rt&lt;&lt;1|1]);
    }

    ll Query(int rt, int l, int r, int L, int R) {
        if(l &gt;= L &amp;&amp; r &lt;= R) return dp[rt];
        ll Max = 0;
        int m = (l + r) &gt;&gt; 1;
        if(L &lt;= m) Max = max(Max, Query(rt&lt;&lt;1, l, m, L, R));
        if(R &gt; m) Max = max(Max, Query(rt&lt;&lt;1|1, m+1, r, L, R));
        return Max;
    }
}seg;


int main() {
    int n;
    while(~scanf(&quot;%d&quot;, &amp;n)) {
        int cnt = 0;
        ty[cnt++] = 0;
        node[0] = Node{0, 0, 0, 0};
        for (int i = 1; i &lt;= n; i ++) {
            scanf(&quot;%lld %lld %lld %lld&quot;, &amp;node[i].x, &amp;node[i].y, &amp;node[i].a, &amp;node[i].b);
            ty[cnt++] = node[i].y;
        }
        sort(ty, ty + cnt);
        cnt = unique(ty, ty+cnt) - ty;
        for (int i = 0; i &lt;= n; i ++) 
            node[i].y = lower_bound(ty, ty + cnt, node[i].y) - ty + 1;
        sort(node, node + 1 + n);
        seg.Build(1, 1, cnt);
        for (int i = 0; i &lt;= n; i ++) {
            if(node[i].y &lt; cnt) seg.Updata(1, 1, cnt, node[i].y+1, cnt, node[i].b); //[node.y+1~cnt]+a
            seg.Updata(1, 1, cnt, node[i].y, seg.Query(1, 1, cnt, 1, node[i].y)+node[i].b);//dp[i] = max
            if(node[i].y &gt; 1) seg.Updata(1, 1, cnt, 1, node[i].y-1, node[i].a);//[1~node.y] + b
        }
        printf(&quot;%lld\n&quot;, seg.dp[1]);
    }

    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title>My First Blog</title>
    <url>//81cc/</url>
    <content><![CDATA[<p>这是我的第一篇博客，主要写一些Hexo的配置</p>
<h1 id="Hexo-Github-搭建博客："><a href="#Hexo-Github-搭建博客：" class="headerlink" title="Hexo + Github 搭建博客："></a>Hexo + Github 搭建博客：</h1><p><a href="https://blog.csdn.net/ainuser/article/details/77609180" target="_blank" rel="noopener">跟着这篇博客走即可</a></p>
<h1 id="Hexo-主题配置"><a href="#Hexo-主题配置" class="headerlink" title="Hexo 主题配置"></a>Hexo 主题配置</h1><p>Hexo目录下的_config.yml称为站点配置文件</p>
<p>Hexo/themes/next/目录下的_config.yml称为主题配置文件</p>
<h2 id="next主题"><a href="#next主题" class="headerlink" title="next主题"></a>next主题</h2><p>下载next主题</p>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gblv57b6g3j30om01v74a.jpg" alt="img1"></p>
<pre><code class="lang-stylus"> git clone https://github.com/theme-next/hexo-theme-next themes/next
</code></pre>
<p>在站点配置文件 <code>_config.yml</code></p>
<p><img src="https://wx2.sinaimg.cn/mw690/0083TyOJly1gblv59sp7bj30el03i0t4.jpg" alt="img2"></p>
<pre><code class="lang-yaml"># Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: next
</code></pre>
<p>在主题配置文件<code>_config.yml</code>中可以选择四种scheme，我选择的是<code>Gemini</code></p>
<p><img src="https://wx1.sinaimg.cn/mw690/0083TyOJly1gblv5clsagj309q07raa7.jpg" alt="img3"></p>
<pre><code class="lang-yaml"># ---------------------------------------------------------------
# Scheme Settings
# ---------------------------------------------------------------

# Schemes
#scheme: Muse
#scheme: Mist
#scheme: Pisces
scheme: Gemini
</code></pre>
<h2 id="基本信息配置"><a href="#基本信息配置" class="headerlink" title="基本信息配置"></a>基本信息配置</h2><p>配置站点配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml">title: 标题
subtitle: 副标题
description: 描述
author: 作者
language: 语言（简体中文是zh-Hans）
timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）
</code></pre>
<h2 id="菜单信息配置："><a href="#菜单信息配置：" class="headerlink" title="菜单信息配置："></a>菜单信息配置：</h2><p>配置主题配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml">menu:
  home: / || home
  about: /about/ || user
  tags: /tags/ || tags
  categories: /categories/ || th
  archives: /archives/ || archive
  #schedule: /schedule/ || calendar
  #sitemap: /sitemap.xml || sitemap
  #commonweal: /404/ || heartbeat

# Enable/Disable menu icons.
menu_icons:
  enable: true
</code></pre>
<h2 id="设置标签，分类页面"><a href="#设置标签，分类页面" class="headerlink" title="设置标签，分类页面"></a>设置标签，分类页面</h2><p>在Git-Bash中输入：</p>
<pre><code class="lang-yaml">hexo new page &quot;tags&quot;
hexo new page &quot;categories&quot;
hexo new page &quot;about&quot;
</code></pre>
<p><img src="https://wx4.sinaimg.cn/mw690/0083TyOJly1gblv5ezol4j30c401kjrb.jpg" alt="img4"></p>
<p>这时在<code>Hexo/source/</code>下出现一个<code>tags/index.md</code>和<code>categories/index.md</code></p>
<p>这时你修改<code>index.md</code>的属性，新加<code>type</code>属性</p>
<p><code>tags的index</code></p>
<pre><code class="lang-yaml">---
title: 标签
data: 2019-08-10 00:11:16
type: &quot;tags&quot;
comments: false
---
</code></pre>
<p><code>categories的index</code></p>
<pre><code class="lang-yaml">---
title: 分类
date: 2019-08-10 00:08:44
type: &quot;categories&quot;
comments: false
---
</code></pre>
<p><code>about的index</code></p>
<pre><code class="lang-yaml">---
title: 这是我的自我介绍
layout: about
comments: false
---
</code></pre>
<p><code>comments: false</code>是关闭评论功能</p>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>在Hexo的根目录下执行</p>
<pre><code class="lang-yaml">npm install hexo-generator-searchdb --save
</code></pre>
<p>站点配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml">search: # 本地搜索插件
  path: search.xml
  field: post
  format: html
  limit: 10000
</code></pre>
<p>在主题配置文件<code>_config.yml</code>中</p>
<pre><code class="lang-yaml">local_search:
  enable: true
  # if auto, trigger search by changing input
  # if manual, trigger search by pressing enter key or search button
  trigger: auto
  # show top n results per article, show all results by setting to -1
  top_n_per_article: 1
</code></pre>
<h2 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h2><p>把你要作为头像的图片放到：<code>Hexo/themes/next/source/images</code></p>
<p>然后更改主题配置文件<code>_config.yml</code>中的 <code>Sidebar Avaatar</code></p>
<pre><code class="lang-yaml">avatar: /images/header.jpg
</code></pre>
<h2 id="网站缩略图图标"><a href="#网站缩略图图标" class="headerlink" title="网站缩略图图标"></a>网站缩略图图标</h2><p>把你要作为缩略图的图片放到：<code>Hexo/themes/next/source/images</code></p>
<p>然后打开主题配置文件<code>_config.yml</code>,找到 <code>favicon</code>，修改成这样</p>
<pre><code class="lang-yaml">favicon:
  small: /images/header.jpg
  medium: /images/header.jpg
  apple_touch_icon: /images/header.jpg
  safari_pinned_tab: /images/logo.svg
  #android_manifest: /images/manifest.json
  #ms_browserconfig: /images/browserconfig.xml
</code></pre>
<h2 id="修改链接文本样式"><a href="#修改链接文本样式" class="headerlink" title="修改链接文本样式"></a>修改链接文本样式</h2><p>打开<code>Hexo/themes/next/source/css/_common/components/post.styl</code>，添加</p>
<pre><code class="lang-stylus">.post-body p a {
  color: #0593d3;
  border-bottom: none;
  border-bottom: 1px solid #0593d3;
  &amp;:hover {
    color: #fc6423;
    border-bottom: none;
    border-bottom: 1px solid #fc6423;
  }
}
</code></pre>
<h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><p>注册登录<a href="https://www.livere.com/" target="_blank" rel="noopener">来必力</a>, 安装City，获得安装代码中的<code>data-uid=&quot;xxx&quot;</code></p>
<p>配置主题配置文件<code>_config.yml</code>,添加<code>LiveRe Uid</code>:</p>
<pre><code class="lang-yaml">livere_uid: #你的LiveRe UID
</code></pre>
<h2 id="添加访问计数"><a href="#添加访问计数" class="headerlink" title="添加访问计数"></a>添加访问计数</h2><p>next已经集成了busuanzi计数，编辑<code>Hexo/themes/next/layout/_third-party/analytics/busuanzi-counter.swig</code> </p>
<p>将</p>
<p><code>&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p>
<p>改为</p>
<p><code>&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p>
<p>主题配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml"># Show PV/UV of the website/page with busuanzi.
# Get more information on http://ibruce.info/2015/04/04/busuanzi/
busuanzi_count:
  # count values only if the other configs are false
  enable: true
  # custom uv span for the whole site
  site_uv: true
  total_visitors: true
  total_visitors_icon: user
  total_view: true
  total_views_icon: eye
  post_views: false
  post_view_icon: eye
  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访客数
  site_uv_footer: 人
  # custom pv span for the whole site
  site_pv: true
  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量
  site_pv_footer: 次
  # custom pv span for one page only
  page_pv: true
  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;  阅读数
  page_pv_footer: 次
</code></pre>
<h2 id="文章版权信息"><a href="#文章版权信息" class="headerlink" title="文章版权信息"></a>文章版权信息</h2><p>编辑主题配置文件<code>_config.yml</code>，修改</p>
<pre><code class="lang-yaml">post_copyright:
  enable: true
</code></pre>
<h2 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h2><p>编辑主题配置文件<code>_config.yml</code>,修改</p>
<pre><code class="lang-yaml"># Reward
reward_comment: 求打赏文本
wechatpay: /images/wechatpay.png  # 微信收款二维码 图片路径
alipay: /images/alipay.png        # 支付宝收款二维码 图片路径
#bitcoin: /images/bitcoin.png     # 比特币
</code></pre>
<h2 id="添加更新时间"><a href="#添加更新时间" class="headerlink" title="添加更新时间"></a>添加更新时间</h2><p>编辑主题配置文件<code>_config.yml</code>,修改</p>
<pre><code class="lang-yaml">post_meta:
  item_text: true
  created_at: true   # 创建时间
  updated_at: true   # 更新时间
  # Only show &#39;updated&#39; if different from &#39;created&#39;.
  updated_diff: false # 只使用更新时间
  # If true, post&#39;s time format will be hexo config&#39;s date_format + &#39; &#39; + time_format.
  date_time_merge: false
  categories: true
</code></pre>
<h2 id="修改文章底部的标签"><a href="#修改文章底部的标签" class="headerlink" title="修改文章底部的标签"></a>修改文章底部的标签</h2><p>编辑<code>Hexo/themes/next/layout/_macro/post.swig</code></p>
<p>找到<code>rel=&quot;tag&quot;&gt;#</code></p>
<p>将<code>#</code>改为<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h2 id="文章底部添加”本文结束”"><a href="#文章底部添加”本文结束”" class="headerlink" title="文章底部添加”本文结束”"></a>文章底部添加”本文结束”</h2><p>编辑<code>Hexo/themes/next/laayout/_macro/post.swig</code>，在文章结束的地方加上</p>
<pre><code class="lang-python">{% if not is_index %}
    <div style="text-align:center;color: #ccc;font-size:14px;">
        ---------Thanks for your attention---------
    </div>
{% endif %}
</code></pre>
<h2 id="在页脚添加运行时间"><a href="#在页脚添加运行时间" class="headerlink" title="在页脚添加运行时间"></a>在页脚添加运行时间</h2><p>编辑<code>themes/next/layout/_partials/footer.swig</code></p>
<p>在所示位置加上代码：</p>
<p><img src="https://wx3.sinaimg.cn/mw690/0083TyOJly1gblv5hgdmij30so0j0diq.jpg" alt="img5"></p>
<pre><code class="lang-python">
&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;
&lt;script language=javascript&gt;
    function siteTime(){
        window.setTimeout(&quot;siteTime()&quot;, 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth()+1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2018,02,13,15,00,00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
        var diff = t2-t1;
        var diffYears = Math.floor(diff/years);
        var diffDays = Math.floor((diff/days)-diffYears*365);
        var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
        var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
        var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
        document.getElementById(&quot;sitetime&quot;).innerHTML=&quot; 已运行&quot;+diffYears+&quot; 年 &quot;+diffDays+&quot; 天 &quot;+diffHours+&quot; 小时 &quot;+diffMinutes+&quot; 分钟 &quot;+diffSeconds+&quot; 秒&quot;;
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
&lt;/script&gt;
</code></pre>
<h2 id="Latex公式"><a href="#Latex公式" class="headerlink" title="Latex公式"></a>Latex公式</h2><p>更换Hexo的Markdown渲染引擎</p>
<pre><code class="lang-c">npm uninstall hexo-renderer-marked --save
npm install hexo-renderer-kramed --save
</code></pre>
<p>然后打开<code>node_modules/kramed/lib/rules/inline.js</code></p>
<p>替换11行的escape变量</p>
<pre><code class="lang-c">//  escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/,
  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/
</code></pre>
<p>改变20行的em变量</p>
<pre><code class="lang-c">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/
</code></pre>
<p>next集成了Mathjax，编辑主题配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml"># MathJax Support
mathjax:
  enable: true
  per_page: true
  engine: mathjax
  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML

# Han Support docs: https://hanzi.pro/
han: false
</code></pre>
<p>在写文章时要在文章的配置中加上<code>mathjax: true</code></p>
<h2 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h2><p>在根目录执行</p>
<p><code>npm install hexo-abbrlink --save</code></p>
<p>配置站点配置文件<code>_config.yml</code>,修改</p>
<pre><code class="lang-yaml"># abbrlink config
abbrlink:
  alg: crc16 #support crc16(default) and crc32
  rep: hex    #support dec(default) and hex

# 更改 permalink 值
permalink: /:abbrlink/
</code></pre>
<h2 id="文章封面图片"><a href="#文章封面图片" class="headerlink" title="文章封面图片"></a>文章封面图片</h2><p>在根目录执行</p>
<p><code>npm install --save hexo-less</code></p>
<p>在写文章时手动设置文章摘要<code>&lt;!-- less --&gt;</code>为分界线</p>
<h2 id="social"><a href="#social" class="headerlink" title="social"></a>social</h2><p>修改主题配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml">social:
  #GitHub: https://github.com/yourname || github
  #Google: https://plus.google.com/yourname || google
  #Twitter: https://twitter.com/yourname || twitter
  #E-Mail: mailto:yourname@gmail.com || envelope
  #FB Page: https://www.facebook.com/yourname || facebook
  #VK Group: https://vk.com/yourname || vk
  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow
  #YouTube: https://youtube.com/yourname || youtube
  #Instagram: https://instagram.com/yourname || instagram
  #Skype: skype:yourname?call|chat || skype

social_icons:
  enable: true
  GitHub: github
  Twitter: twitter
  微博: weibo
</code></pre>
<h2 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h2><p>修改主题配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml"># Blog rolls
links_icon: link
links_title: Friend Links
links_layout: block
#links_layout: inline
links:
  github: http://github.com/
</code></pre>
<h2 id="字数统计和阅读时长"><a href="#字数统计和阅读时长" class="headerlink" title="字数统计和阅读时长"></a>字数统计和阅读时长</h2><p>在根目录执行</p>
<p><code>npm install hexo-symbols-count-time --save</code></p>
<p>修改站点配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml">symbols_count_time:
 #文章内是否显示
  symbols: true
  time: true
 # 网页底部是否显示
  total_symbols: true
  total_time: true
</code></pre>
<p>修改主题配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml"># Post wordcount display settings
# Dependencies: https://github.com/theme-next/hexo-symbols-count-time
symbols_count_time:
  separated_meta: true
  #文章中的显示是否显示文字（本文字数|阅读时长） 
  item_text_post: true
  #网页底部的显示是否显示文字（站点总字数|站点阅读时长） 
  item_text_total: false
  # Average Word Length (chars count in word)
  awl: 4
  # Words Per Minute
  wpm: 275
</code></pre>
<h2 id="隐藏网页底部信息"><a href="#隐藏网页底部信息" class="headerlink" title="隐藏网页底部信息"></a>隐藏网页底部信息</h2><p>修改主题配置文件<code>_config.yml</code></p>
<pre><code class="lang-yaml">footer:
  # Specify the date when the site was setup.
  # If not defined, current year will be used.
  #since: 2015

  # Icon between year and copyright info.
  icon: user
  counter: true

  # If not defined, will be used `author` from Hexo main config.
  copyright:
  # -------------------------------------------------------------
  # Hexo link (Powered by Hexo).
  powered: false

  theme:
    # Theme &amp; scheme info link (Theme - NexT.scheme).
    enable: false
    # Version info of NexT after scheme info (vX.X.X).
    version: false
  # -------------------------------------------------------------
  # Any custom text can be defined here.
  #custom_text: Hosted by &lt;a target=&quot;_blank&quot; href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;

# ---------------------------------------------------------------
# SEO Settings
# ---------------------------------------------------------------

# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.
# See: https://support.google.com/webmasters/answer/139066
# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )
canonical: true

# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.
seo: false

# If true, will add site-subtitle to index page, added in main hexo config.
# subtitle: Subtitle
index_with_subtitle: false
</code></pre>
<h2 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h2><p>在根目录执行</p>
<p><code>npm install hexo-generator-feed --save</code></p>
<p>修改站点配置文件<code>_config.yml</code>,在<code>Extensions</code>下添加</p>
<pre><code class="lang-yaml"># RSS订阅
feed:
  type: atom
  path: atom.xml
  limit: 20
  hub:
  content:
  content_limit: 140
  content_limit_delim: &#39; &#39;
</code></pre>
<p>修改主题配置文件 <code>_config.yml</code>修改<code>rss</code>为</p>
<p><code>rss: /atom.xml</code></p>
<h2 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h2><p>在GItHub上<a href="https://github.com/crozynski/comicneue" target="_blank" rel="noopener">下载</a>后，解压后将所有Web文件夹下的所有内容放入<code>Hexo/theme/next/source/fonts</code></p>
<p>然后修改<code>Hexo/themes/next/source/css/_custom/custom.styl</code></p>
<pre><code class="lang-stylus">//字体
@font-face {
  font-family: &#39;Comic Neue&#39;;
  src: url(&#39;/fonts/ComicNeue-Light.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Light.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Light.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Light.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Light.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 300;
}

@font-face {
  font-family: &#39;Comic Neue&#39;;
  src: url(&#39;/fonts/ComicNeue-Light-Oblique.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Light-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Light-Oblique.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Light-Oblique.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Light-Oblique.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 300;
  font-style: oblique;
}

@font-face {
  font-family: &#39;Comic Neue&#39;;
  src: url(&#39;/fonts/ComicNeue-Regular.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Regular.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Regular.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Regular.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Regular.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 400;
}

@font-face {
  font-family: &#39;Comic Neue&#39;;
  src: url(&#39;/fonts/ComicNeue-Regular-Oblique.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Regular-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Regular-Oblique.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Regular-Oblique.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Regular-Oblique.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 400;
  font-style: oblique;
}

@font-face {
  font-family: &#39;Comic Neue&#39;;
  src: url(&#39;/fonts/ComicNeue-Bold.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Bold.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Bold.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Bold.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Bold.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 700;
}

@font-face {
  font-family: &#39;Comic Neue&#39;;
  src: url(&#39;/fonts/ComicNeue-Bold-Oblique.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Bold-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Bold-Oblique.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Bold-Oblique.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Bold-Oblique.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 700;
  font-style: oblique;
}

@font-face {
  font-family: &#39;Comic Neue Angular&#39;;
  src: url(&#39;/fonts/ComicNeue-Angular-Light.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Angular-Light.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Light.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Light.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Light.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 300;
}

@font-face {
  font-family: &#39;Comic Neue Angular&#39;;
  src: url(&#39;/fonts/ComicNeue-Angular-Light-Oblique.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Angular-Light-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Light-Oblique.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Light-Oblique.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Light-Oblique.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 300;
  font-style: oblique;
}

@font-face {
  font-family: &#39;Comic Neue Angular&#39;;
  src: url(&#39;/fonts/ComicNeue-Angular-Regular.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Angular-Regular.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Regular.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Regular.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Regular.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 400;
}

@font-face {
  font-family: &#39;Comic Neue Angular&#39;;
  src: url(&#39;/fonts/ComicNeue-Angular-Regular-Oblique.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Angular-Regular-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Regular-Oblique.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Regular-Oblique.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Regular-Oblique.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 400;
  font-style: oblique;
}

@font-face {
  font-family: &#39;Comic Neue Angular&#39;;
  src: url(&#39;/fonts/ComicNeue-Angular-Bold.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Angular-Bold.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Bold.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Bold.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Bold.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 700;
}

@font-face {
  font-family: &#39;Comic Neue Angular&#39;;
  src: url(&#39;/fonts/ComicNeue-Angular-Bold-Oblique.eot&#39;);
  src: url(&#39;/fonts/ComicNeue-Angular-Bold-Oblique.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Bold-Oblique.woff2&#39;) format(&#39;woff2&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Bold-Oblique.woff&#39;) format(&#39;woff&#39;),
       url(&#39;/fonts/ComicNeue-Angular-Bold-Oblique.ttf&#39;)  format(&#39;truetype&#39;);
  font-weight: 700;
  font-style: oblique;
}
</code></pre>
<p>修改主题配置文件 <code>_config.yml</code>修改<code>font</code>为</p>
<pre><code class="lang-yaml">font:
  enable: true

  # Uri of fonts host. E.g. //fonts.googleapis.com (Default).
  host:

  # Font options:
  # `external: true` will load this font family from `host` above.
  # `family: Times New Roman`. Without any quotes.
  # `size: xx`. Use `px` as unit.

  # Global font settings used on &lt;body&gt; element.
  global:
    external: true
    family: &#39;Comic Neue&#39;
    size:

  # Font settings for Headlines (h1, h2, h3, h4, h5, h6).
  # Fallback to `global` font settings.
  headings:
    external: true
    family: &#39;Comic Neue&#39;
    size:

  # Font settings for posts.
  # Fallback to `global` font settings.
  posts:
    external: true
    family: &#39;Comic Neue&#39;

  # Font settings for Logo.
  # Fallback to `global` font settings.
  logo:
    external: true
    family: &#39;Comic Neue&#39;
    size:

  # Font settings for &lt;code&gt; and code blocks.
  codes:
    external: true
    family: &#39;Comic Neue&#39;
    size:
</code></pre>
<p>刚开始的字体是默认14px，在代码部分会很小，所以可以在<code>themes/next/source/css/_variables/base.styl</code></p>
<p>修改 font size和code font  为18px就很好</p>
<h2 id="设置新建文件配置"><a href="#设置新建文件配置" class="headerlink" title="设置新建文件配置"></a>设置新建文件配置</h2><p>进入<code>Hexo/scaffolds</code>修改<code>post.md</code></p>
<pre><code class="lang-yaml">---
title: {{ title }}
date: {{ date }}
mathjax: true
categories:
tags:
---
</code></pre>
<h2 id="新建带日期的博文"><a href="#新建带日期的博文" class="headerlink" title="新建带日期的博文"></a>新建带日期的博文</h2><p>修改站点配置文件<code>-config.yml</code></p>
<pre><code class="lang-yaml"># Writing
new_post_name: :year-:month-:day-:title.md # File name of new posts
default_layout: post
titlecase: false # Transform title into titlecase
external_link: true # Open external links in new tab
filename_case: 0
render_drafts: false
post_asset_folder: true # 同时生成一个文件夹
relative_link: false
future: true
highlight: # Hexo自带代码高亮插件
  enable: true
  line_number: true
  auto_detect: false
  tab_replace:
</code></pre>
<h2 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h2><p>把背景图片存放到<code>Hexo/themes/next/source/images</code></p>
<p>再在<code>Hexo/themes/next/source/css/_custom/custom/styl</code>修改一下</p>
<pre><code class="lang-stylus">body { background:url(/images/music.png);}
</code></pre>
<p>参考博客：</p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p>
<p><a href="https://www.cnblogs.com/liziczh/p/9318656.html" target="_blank" rel="noopener">https://www.cnblogs.com/liziczh/p/9318656.html</a></p>
<p><a href="https://xian6ge.netlify.com/posts/82ce1911/" target="_blank" rel="noopener">https://xian6ge.netlify.com/posts/82ce1911/</a></p>
<p><a href="https://www.jianshu.com/p/805bd0b65d98https://www.jianshu.com/p/805bd0b65d98" target="_blank" rel="noopener">https://www.jianshu.com/p/805bd0b65d98https://www.jianshu.com/p/805bd0b65d98</a></p>
<p><a href="https://www.jianshu.com/p/3a01cc514ce7?utm_source=oschina-app" target="_blank" rel="noopener">https://www.jianshu.com/p/3a01cc514ce7?utm_source=oschina-app</a></p>
<p><a href="https://leflacon.github.io/7167e0bc/" target="_blank" rel="noopener">https://leflacon.github.io/7167e0bc/</a></p>]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
