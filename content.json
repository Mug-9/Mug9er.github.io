{"meta":{"title":"PlusHl' blog","subtitle":"Stay Hungry, Stay Foolish","description":"Let life be beautiful like summer flowers and death like autumn leaves.","author":"PlusHl","url":"http://orzff.cn","root":"/"},"pages":[{"title":"","date":"2019-08-09T13:16:06.019Z","updated":"2019-08-09T13:16:06.019Z","comments":true,"path":"404/index.html","permalink":"http://orzff.cn/404/index.html","excerpt":"","text":"title:”[404]”date:2019-08-09 21:11:29layout:404 description:”May the Force be with you :&#41;"},{"title":"这是我的自我介绍","date":"2019-08-11T07:55:56.975Z","updated":"2019-08-11T07:55:56.975Z","comments":false,"path":"about/index.html","permalink":"http://orzff.cn/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-08-09T16:08:44.000Z","updated":"2019-08-10T14:32:34.082Z","comments":false,"path":"categories/index.html","permalink":"http://orzff.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-09T16:11:16.000Z","updated":"2019-08-10T14:32:49.810Z","comments":false,"path":"tags/index.html","permalink":"http://orzff.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"牛客第二场","slug":"牛客第二场","date":"2019-08-11T12:51:17.000Z","updated":"2019-08-11T15:19:48.059Z","comments":true,"path":"b17f/","link":"","permalink":"http://orzff.cn/b17f/","excerpt":"","text":"A:Eddy Walker题意给你一个n的点的环，一开始从0号点开始，每次可以前进1或者后退1，问第一次站在m号点的时候已经遍历完所有点的概率，求出前缀概率积 思路一： 暴力打表找规律 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;double p[10];bool vis[10];int n;bool Check() &#123; for (int i = 0; i &lt; n; i ++) if(!vis[i]) return false; return true; &#125;void dfs(int idx, double px) &#123; if(px &lt; 1e-10) return ; vis[idx] = 1; if(!Check()) &#123; int nxt = (idx+1)%n; int tmp = vis[nxt]; vis[nxt] = 1; dfs(nxt, px*0.5); vis[nxt] = tmp; nxt = (idx-1+n)%n; tmp = vis[nxt]; vis[nxt] = 1; dfs(nxt, px*0.5); vis[nxt] = tmp; &#125;else p[idx] += px;&#125;int main() &#123; for (n = 1; n &lt;= 7; n ++) &#123; printf(\"n: %d\\n\", n); memset(p, 0, sizeof(p)); memset(vis, 0, sizeof(vis)); dfs(0, 1); for (int i = 0; i &lt; n; i ++) &#123; printf(\"i: %d, p: %lf\\n\", i, p[i]); &#125; &#125; return 0;&#125; 这是打表的结果，可以发现结果与m无关(当m&gt;0时)而且近似为$\\frac{1}{n-1}$ 二：数学分析:因为是最后站在一个非0的位置上，而每个非零的点的最后一次到达的概率是相同的，所以是$\\frac{1}{n-1}$ B:Eddy Walker2题意现在是给你一条链，从0点出发，一个最多走k步，每一步的概率都是$\\frac{1}{k}$ ,问最后走到n的概率 思路根据题意可以写出一个递推式子： $dp[i] = \\frac{1}{k}\\sum\\limits_{i=1}^{k}dp[n-i]$ 如果n很小的话，可以直接用dp来写，但是n的大小是$1e^{9}$，所以我们就得用BM直接套板子线性递推 但是有一个问题，就是n可能为无穷，我们可以这样来写， 我们每次行动的移动记录期望是$\\frac{1}{k}\\sum\\limits_{i=1}^{k}i=\\frac{(k+1)k}{2k}=\\frac{k+1}{2}$ ,也就是每行动一次大概移动$\\frac{k+1}{2}$ ，而我们移动到n的次数可能为m次，那么移动的距离期望就是$\\frac{(k+1)m}{2}$ 而n在其中，在这$\\frac{(k+1)m}{2}$个点中，我们一共会走m个点，那么就是n在这m个点之间的概率$\\frac{1}{m}$ , 期望就是$m$ ,而在整体的概率就是$\\frac{m}{\\frac{(k+1)m}{2}}=\\frac{2}{k+1}$ $dp[i]=\\begin{cases} \\frac{1}{k}\\cdot (dp[i-1]+dp[i-2]+…+dp[i-k]),i&gt;=k\\ \\frac{2}{k+1},i=\\infty \\\\\\end{cases}$ AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod = 1e9 + 7;#define sz(x) ((int)(x).size())typedef vector&lt;ll&gt; VI; ll Ksm(ll a, ll b) &#123; ll res = 1; a %= mod; assert(b &gt;= 0); while(b) &#123; if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125; int _, n;namespace Linear_Seq&#123; const int N = 10010; ll res[N], base[N], _c[N], _md[N]; vector&lt;int&gt; Md; void Mul(ll *a, ll *b, int k) &#123; for (int i = 0; i &lt; k+k; i ++) _c[i] = 0; for (int i = 0; i &lt; k; i ++) if(a[i]) for (int j = 0; j &lt; k; j ++) _c[i+j] = (_c[i+j] + a[i]*b[j]) % mod; for (int i = k + k - 1; i &gt;= k; i --) if(_c[i]) for (int j = 0; j &lt; sz(Md); j ++) _c[i-k+Md[j]] = (_c[i-k+Md[j]] - _c[i] * _md[Md[j]]) % mod; for (int i = 0; i &lt; k; i ++) a[i] = _c[i]; &#125; int solve(ll n, VI a, VI b) &#123; ll ans = 0, pnt = 0; int k = sz(a); assert(sz(a) == sz(b)); for (int i = 0; i &lt; k; i ++) _md[k-1-i] = -a[i]; _md[k] = 1; Md.clear(); for (int i = 0; i &lt; k; i ++) if(_md[i]) Md.push_back(i); for (int i = 0; i &lt; k; i ++) res[i] = base[i] = 0; res[0] = 1; while((1ll&lt;&lt;pnt) &lt;= n) pnt ++; for (int p = pnt; p &gt;= 0; p --) &#123; Mul(res, res, k); if((n&gt;&gt;p) &amp; 1) &#123; for (int i = k-1; i &gt;= 0; i --) res[i+1] = res[i]; res[0] = 0; for (int j = 0; j &lt; sz(Md); j ++) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; &#125; &#125; for (int i = 0; i &lt; k; i ++) ans = (ans + res[i] * b[i]) % mod; if(ans &lt; 0) ans += mod; return ans; &#125; VI BM(VI s) &#123; VI C(1, 1), B(1, 1); int L = 0, m = 1, b = 1; for (int n = 0; n &lt; sz(s); n ++) &#123; ll d = 0; for (int i = 0; i &lt; L + 1; i ++) d = (d + (ll)C[i] * s[n-i]) % mod; if (d == 0) ++m; else if(2 * L &lt;= n) &#123; VI T = C; ll c = mod - d * Ksm(b, mod-2) % mod; while(sz(C) &lt; sz(B) + m) C.push_back(0); for (int i = 0; i &lt; sz(B); i ++) C[i+m] = (C[i+m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m = 1; &#125;else &#123; ll c = mod - d * Ksm(b, mod-2) % mod; while(sz(C) &lt; sz(B) + m) C.push_back(0); for (int i = 0; i &lt; sz(B); i ++) C[i+m] = (C[i+m] + c * B[i]) % mod; ++ m; &#125; &#125; return C; &#125; int Gao(VI a, ll n) &#123; VI c = BM(a); c.erase(c.begin()); for (int i = 0; i &lt; sz(c); i ++) c[i] = (mod-c[i]) % mod; return solve(n, c, VI(a.begin(), a.begin()+sz(c))); &#125;&#125;;using namespace Linear_Seq; void solve() &#123; ll n, k; scanf(\"%lld %lld\", &amp;k, &amp;n); if(n == 0) &#123; printf(\"1\\n\"); return ; &#125;else if(n == -1) &#123; printf(\"%lld\\n\", 2 * Ksm(k+1, mod-2) % mod); return ; &#125; VI dp(3*k, 0), v; dp[0] = 1; v.push_back(1); for (int i = 1; i &lt;= k; i ++) &#123; for (int j = 0; j &lt; i; j ++) dp[i] = (dp[i] + dp[j]) % mod; dp[i] = dp[i] * Ksm(k, mod-2) % mod; v.push_back(dp[i]); &#125; for (int i = k+1; i &lt;= 2 * k; i ++) &#123; for (int j = 1; j &lt;= k; j ++) dp[i] = (dp[i] + dp[i-j]) % mod; dp[i] = dp[i] * Ksm(k, mod-2) % mod; v.push_back(dp[i]); &#125; printf(\"%lld\\n\", Gao(v, n));&#125; int main() &#123; int T; scanf(\"%d\", &amp;T); while(T --) solve(); return 0;&#125; E:MAZE题意给你一个NxM的地图，0表示可走，1表示不可走， 有$Q$次询问，可能会对某一位置取反，可能问你从$(1,a)$到$(n,b)$有多少走法 思路因为题目 要求不能往回走，所以如果我们从下面开始走，那么我们在横向移动是就不能改变方向，然后向上走 我们先用$dp$来考虑一下做法：设$dp[i][j]$是经由下面$dp[i-1][j]$走过来的走法数，那么从左边或右边走过来的方法数呢，我们可以在最后在加一层，那么$dp[0][j]$就加上了第1层左右到达$dp[1][j]$的方法数 那么$dp[i][j] = sum(dp[i-1][j]+dp[i-1][j-1] + … dp[i-1][j-k])+sum(dp[i-1][j+1]+dp[i-1][j+2]+…+dp[i-1][j+k])$ $dp[i][j]$由$i-1$层，$i$的左边第一个1和$i$的右边第一个1，这么一段区间里的$dp$值转移过来 比如这样一个2X6的地图, $dp[1][3]=dp[2][2]+dp[2][3]+dp[2][4]+d[2][5]$ $dp[1][4]=dp[2][2]+dp[2][3]+dp[2][4]+d[2][5]$ 由于上一层的每个值都是有下面的值组成，那么我们就可以构造出一个矩阵 这样我们就能从第$i$层转移到第$i-1$层了 现在来考虑地图修改的情况 这n个矩阵我们可以用一个线段树来维护，地图修改时用线段树来修改矩阵就行了 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long const int maxn = 5e4 + 5;const int mod = 1e9+7;char c[maxn][15];int dp[maxn][15]; int N, M, Q; struct Maze &#123; int maze[15][15]; Maze() &#123;memset(maze, 0, sizeof(maze));&#125; void init() &#123;for (int i = 0; i &lt; 15; i ++) maze[i][i] = 1;&#125; Maze friend operator * (Maze a, Maze b) &#123; Maze c; for (int i = 0; i &lt; M; i ++) for (int j = 0; j &lt; M; j ++) for (int k = 0; k &lt; M; k ++) c.maze[i][j] = (c.maze[i][j] + 1ll * a.maze[i][k] * b.maze[k][j]) % mod; return c; &#125; &#125;; struct Seg&#123; Maze w[maxn&lt;&lt;2]; void Build(int rt, int l, int r) &#123; if(l == r) &#123; for (int i = 0; i &lt; M; i ++) &#123; if(c[l][i] == '0') &#123; for (int j = i; j &gt;= 0; j --) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; for (int j = i; j &lt; M; j ++) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; &#125; &#125; return ; &#125; int m = (l + r) &gt;&gt; 1; Build(rt*2, l, m); Build(rt*2+1, m+1, r); w[rt] = w[rt*2] * w[rt*2+1]; &#125; void Updata(int rt, int l, int r, int pos) &#123; if(l == r) &#123; for (int i = 0; i &lt; M; i ++) for (int j = 0; j &lt; M; j ++) w[rt].maze[i][j] = 0; for (int i = 0; i &lt; M; i ++) &#123; if(c[l][i] == '0') &#123; for (int j = i; j &gt;= 0; j --) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; for (int j = i; j &lt; M; j ++) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; &#125; &#125; return ; &#125; int m = (l + r) &gt;&gt; 1; if(pos &lt;= m) Updata(rt*2, l, m, pos); else Updata(rt*2+1, m+1, r, pos); w[rt] = w[rt*2] * w[rt*2+1]; &#125; void Updata(int pos) &#123; Updata(1, 1, N, pos); &#125; &#125;seg; int main() &#123; scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;Q); for (int i = 0; i &lt; N; i ++) scanf(\"%s\", c[i]); for (int i = 0; i &lt; M; i ++) c[N][i] = '0'; seg.Build(1, 1, N); //seg.Print(1, 1, N); while(Q --) &#123; int op, a, b; scanf(\"%d %d %d\", &amp;op, &amp;a, &amp;b); if(op == 1) &#123; if(c[a-1][b-1] == '0') c[a-1][b-1] = '1'; else c[a-1][b-1] = '0'; if(a &gt; 1) seg.Updata(a-1); seg.Updata(a); &#125; else &#123; Maze ans = seg.w[1]; Maze t1; t1.maze[0][a-1] = 1; t1 = t1 * ans; printf(\"%d\\n\", t1.maze[0][b-1]); &#125; &#125; return 0; &#125; F:Partition problen题意给你2N个人，每对人如果不在同一队的话，有一个竞争值，你要把这些人分为人数相等的两个队，使得竞争值最大 思路直接暴力 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041//队友代码：#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long const int maxn = 1e5 + 5;vector&lt;int&gt; a, b;int c[30][30];int n;ll ans = 0;void dfs(int idx, ll cur) &#123; if(idx == 2 * n + 1) &#123; ans = max(ans, cur); return ; &#125; ll sum = 0; if(a.size() &lt; n) &#123; a.push_back(idx); sum = 0; for (int &amp;v: b) sum += c[idx][v]; dfs(idx+1, cur+sum); a.pop_back(); &#125; if(b.size() &lt; n) &#123; b.push_back(idx); sum = 0; for (int &amp;v: a) sum += c[idx][v]; dfs(idx + 1, cur + sum); b.pop_back(); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= 2*n; i ++) for (int j = 1; j &lt;= 2*n; j ++) scanf(\"%d\", &amp;c[i][j]); dfs(1, 0); printf(\"%lld\\n\", ans); return 0;&#125; H:Second Large Rectangle题意给你一个NXM的矩阵，只有01组成，求第二大的全为1的子矩阵 思路单调栈求最大子矩阵，在过程中就也求出了第二大的子矩阵，然后第一大的宽减一，高减一，和第二大的比较输出最大的 单调栈求最大子矩阵的方法： 逐层遍历，对于每一层求出一个h[]，h表示以此层为底1的高度 比如： 这样一个矩阵,h为： 这样对于每一层就变成一个求最大矩阵的形式， 对于每一层用单调栈求出最大矩阵，注意要记得去重，像上图中的第二层，第二列，第三列，第四列求出的是同一个矩阵，不去重的话无法跟第二大的比较，去重很简单，就记录一下，左边界和上边界即可， AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long const int maxn = 1e3+5;const int inf = 0x3f3f3f3f;typedef pair&lt;int, int&gt; pis;struct Pis&#123; int res, x, h; bool friend operator &lt; (Pis a, Pis b) &#123; return a.res &gt; b.res; &#125; &#125;;char c[maxn][maxn];int maz[maxn][maxn], h[maxn];int pre[maxn], suf[maxn];stack&lt;pis&gt; sta;int n, m;map&lt;pis, int&gt; mp;vector&lt;Pis&gt; ans;void getPS() &#123; while(!sta.empty()) sta.pop(); sta.push(pis&#123;-inf, 0&#125;); for (int j = 1; j &lt;= m; j ++) &#123; while(h[j] &lt;= sta.top().first) sta.pop(); pre[j] = sta.top().second+1; sta.push(pis&#123;h[j], j&#125;); &#125; while(!sta.empty()) sta.pop(); sta.push(pis&#123;-inf, m+1&#125;); for (int j = m; j &gt;= 1; j --) &#123; while(h[j] &lt;= sta.top().first) sta.pop(); suf[j] = sta.top().second-1; sta.push(pis&#123;h[j], j&#125;); &#125;&#125;void getH(int i) &#123; for (int j = 1; j &lt;= m; j ++) if(maz[i][j]) h[j] += 1; else h[j] = 0;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) scanf(\"%s\", c[i]+1); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) maz[i][j] = c[i][j] - '0'; for (int i = 1; i &lt;= n; i ++) &#123; getH(i); getPS(); mp.clear(); for (int i = 1; i &lt;= m; i ++) &#123; if(!mp[pis&#123;pre[i], h[i]&#125;]) &#123; mp[pis&#123;pre[i], h[i]&#125;] = 1; int sum = (suf[i]-pre[i]+1) * h[i]; ans.push_back(Pis&#123;sum, pre[i], h[i]&#125;); &#125; &#125; &#125; sort(ans.begin(), ans.end()); if(ans.size() &lt;= 1) printf(\"0\\n\"); else &#123; int tx = ans[0].res/ans[0].h, ty = ans[0].h; printf(\"%d\\n\", max(ans[1].res, max(tx*(ty-1), (tx-1)*ty))); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/categories/题解/"}],"tags":[{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/多校/"}]},{"title":"牛客第一场","slug":"牛客第一场","date":"2019-08-11T12:50:58.000Z","updated":"2019-08-11T15:25:11.425Z","comments":true,"path":"2105/","link":"","permalink":"http://orzff.cn/2105/","excerpt":"","text":"A. Equivalent Prefixes题意两个序列相等的条件是RMQ(u,l,r) = RMQ(u,l,r)，($1\\leq l \\leq r\\leq m$) ,RMQ(u,l,r)代表序列u，的任意区间(l,r）的最小值的序号，求一个最大的P，使得$\\lbrace a_1, a_2,…a_p \\rbrace$和$\\lbrace b_1,b_2,…b_p \\rbrace$相等 思路我们假设$last_a[i]= max\\lbrace j|j&lt;i \\&amp;\\&amp; a_j&lt;a_i\\rbrace$ ,也就是$a_i$左边序号最大的小于$a_i$的数字的位置， 我们用单调栈去求这个last，求得以后 那么我们求序列[1,r]的RMQ，就是找到last[r],last[last[r]],last[last[last[r]],的值 如果两个序列的last数组相同，那么就证明$RMQ(a,l,r)=RMQ(b,l,r)$ AC代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 1e5 + 7;const int inf = 0x3f3f3f3f;const int mod = 1e9 + 7;typedef pair&lt;int, int&gt; pis;int a[maxn], b[maxn];int lasta[maxn], lastb[maxn];stack&lt;pis&gt; sta;int main() &#123; int n; while(~scanf(\"%d\", &amp;n)) &#123; for (int i = 1; i &lt;= n; i ++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n; i ++) scanf(\"%d\", &amp;b[i]); while(!sta.empty()) sta.pop(); sta.push(pis&#123;0, 0&#125;); for (int i = 1; i &lt;= n; i ++) &#123; while(sta.top().first &gt; a[i]) sta.pop(); lasta[i] = sta.top().second; sta.push((pis&#123;a[i], i&#125;)); &#125; while(!sta.empty()) sta.pop(); sta.push(pis&#123;0, 0&#125;); for (int i = 1; i &lt;= n; i ++) &#123; while(sta.top().first &gt; b[i]) sta.pop(); lastb[i] = sta.top().second; sta.push((pis&#123;b[i], i&#125;)); &#125; int cnt = 0; for (int i = 1; i &lt;= n; i ++) &#123; if(lasta[i] == lastb[i]) cnt ++; else break; &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; B.Integration题意已知$\\int_0^{\\infty}\\frac{1}{1+x^2}dx=\\frac{\\pi}{2}$ 求：$\\frac{1}{\\pi}\\int_0^{\\infty}\\frac{1}{\\prod\\limits_{i=1}^{n}(a_i^2+x^2)}dx$ 思路我们先算$\\frac{1}{\\prod\\limits_{i=1}^{n}(a_i^2+x^2)}$$=\\frac{1}{a_1^2+x^2} \\frac{1}{a_2^2+x^2}\\frac{1}{\\prod\\limits_{i=3}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{a_1^2+x^2}-\\frac{1}{a_2^2+x^2})\\frac{1}{\\prod\\limits_{i=3}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{a_1^2+x^2}-\\frac{1}{a_2^2+x^2})\\frac{1}{a_3^2+x^2}\\frac{1}{\\prod\\limits_{i=4}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{a_1^2+x^2}\\frac{1}{a_3^2+x^2}-\\frac{1}{a_2^2+x^2}\\frac{1}{a_3^2+x^2})\\frac{1}{\\prod\\limits_{i=4}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{(a_1^2-a_3^2)}(\\frac{1}{a_3^2+x^2}-\\frac{1}{a_1^2+x^2})-\\frac{1}{(a_3^2-a_2^2)}(\\frac{1}{a_2^2+x^2}-\\frac{1}{a_3^2+x^2}))\\frac{1}{\\prod\\limits_{i=4}^{n}a_i^2+x^2}\\\\=(\\frac{1}{a_2^2-a_1^2}\\frac{1}{a_3^2-a_1^2})\\frac{1}{a_1^2+x^2}+(\\frac{1}{a_1^2-a_2^2}\\frac{1}{a_3^2-a_2^2})\\frac{1}{a_2^2+x^2}+(\\frac{1}{a_1^2-a_3^2}\\frac{1}{a_2^2-a_3^2})\\frac{1}{a_3^2+x^2}\\\\=…\\\\=\\sum\\limits_{i=1}^{n}\\frac{1}{\\prod\\limits_{j=1,j!=i}^{n}(a_j^2-a_i^2)}\\frac{1}{a_i^2+x^2}$我们设$c_i=\\prod\\limits_{j=1,j!=i}^{n}(a_j^2-a_i^2)$$原式=\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\frac{1}{a_i^2+x^2}$那么$\\frac{1}{\\pi}\\int_0^{\\infty}\\frac{1}{\\prod\\limits_{i=1}^{n}(a_i^2+x^2)}dx\\\\=\\frac{1}{\\pi}\\int_0^{\\infty}\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\frac{1}{a_i^2+x^2}\\\\=\\frac{1}{\\pi}\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\int_0^{\\infty}\\frac{1}{a_i^2+x^2}\\\\=\\frac{1}{\\pi}\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\frac{\\pi}{2a_i}\\\\=\\sum\\limits_{i=1}^{n}\\frac{1}{2c_ia_i}$ AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 1e5 + 7;const int inf = 0x3f3f3f3f;const int mod = 1e9 + 7;typedef pair&lt;int, int&gt; pis;ll a[maxn], b[maxn];int n;ll ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if(!b) &#123; x = 1; y = 0; return a; &#125; ll d = ex_gcd(b, a % b, x, y); ll t = x; x = y; y = t - a / b * y; return d;&#125;ll getInv(ll a, ll p) &#123; ll x, y; ex_gcd(a, p, x, y); x = ((x % p) + p) % p; return x;&#125;ll solve(ll x, int idx) &#123; ll res = x; for (int i = 1; i &lt;= n; i ++) &#123; if(i == idx) continue; res *= (b[i] - b[idx] + mod) % mod; res %= mod; &#125; return getInv(res, mod);&#125;int main() &#123; while(~scanf(\"%d\", &amp;n)) &#123; for (int i = 1; i &lt;= n; i ++) &#123; scanf(\"%lld\", &amp;a[i]); b[i] = a[i] * a[i] % mod; &#125; ll ans = 0; for (int i = 1; i &lt;= n; i ++) ans = (ans + solve(a[i], i)) % mod; printf(\"%lld\\n\", ans * getInv(2, mod) % mod); &#125; return 0;&#125; C:Euclidean Distance题意给你一些点$(\\frac{a_1}{m},\\frac{a_2}{m},…,\\frac{a_n}{m})$,让你找一些$p_i$,使得$\\sum\\limits_{i=1}^{n}(p_i-a_i)^2$最小,$p_i$满足$\\sum\\limits_{i=1}^{n}p_i=1,p_i&gt;=0$ 思路听说题解是用拉格朗日乘子法，但我也不会，我看到有别人用的是贪心因为所有的$a_i$都是除以m的，所以我们把$a_i$和$p_i$都乘以m，那么我们就变成了用m步使得面积最小（负数的面积不能变小只能变大） 那么贪心的做法就是把大的尽量的变小，因为是排过序的，所以前面的要比后面的大。每次都试着把前i-1块变得跟第i块平齐，如果不能就把前(i-1)块全部减小$\\frac{k}{i-1}$,保持前面的平齐 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 5e5 + 5;const int inf = 0x3f3f3f3f;const int mod = 1e9 + 7;ll a[maxn];bool cmp(ll a, ll b) &#123; return a &gt; b;&#125;ll gcd(ll a, ll b) &#123; return !b ? a : gcd(b, a % b);&#125;int main() &#123; ll n, m; while(~scanf(\"%lld %lld\", &amp;n, &amp;m)) &#123; for (int i = 1; i &lt;= n; i ++) scanf(\"%lld\", &amp;a[i]); sort(a + 1, a + n + 1, cmp); ll k = m; for (int i = 2; i &lt;= n; i ++) &#123; if(k &gt; (a[i-1] - a[i]) * (i-1)) &#123; k -= 1ll * (a[i-1] - a[i]) * (i-1); &#125;else &#123; for (int j = 1; j &lt;= i-1; j ++) a[j] = 1ll* (i-1) * a[i-1] - k; for (int j = i; j &lt;= n; j ++) a[j] = 1ll * a[j] * (i-1); m = 1ll * m * (i-1); k = 0; break; &#125; &#125; if(k) &#123; for (int i = 1; i &lt;= n; i ++) a[i] = 1ll * (a[n] * n) - k; m = 1ll * m * n; &#125; ll ans = 0; for (int i = 1; i &lt;= n; i ++) ans = (ans + 1ll * a[i] * a[i]); m = 1ll * m * m; ll k1 = gcd(ans, m); ans /= k1; m /= k1; if(m == 1) printf(\"%lld\\n\", ans); else printf(\"%lld/%lld\\n\", ans, m); &#125; return 0;&#125; E:ABBA题意给你n个AB和m个BA，问你能构造出多少个长度为(n+m)*2并且能组成n个AB和B个BA的串 思路如果我们把A看做-1，B看成1，那么构成串的前缀和应该在[-n,m]，如果不在就是不合法的串然后我们在用dp[i][j]来表示构成串的前i+j位中有i个A,j个B，那么我们考虑dp[i][j]—&gt;(dp[i+1][j],dp[i][j+1])转移是只需要判断(dp[i+1][j],dp[i][j+1])是否合法即可 AC代码123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std; #define ll long longconst int maxn = 2e3 + 5;const int inf = 0x3f3f3f3f;const int mod = 1e9 + 7; ll dp[maxn][maxn]; int main() &#123; int n, m; while(scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; for (int i = 0; i &lt;= n + m; i ++) for (int j = 0; j &lt;= n + m; j ++) dp[i][j] = 0; dp[0][0] = 1; for (int i = 0; i &lt;= n+m; i ++) &#123; for (int j = max(0, i-n); j &lt;= min(n+m, i+m); j ++) &#123; if(i) dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod; if(j) dp[i][j] = (dp[i][j] + dp[i][j-1]) % mod; &#125; &#125; printf(\"%lld\\n\", dp[n+m][n+m]); &#125; return 0;&#125; H:XOR题意给你一堆数，让你找他们子集xor和位0的的子集的大小之和 思路明显的线性集问题,首先我们要知道一堆数字组成线性集， 可以范围线性集外的数字和线性集内的数字，线性集内的数字可以xor出线性集外的所有子集 因为是问子集大小的和，所以我们可以转化成求每个数字的贡献 分为两种：我们设数字总数为$n$,线性集大小为$r$ 1.线性集外数字的贡献： 因为线性集内的数字能把线性集外的所有子集xor出来。 我们枚举线性集外的每一个数字$x$，那么如果线性集内的数字能把$x$xor出来那么，$x$对应的 线性集外的子集大小就为$2^{n-r-1}$,即这个数字的贡献就为$2^{n-r-1}$ 2.线性集内的数字的贡献： 对剩下的n-1个数字做一次线性集，看是否能把$x$xor出来，能xor出来贡献就为$2^{n-r-1}$，不能就为0 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std; #define ll long longconst int maxn = 1e5 + 7;const int inf = 0x3f3f3f3f;const int mod = 1e9 + 7;typedef pair&lt;int, int&gt; pis; ll a[maxn];bool vis[maxn];vector&lt;int&gt; vec; struct LB&#123; ll b[65], cnt = 0; bool flag; void init() &#123; memset(b, 0, sizeof(b)); flag = false; cnt = 0; &#125; void ins(ll x) &#123; for (int i = 62; i &gt;= 0; i --) if(x &gt;&gt; i) &#123; if(!b[i]) &#123; b[i] = x; cnt ++; return ; &#125; x ^= b[i]; &#125; flag = true; &#125; bool Fin(ll x) &#123; if(x == 0 &amp;&amp; flag) return true; for (int i = 62; i &gt;= 0; i --) &#123; if(x &gt;&gt; i) &#123; x ^= b[i]; &#125; &#125; return x == 0; &#125;&#125;A, B, C; ll Ksm(ll a, ll b) &#123; ll res = 1; while(b) &#123; if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125; int main() &#123; int n; while(~scanf(\"%d\", &amp;n)) &#123; A.init(); B.init(); vec.clear(); for (int i = 1; i &lt;= n; i ++) &#123; scanf(\"%lld\", &amp;a[i]); if(!A.Fin(a[i])) &#123; A.ins(a[i]); vec.push_back(i); &#125;else B.ins(a[i]); &#125; ll r = A.cnt; if(n == r) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; ll base = Ksm(2, n-r-1); ll sum = base * (n-r) % mod; for (auto &amp;it: vec) &#123; ll x = a[it]; for (int i = 0; i &lt;= 62; i ++) C.b[i] = B.b[i]; C.flag = B.flag; for (auto &amp;it2: vec) if(it != it2) C.ins(a[it2]); if(C.Fin(x)) sum = (sum + base) % mod; &#125; printf(\"%lld\\n\", sum); &#125; return 0;&#125; I:Points Division题意给你n个点，把点划分成A,B两部分，规定$i\\in A$ and $j\\in B$ and $x_j \\leq x_i$ and $y_i\\leq y_j$ 求最后$\\sum\\limits_{i\\in A}a_i+\\sum\\limits_{j\\in B}b_j$ 的最大值 思路我们发现$A$位于左上角，$B$位于右上角，$AB$边界时一条不下降的折线,所以我们可以沿着这条折线进行$dp$， 我们规定折线上的点全是$B$上的点。 首先我们先把纵坐标离散化，然后用$dp[i]$来表示当高度为i时最大值为多少 然后我们来求每一个点对结果的贡献， 对于一个点$i$,有两种情况: ​ 一：这个点不在折线上，那么大于$y_i$并且在折线上面的点$j$，$i$相当于位于$B$，那么$i$对于$j$的贡献就是$b_i$,对于那些小于$y_i$并且在折线上面的点$k$，$i$相当于位于$A$，那么$i$对$k$的贡献就是$a_i$, ​ 二：这个点在折线上，$dp[i]$就由从$1到i-1$的点的最大值+$b_i$ 也就是$dp[i] = \\max\\limits_{1\\leq j &lt; i} dp[j] + b_i$ 大体思路就是这样，因为我们要对区间操作，所以要用一个线段树来维护一下 注意因为我们默认折线上的点全是属于$B$的点，这就导致不会有$A=P$ and $B=\\emptyset$的情况，但是我们在点中加入一个$(0,0)$的点，因为$1\\leq x_i, y_i\\leq 10^9$那么所有的点都位于$(0,0)$上面，对$(0,0)$的贡献就是$B=\\emptyset$的值 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 1e5 + 5;struct Node&#123; ll x, y, a, b; bool friend operator &lt; (Node a, Node b) &#123; if(a.x == b.x) return a.y &gt; b.y; return a.x &lt; b.x; &#125;&#125;node[maxn];ll ty[maxn];struct Seg&#123; ll dp[maxn&lt;&lt;2], lazy[maxn&lt;&lt;2]; void Build(int rt, int l, int r) &#123; if (l == r) &#123; dp[rt] = 0; lazy[rt] = 0; return ; &#125; lazy[rt] = 0; dp[rt] = 0; int m = (l + r) &gt;&gt; 1; Build(rt&lt;&lt;1, l, m); Build(rt&lt;&lt;1|1, m+1, r); &#125; void down(int rt) &#123; lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; dp[rt&lt;&lt;1] += lazy[rt]; dp[rt&lt;&lt;1|1] += lazy[rt]; lazy[rt] = 0; &#125; void Updata(int rt, int l, int r, int L, int R, ll v) &#123; //区间更新 if(l &gt;= L &amp;&amp; r &lt;= R) &#123; dp[rt] += v; lazy[rt] += v; return ; &#125; if(lazy[rt]) down(rt); int m = (l + r) &gt;&gt; 1; if(L &lt;= m) Updata(rt&lt;&lt;1, l, m, L, R, v); if(R &gt; m) Updata(rt&lt;&lt;1|1, m+1, r, L, R, v); dp[rt] = max(dp[rt&lt;&lt;1], dp[rt&lt;&lt;1|1]); &#125; void Updata(int rt, int l, int r, int w, ll v) &#123; //单点更新 if(l == r) &#123; dp[rt] = max(dp[rt], v); return ; &#125; if(lazy[rt]) down(rt); int m = (l + r) &gt;&gt; 1; if(w &lt;= m) Updata(rt&lt;&lt;1, l, m, w, v); else Updata(rt&lt;&lt;1|1, m+1, r, w, v); dp[rt] = max(dp[rt&lt;&lt;1], dp[rt&lt;&lt;1|1]); &#125; ll Query(int rt, int l, int r, int L, int R) &#123; if(l &gt;= L &amp;&amp; r &lt;= R) return dp[rt]; ll Max = 0; int m = (l + r) &gt;&gt; 1; if(L &lt;= m) Max = max(Max, Query(rt&lt;&lt;1, l, m, L, R)); if(R &gt; m) Max = max(Max, Query(rt&lt;&lt;1|1, m+1, r, L, R)); return Max; &#125;&#125;seg;int main() &#123; int n; while(~scanf(\"%d\", &amp;n)) &#123; int cnt = 0; ty[cnt++] = 0; node[0] = Node&#123;0, 0, 0, 0&#125;; for (int i = 1; i &lt;= n; i ++) &#123; scanf(\"%lld %lld %lld %lld\", &amp;node[i].x, &amp;node[i].y, &amp;node[i].a, &amp;node[i].b); ty[cnt++] = node[i].y; &#125; sort(ty, ty + cnt); cnt = unique(ty, ty+cnt) - ty; for (int i = 0; i &lt;= n; i ++) node[i].y = lower_bound(ty, ty + cnt, node[i].y) - ty + 1; sort(node, node + 1 + n); seg.Build(1, 1, cnt); for (int i = 0; i &lt;= n; i ++) &#123; if(node[i].y &lt; cnt) seg.Updata(1, 1, cnt, node[i].y+1, cnt, node[i].b); //[node.y+1~cnt]+a seg.Updata(1, 1, cnt, node[i].y, seg.Query(1, 1, cnt, 1, node[i].y)+node[i].b);//dp[i] = max if(node[i].y &gt; 1) seg.Updata(1, 1, cnt, 1, node[i].y-1, node[i].a);//[1~node.y] + b &#125; printf(\"%lld\\n\", seg.dp[1]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/categories/题解/"}],"tags":[{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/多校/"}]},{"title":"My First Blog","slug":"2019-08-11-My-First-Blog","date":"2019-08-11T06:57:09.000Z","updated":"2019-08-11T12:37:55.517Z","comments":true,"path":"81cc/","link":"","permalink":"http://orzff.cn/81cc/","excerpt":"这是我的第一篇博客，主要写一些Hexo的配置","text":"一. Hexo + Github 搭建博客：跟着这篇博客走即可 二：Hexo 主题配置Hexo目录下的_config.yml称为站点配置文件 Hexo/themes/next/目录下的_config.yml称为主题配置文件 1. next主题下载next主题 1git clone https://github.com/theme-next/hexo-theme-next themes / next 在站点配置文件 _config.yml 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 在主题配置文件_config.yml中可以选择四种scheme，我选择的是Gemini 123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 2. 基本信息配置配置站点配置文件_config.yml 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 3. 菜单信息配置：配置主题配置文件_config.yml 12345678910111213menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true 4. 设置标签，分类页面在Git-Bash中输入： 123hexo new page \"tags\"hexo new page \"categories\"hexo new page \"about\" 这时在Hexo/source/下出现一个tags/index.md和categories/index.md 这时你修改index.md的属性，新加type属性 tags的index 123456---title: 标签data: 2019-08-10 00:11:16type: \"tags\"comments: false--- categories的index 123456---title: 分类date: 2019-08-10 00:08:44type: \"categories\"comments: false--- about的index 12345---title: 这是我的自我介绍layout: aboutcomments: false--- comments: false是关闭评论功能 5. 搜索功能在Hexo的根目录下执行 1npm install hexo-generator-searchdb --save 站点配置文件_config.yml 12345search: # 本地搜索插件 path: search.xml field: post format: html limit: 10000 在主题配置文件_config.yml中 1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 6. 头像设置把你要作为头像的图片放到：Hexo/themes/next/source/images 然后更改主题配置文件_config.yml中的 Sidebar Avaatar 1avatar: /images/header.jpg 7. 网站缩略图图标把你要作为缩略图的图片放到：Hexo/themes/next/source/images 然后打开主题配置文件_config.yml,找到 favicon，修改成这样 1234567favicon: small: /images/header.jpg medium: /images/header.jpg apple_touch_icon: /images/header.jpg safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 8. 修改链接文本样式打开Hexo/themes/next/source/css/_common/components/post.styl，添加 12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 9. 添加评论系统注册登录来必力, 安装City，获得安装代码中的data-uid=&quot;xxx&quot; 配置主题配置文件_config.yml,添加LiveRe Uid: 1livere_uid: #你的LiveRe UID 10. 添加访问计数next已经集成了busuanzi计数，编辑Hexo/themes/next/layout/_third-party/analytics/busuanzi-counter.swig 将 &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 改为 &lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 主题配置文件_config.yml 1234567891011121314151617181920212223# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true total_visitors: true total_visitors_icon: user total_view: true total_views_icon: eye post_views: false post_view_icon: eye site_uv_header: &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; 访客数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=\"fa fa-file-o\"&gt;&lt;/i&gt; 阅读数 page_pv_footer: 次 11. 文章版权信息编辑主题配置文件_config.yml，修改 12post_copyright: enable: true 12. 打赏编辑主题配置文件_config.yml,修改 12345# Rewardreward_comment: 求打赏文本wechatpay: /images/wechatpay.png # 微信收款二维码 图片路径alipay: /images/alipay.png # 支付宝收款二维码 图片路径#bitcoin: /images/bitcoin.png # 比特币 13. 添加更新时间编辑主题配置文件_config.yml,修改 123456789post_meta: item_text: true created_at: true # 创建时间 updated_at: true # 更新时间 # Only show 'updated' if different from 'created'. updated_diff: false # 只使用更新时间 # If true, post's time format will be hexo config's date_format + ' ' + time_format. date_time_merge: false categories: true 14. 修改文章底部的标签编辑Hexo/themes/next/layout/_macro/post.swig 找到rel=&quot;tag&quot;&gt;# 将#改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 15. 文章底部添加”本文结束”编辑Hexo/themes/next/laayout/_macro/post.swig，在文章结束的地方加上 12345&#123;% if not is_index %&#125; &lt;div style=\"text-align:center;color: #ccc;font-size:14px;\"&gt; ---------Thanks for your attention--------- &lt;/div&gt;&#123;% endif %&#125; 16. 在页脚添加运行时间编辑themes/next/layout/_partials/footer.swig 在所示位置加上代码： 12345678910111213141516171819202122232425262728293031323334353637&#123;### 运行时间 ####&#125;&lt;span id=\"sitetime\"&gt;&lt;/span&gt;&lt;script language=javascript&gt; function siteTime()&#123; window.setTimeout(\"siteTime()\", 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) year - 作为date对象的年份，为4位年份值 month - 0-11之间的整数，做为date对象的月份 day - 1-31之间的整数，做为date对象的天数 hours - 0(午夜24点)-23之间的整数，做为date对象的小时数 minutes - 0-59之间的整数，做为date对象的分钟数 seconds - 0-59之间的整数，做为date对象的秒数 microseconds - 0-999之间的整数，做为date对象的毫秒数 */ var t1 = Date.UTC(2018,02,13,15,00,00); //北京时间2018-2-13 00:00:00 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(\"sitetime\").innerHTML=\" 已运行\"+diffYears+\" 年 \"+diffDays+\" 天 \"+diffHours+\" 小时 \"+diffMinutes+\" 分钟 \"+diffSeconds+\" 秒\"; &#125;/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/ siteTime();&lt;/script&gt; 17. Latex公式next集成了Mathjax，编辑主题配置文件_config.yml 123456789# MathJax Supportmathjax: enable: true per_page: true engine: mathjax cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML# Han Support docs: https://hanzi.pro/han: false 在写文章时要在文章的配置中加上mathjax: true 18. 短链接在根目录执行 npm install hexo-abbrlink --save 配置站点配置文件_config.yml,修改 1234567# abbrlink configabbrlink: alg: crc16 #support crc16(default) and crc32 rep: hex #support dec(default) and hex# 更改 permalink 值permalink: p/:abbrlink.html 19. 文章封面图片在根目录执行 npm install --save hexo-less 在写文章时手动设置文章摘要&lt;!-- less --&gt;为分界线 20. social修改主题配置文件_config.yml 12345678910111213141516social: #GitHub: https://github.com/yourname || github #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true GitHub: github Twitter: twitter 微博: weibo 21. 友链修改主题配置文件_config.yml 1234567# Blog rollslinks_icon: linklinks_title: Friend Linkslinks_layout: block#links_layout: inlinelinks: github: http://github.com/ 22. 字数统计和阅读时长在根目录执行 npm install hexo-symbols-count-time --save 修改站点配置文件_config.yml 1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 修改主题配置文件_config.yml 123456789101112# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true #文章中的显示是否显示文字（本文字数|阅读时长） item_text_post: true #网页底部的显示是否显示文字（站点总字数|站点阅读时长） item_text_total: false # Average Word Length (chars count in word) awl: 4 # Words Per Minute wpm: 275 23. 隐藏网页底部信息修改主题配置文件_config.yml 123456789101112131415161718192021222324252627282930313233343536373839footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: user counter: true # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target=\"_blank\" href=\"https://pages.github.com\"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false 24. 设置RSS在根目录执行 npm install hexo-generator-feed --save 修改站点配置文件_config.yml,在Extensions下添加 123456789# RSS订阅feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' 修改主题配置文件 _config.yml修改rss为 rss: /atom.xml 25. 修改字体在GItHub上下载后，解压后将所有Web文件夹下的所有内容放入Hexo/theme/next/source/fonts 然后修改Hexo/themes/next/source/css/_custom/custom.styl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//字体@font-face &#123; font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Light.eot'); src: url('/fonts/ComicNeue-Light.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Light.woff2') format('woff2'), url('/fonts/ComicNeue-Light.woff') format('woff'), url('/fonts/ComicNeue-Light.ttf') format('truetype'); font-weight: 300;&#125;@font-face &#123; font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Light-Oblique.eot'); src: url('/fonts/ComicNeue-Light-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Light-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Light-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Light-Oblique.ttf') format('truetype'); font-weight: 300; font-style: oblique;&#125;@font-face &#123; font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Regular.eot'); src: url('/fonts/ComicNeue-Regular.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Regular.woff2') format('woff2'), url('/fonts/ComicNeue-Regular.woff') format('woff'), url('/fonts/ComicNeue-Regular.ttf') format('truetype'); font-weight: 400;&#125;@font-face &#123; font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Regular-Oblique.eot'); src: url('/fonts/ComicNeue-Regular-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Regular-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Regular-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Regular-Oblique.ttf') format('truetype'); font-weight: 400; font-style: oblique;&#125;@font-face &#123; font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Bold.eot'); src: url('/fonts/ComicNeue-Bold.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Bold.woff2') format('woff2'), url('/fonts/ComicNeue-Bold.woff') format('woff'), url('/fonts/ComicNeue-Bold.ttf') format('truetype'); font-weight: 700;&#125;@font-face &#123; font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Bold-Oblique.eot'); src: url('/fonts/ComicNeue-Bold-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Bold-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Bold-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Bold-Oblique.ttf') format('truetype'); font-weight: 700; font-style: oblique;&#125;@font-face &#123; font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Light.eot'); src: url('/fonts/ComicNeue-Angular-Light.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Light.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Light.woff') format('woff'), url('/fonts/ComicNeue-Angular-Light.ttf') format('truetype'); font-weight: 300;&#125;@font-face &#123; font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Light-Oblique.eot'); src: url('/fonts/ComicNeue-Angular-Light-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Light-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Light-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Angular-Light-Oblique.ttf') format('truetype'); font-weight: 300; font-style: oblique;&#125;@font-face &#123; font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Regular.eot'); src: url('/fonts/ComicNeue-Angular-Regular.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Regular.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Regular.woff') format('woff'), url('/fonts/ComicNeue-Angular-Regular.ttf') format('truetype'); font-weight: 400;&#125;@font-face &#123; font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Regular-Oblique.eot'); src: url('/fonts/ComicNeue-Angular-Regular-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Regular-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Regular-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Angular-Regular-Oblique.ttf') format('truetype'); font-weight: 400; font-style: oblique;&#125;@font-face &#123; font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Bold.eot'); src: url('/fonts/ComicNeue-Angular-Bold.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Bold.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Bold.woff') format('woff'), url('/fonts/ComicNeue-Angular-Bold.ttf') format('truetype'); font-weight: 700;&#125;@font-face &#123; font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Bold-Oblique.eot'); src: url('/fonts/ComicNeue-Angular-Bold-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Bold-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Bold-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Angular-Bold-Oblique.ttf') format('truetype'); font-weight: 700; font-style: oblique;&#125; 修改主题配置文件 _config.yml修改font为 123456789101112131415161718192021222324252627282930313233343536373839404142font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: 'Comic Neue' size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: 'Comic Neue' size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: 'Comic Neue' # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: 'Comic Neue' size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: 'Comic Neue' size: 26. 设置新建文件配置进入Hexo/scaffolds修改post.md 1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;mathjax: truecategories:tags:--- 27. 新建带日期的博文修改站点配置文件-config.yml 123456789101112131415# Writingnew_post_name: :year-:month-:day-:title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: true # 同时生成一个文件夹relative_link: falsefuture: truehighlight: # Hexo自带代码高亮插件 enable: true line_number: true auto_detect: false tab_replace: 28. 背景图片把背景图片存放到Hexo/themes/next/source/images 再在Hexo/themes/next/source/css/_custom/custom/styl修改一下 1body &#123; background:url(/images/music.png);&#125; 参考博客： https://www.jianshu.com/p/3a05351a37dc https://www.cnblogs.com/liziczh/p/9318656.html https://xian6ge.netlify.com/posts/82ce1911/ https://www.jianshu.com/p/805bd0b65d98https://www.jianshu.com/p/805bd0b65d98 https://www.jianshu.com/p/3a01cc514ce7?utm_source=oschina-app https://leflacon.github.io/7167e0bc/","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://orzff.cn/categories/杂谈/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://orzff.cn/tags/Hexo/"}]}]}