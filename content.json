{"meta":{"title":"Mug-9's blog","subtitle":"Stay Hungry, Stay Foolish","description":null,"author":"Mug-9","url":"http://orzff.cn","root":"/"},"pages":[{"title":"404","date":"2019-08-09T13:11:29.000Z","updated":"2021-05-31T11:58:00.938Z","comments":true,"path":"404/index.html","permalink":"http://orzff.cn/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-08-09T16:08:44.000Z","updated":"2021-05-31T11:58:01.224Z","comments":false,"path":"about/index.html","permalink":"http://orzff.cn/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2021-06-02T12:27:17.000Z","updated":"2021-06-15T13:42:58.534Z","comments":true,"path":"archives/index.html","permalink":"http://orzff.cn/archives/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-05-30T09:42:17.000Z","updated":"2021-05-31T11:58:01.242Z","comments":true,"path":"contact/index.html","permalink":"http://orzff.cn/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-09T16:08:44.000Z","updated":"2021-05-31T11:58:01.242Z","comments":false,"path":"categories/index.html","permalink":"http://orzff.cn/categories/index.html","excerpt":"","text":""},{"title":"LeetCode","date":"2019-08-09T16:08:44.000Z","updated":"2021-06-15T13:42:58.534Z","comments":true,"path":"leetcode/index.html","permalink":"http://orzff.cn/leetcode/index.html","excerpt":"","text":""},{"title":"画廊","date":"2021-05-30T15:07:43.000Z","updated":"2021-05-31T11:58:01.243Z","comments":true,"path":"galleries/index.html","permalink":"http://orzff.cn/galleries/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-05-30T09:46:53.000Z","updated":"2021-05-31T13:47:32.212Z","comments":false,"path":"friends/index.html","permalink":"http://orzff.cn/friends/index.html","excerpt":"","text":""},{"title":"tag","date":"2019-08-09T16:11:16.000Z","updated":"2021-05-31T11:58:01.244Z","comments":false,"path":"tags/index.html","permalink":"http://orzff.cn/tags/index.html","excerpt":"","text":""},{"title":"封面图","date":"2021-05-30T15:18:45.000Z","updated":"2021-05-31T11:58:01.243Z","comments":true,"path":"galleries/封面图/index.html","permalink":"http://orzff.cn/galleries/%E5%B0%81%E9%9D%A2%E5%9B%BE/index.html","excerpt":"","text":""},{"title":"个人训练","date":"2019-11-10T14:56:13.000Z","updated":"2020-12-04T13:38:22.365Z","comments":false,"path":"practice/index.html","permalink":"http://orzff.cn/practice/index.html","excerpt":"","text":"格式：$\\bullet$ ✓ : 赛时通过 $\\bullet$ ✗ ：赛时未通过 $\\bullet$ ★ : 赛后通过 $\\bullet$ ✧ : 未提交 比赛记录： a{text-decoration:none} a:hover{text-decoration:none} ​ 比赛通过日期 ABC DEF GHI JKL MN Educational Codeforces Round 67 (Div. 2)2/609/12/2019 ✓✓★ ✧✧✧ Codeforces Round #574 (Div. 2)5/607/12/2019 ✓✓✓ ✓✧✧ Codeforces Round #604 (Div. 2)5/606/12/2019 ✓✓✓ ✓✓✧ Codeforces Round #573 (Div. 2)3/605/12/2019 ✓✓✓ ★✧✧ Educational Codeforces Round 68 (Div. 2)3/604/12/2019 ✓✓✓ ★✧✧ Codeforces Round #574 (Div. 2)3/603/12/2019 ✓✓✓ ★✧✧ Codeforces Round #576 (Div. 2)3/602/12/2019 ✓✓✓ ★✧✧ Codeforces Round #603 (Div. 2)4/628/11/2019 ✓✓✓ ✓ ✧✧ Codeforces Round #577 (Div. 2)3/628/11/2019 ✓✓✓ ✧ ✧✧ Educational Codeforces Round 77 (Div. 2)3/627/11/2019 ✓✓✓ ★ ✧✧ Educational Codeforces Round 70 (Div.2)2/626/11/2019 ✓✓✧ ★ ✧✧ Codeforces Round #578 (Div. 2)3/625/11/2019 ✓✓✓ ★ ✧✧ Codeforces Round #602 (Div. 2)3/824/11/2019 ✓✓✧ ✓✗✧ ✧✧ 2013-2014 ACM-ICPC, Asia Aizu Regional Contest2/1023/11/2019 ✓✓✧ ✧✧✧ ✧✧✧ ✧ Codeforces Round #580 (Div. 2)3/622/11/2019 ✓✓✓ ★✧✧ Codeforces Round #581 (Div. 2)4/521/11/2019 ✓✓✓ ✓✧ Educational Codeforces Round 72 (Div. 2)3/620/11/2019 ✓✓✓ ✧✧✧ Codeforces Round 599(Div 2)4/610/11/2019 ✓✓✓ ✓✧✧ Educational Codeforces Round 75(Div 2)2/711/11/2019 ✓✓★ ★✧✧ ✧ Codeforces Round #595(Div 3)3/612/11/2019 ✓✓✓ ★✧✧ Educational Codeforces Round 73 (Div 2)3/713/11/2019 ✓✓✓ ★✧✧ ✧ Educational Codeforces Round 76 (Div. 2)3/714/11/2019 ✓✓✓ ★✧✧ ✧ Codeforces Round #586 (Div. 1 + Div. 2)3/715/11/2019 ✓✓✓ ✗✧✧ ✧ Codeforces Round #600 (Div. 2)3/716/11/2019 ✓★✓ ✧✧✧ ✧ 2019-2020 ICPC, NERC, Southern and Volga Russian Regional Contest (Online Mirror, ICPC Rules, Teams Preferred)6/1417/11/2019 ✓✓✧ ✧✧✓ ✧✓✧ ✓✧✓ ✧✧ Codeforces Round #584 - Dasha Code Championship - Elimination Round (rated, open for everyone, Div. 1 + Div. 2)3/718/11/2019 ✓✓✓ ★✧✧ ✧✧ Codeforces Round #601 (Div. 2)1/619/11/2019 ✓★✧ ✧✧✧"},{"title":"瞎BB","date":"2021-05-31T03:04:09.000Z","updated":"2021-05-31T12:10:29.080Z","comments":false,"path":"artitalk/index.html","permalink":"http://orzff.cn/artitalk/index.html","excerpt":"","text":"new Artitalk({ appId: 'pVqE7D3TEJU4uGHFgVDQYHbj-MdYXbMMI', // Your LeanCloud appId appKey: 'uf5JWphxgdEGy1JaJTPbvdu8' // Your LeanCloud appKey })"}],"posts":[{"title":"吴恩达机器学习2","slug":"吴恩达机器学习2","date":"2021-06-03T13:26:40.000Z","updated":"2021-06-15T13:47:46.509Z","comments":true,"path":"/e0295d92/","link":"","permalink":"http://orzff.cn/e0295d92/","excerpt":"吴恩达机器学习笔记(二)","text":"","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"机器学习/学习笔记","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://orzff.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"525-连续数组","slug":"525-连续数组","date":"2021-06-03T03:25:07.000Z","updated":"2021-06-15T13:42:58.534Z","comments":true,"path":"/f303f9cc/","link":"","permalink":"http://orzff.cn/f303f9cc/","excerpt":"","text":"525. 连续数组跟523类似，只不过将0的数量减去1的数量的值做前缀和，再用哈希表存储下标。 int findMaxLength(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; int dis = 0, ans = 0, pre = 0; m[0] = -1; for (int i = 0; i &lt; nums.size(); ++ i) { pre += nums[i] == 0 ? 1 : -1; if(m.count(pre)) { ans = max(ans, i - m[pre]); }else m[pre] = i; } return ans; }","categories":[],"tags":[]},{"title":"523-连续的字数组和","slug":"523-连续的字数组和","date":"2021-06-02T06:41:03.000Z","updated":"2021-06-15T13:42:58.534Z","comments":true,"path":"/51b0a147/","link":"","permalink":"http://orzff.cn/51b0a147/","excerpt":"","text":"523. 连续的子数组和直接用前缀和和$k$取余来记录前面k的余数的位置，判断是否大于2即可 bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; m; int n = nums.size(); int pre = 0; m[0] = -1; for (int i; i &lt; n; ++i) { int x = nums[i]; pre = (x + pre) % k; if(m.count(pre)) { if(i - m[pre] &gt;= 2) return true; }else m[pre] = i; } return false; }","categories":[],"tags":[]},{"title":"杭电多校第一场","slug":"杭电多校第一场","date":"2021-05-31T11:58:01.201Z","updated":"2021-05-31T11:58:01.201Z","comments":true,"path":"/9d88cf0e/","link":"","permalink":"http://orzff.cn/9d88cf0e/","excerpt":"杭电多校第一场","text":"A: Blank题意有 $n (n \\leq 100)$ 个格子，向其中填入 $0、1、2、3 $这$4$个数，但是有 $m ( m ≤ 100)$ 个限制 限制 $l$ $ r$ $x$ ：表示 $l ~ r$ 的格子内不同的数的个数为$x$ 要求满足所有限制的方案有多少种？ 思路我们首先设$dp[i][j][k][r]$为这$0，1，2，3$四个数字的最后一次出现的位置,$dp$值为方案数 那么转移可以这样写一下: $dp[cur][j][k][r] += dp[i][j][k][r], dp[i][cur][k][r] += dp[i][j][k][r]$ $dp[i][j][cur][r] += dp[i][j][k][r], dp[i][j][k][cur] += dp[i][j][k][r]$ 因为$i,j,k,r$互不相同, 且当位一定为一个数字并且相互之间有大小顺序，那么我们把$dp$按照大小来转移的话 还是$dp[cur][i][j][k]$ 其中$cur \\geq i \\geq j \\geq k$ 那么转移就变成 $dp[cur+1][i][j][k]+=dp[cur][i][j][k], dp[cur+1][cur][j][k] += dp[cur][i][j][k]$ $dp[cur+1][cur][i][k] += dp[cur][i][j][k], dp[cur+1][cur][i][j] += dp[cur][i][j]$ 我们不必要区分$0,1,2,3$对应的是哪一个，因为这对结果没影响 这样的$dp$数组太大，我们可以用滚动数组来优化一下空间 AC代码实测$dp$数组降序会$T$，可能是因为$dp$过程中地址变换太大造成超时. #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e2 + 7; const int inf = 0x3f3f3f3f; const int mod = 998244353; typedef pair&lt;int, int&gt; pis; vector&lt;pis&gt; lo[maxn]; ll dp[maxn][maxn][maxn][2]; //dp[i][j][k][cur] 升序 void add(ll &amp;a, ll b) { a = a + b; if(a &gt; mod) a -= mod; if(a &lt; 0) a += mod; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) { lo[i].clear(); lo[i].push_back(pis{i, 1}); } for (int i = 1; i &lt;= m; i ++) { int l, r, x; scanf(\"%d %d %d\", &amp;l, &amp;r, &amp;x); lo[r].push_back(pis{l, x}); } memset(dp, 0, sizeof(dp)); dp[0][0][0][0] = 1; for (int cur = 1; cur &lt;= n; cur ++) { int np = cur &amp; 1; for (int i = 0; i &lt;= cur; i ++) for (int j = i; j &lt;= cur; j ++) for (int k = j; k &lt;= cur; k ++) dp[i][j][k][np] = 0; for (int i = 0; i &lt;= cur; i ++) for (int j = i; j &lt;= cur; j ++) for (int k = j; k &lt;= cur; k ++) { /*add(dp[i][k][cur-1][np], dp[i][j][k][np^1]); 地址跨越比add(dp[np][cur-1][k][i], dp[np^1][k][j][i]); 要大，可能是造成超时的原因 */ add(dp[j][k][cur-1][np], dp[i][j][k][np^1]); add(dp[i][k][cur-1][np], dp[i][j][k][np^1]); add(dp[i][j][cur-1][np], dp[i][j][k][np^1]); add(dp[i][j][k][np], dp[i][j][k][np^1]); } for (int i = 0; i &lt;= cur; i ++) for (int j = i; j &lt;= cur; j ++) for (int k = j; k &lt;= cur; k ++) for (pis it: lo[cur]) { int l = it.first, r = cur, x = it.second; int cnt = (i &gt;= l) + (j &gt;= l) + (k &gt;= l) + 1; if(cnt != x) dp[i][j][k][np] = 0; } } ll ans = 0; for (int i = 0; i &lt;= n; i ++) for (int j = i; j &lt;= n; j ++) for (int k = j; k &lt;= n; k ++) add(ans, dp[i][j][k][n&amp;1]); printf(\"%lld\\n\", ans); } return 0; } L: Sequence题意给一个长度为n的数组，有m次操作，操作有3种，给一个x，每次改变序列的值$b_i=\\sum\\limits_{j=i-k*x}a_j$ 求改变完了的序列的$(i\\times a[i])$值的异或和 思路通过打表观察可以发现，一种操作多次操作就是把序列$a$和组合数序列进行卷积，然后就直接用ntt就行了 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 5e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 998244353; typedef pair&lt;int, int&gt; pis; #define g 3 #define Mod(x) ((x)&gt;=mod?(x)-mod:(x)) ll rnk[maxn]; ll a[maxn], b[maxn]; ll Ksm(ll a, ll b) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } ll Fac[1000005], inv[1000005]; void FacPre() { inv[0] = Fac[0] = 1; for (int i = 1; i &lt;= 1000000; i ++) Fac[i] = 1ll * Fac[i-1] * i % mod; inv[1000000] = Ksm(Fac[1000000], mod-2); for (int i = 999999; i &gt;= 1; i --) inv[i] = 1ll * inv[i+1] * (i+1) % mod; } ll C(int n, int m) { if(m &gt; n) return 0; return 1ll * Fac[n] * inv[m] % mod * inv[n-m] % mod; } void ntt(long long *a, int op, int n) { for (int i = 0; i &lt; n; i ++) if(i &lt; rnk[i]) swap(a[i], a[rnk[i]]); for (int i = 2; i &lt;= n; i &lt;&lt;= 1) { int nw = Ksm(g, (mod-1)/i); if(op == -1) nw = Ksm(nw, mod-2); for (int j = 0, m = i &gt;&gt; 1; j &lt; n; j += i) for (int k = 0, w = 1; k &lt; m; k ++) { int t = 1ll * a[j+k+m] * w % mod; a[j+k+m] = Mod(a[j+k]-t+mod); a[j+k] = Mod(a[j+k]+t); w = 1ll * w * nw % mod; } } if(op == -1) for (int i = 0, inv = Ksm(n, mod-2); i &lt; n; i ++) a[i] = 1ll * a[i] * inv % mod; } void solve(ll *a, ll *b, int len) { int n = 1, lim = 0; while(n &lt;= len + len) n &lt;&lt;= 1, lim++; for (int i = 0; i &lt; n; i ++) rnk[i] = (rnk[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1) &lt;&lt; (lim-1)); ntt(a, 1, n); ntt(b, 1, n); for (int i = 0; i &lt; n; i ++) a[i] = (1ll * a[i] * b[i]) % mod; ntt(a, -1, n); for (int i = len; i &lt; n; i ++) a[i] = 0; } int cnt[5]; int main() { FacPre(); int t; scanf(\"%d\", &amp;t); while(t --) { memset(cnt, 0, sizeof(cnt)); int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++) scanf(\"%lld\", &amp;a[i]); for (int i = 1, op; i &lt;= m; i ++) { scanf(\"%d\", &amp;op); cnt[op] ++; } for (int i = 1; i &lt;= 3; i ++) { memset(b, 0, sizeof(b)); for (int j = 0; j * i &lt; n; j ++) b[j*i] = C(cnt[i]-1+j, j); if(cnt[i] == 0) b[0] = 1; solve(a, b, n); } ll ans = 0; for (int i = 0; i &lt; n; i ++) ans = ans ^ (1ll * (i+1) * a[i]); printf(\"%lld\\n\", ans); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"合并排序链表+指针指向问题","slug":"合并排序链表+指针指向","date":"2021-05-31T11:58:01.179Z","updated":"2021-05-31T11:58:01.179Z","comments":true,"path":"/f9d7dd15/","link":"","permalink":"http://orzff.cn/f9d7dd15/","excerpt":"合并排序链表+指针指向问题","text":"LeetCode 题目连接：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/题目描述：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例1： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4限制： 0 &lt;= 链表长度 &lt;= 1000 思路：很简单的题，直接定义一个头，然后两个指针相互比较即可。 问题再最初版本出现了问题，最开始的想法很简单，定义一个头pre 用他去遍历两个链表，再用一个ans来记录pre的头部，然后问题出现了，使用pre=pre-&gt;next, pre=l2时，发现ans并不能完全表达pre的值 ListNode *pre = NULL; if(l1-&gt;val &lt;= l2-&gt;val) { pre = l1; l1 = l1-&gt;next; }else { pre = l2; l2 = l2-&gt;next; } ListNode* ans = pre; pre = pre-&gt;next; while(l1 != NULL &amp;&amp; l2 != NULL) { if(l1-&gt;val &lt;= l2-&gt;val) { pre = l1; l1 = l1-&gt;next; }else { pre = l2; l2 = l2-&gt;next; } pre = pre-&gt;next; } 类似如此，ans返回的时第一次的pre值 为什么第一次ans=pre，此时ans与pre指向同一个地址，类似如此 当执行pre=pre-&gt;next时 当这时执行到pre=l2时， 会发现pre指针直接指向l2,而不会带着next指针一起指向l2，这就造成了pre自己走完了一整个链表而ans却一直指向开始的位置。 解决方案指的时候带上next就可以了 ListNode* pre = new ListNode(0); ListNode* cur = pre; while(l1 != NULL &amp;&amp; l2 != NULL) { if(l1-&gt;val &lt;= l2-&gt;val) { cur-&gt;next = l1; l1 = l1-&gt;next; }else { cur-&gt;next = l2; l2 = l2-&gt;next; } cur = cur-&gt;next; } AC代码/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* pre = new ListNode(0); ListNode* cur = pre; while(l1 != NULL &amp;&amp; l2 != NULL) { if(l1-&gt;val &lt;= l2-&gt;val) { cur-&gt;next = l1; l1 = l1-&gt;next; }else { cur-&gt;next = l2; l2 = l2-&gt;next; } cur = cur-&gt;next; } if(l1 != NULL) cur-&gt;next = l1; if(l2 != NULL) cur-&gt;next = l2; return pre-&gt;next; } };","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://orzff.cn/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"Deepin安装NVIDIA以及refind","slug":"Deepin安装NVIDIA以及refind","date":"2021-05-31T11:58:01.074Z","updated":"2021-05-31T11:58:01.074Z","comments":true,"path":"/81fa645f/","link":"","permalink":"http://orzff.cn/81fa645f/","excerpt":"Deepin安装NVIDIA以及refind","text":"Deepin安装NVIDIA驱动安装驱动下载驱动首先根据自己电脑独显的型号去NVIDIA官网选择对应驱动 如果不确定自己电脑显卡型号，可以用sudo lshw -numeric -C display来查看 卸载以前的驱动如果之前在Linux中安装过NVIDIA驱动的话，请将其全部删除 sudo apt autoremove nvidia 禁用nouveaunouveau是通过逆向“Nvidia的Linux驱动”创造的一个开源第三方Nvidia显卡驱动程序，因此其效果差，性能低。在手动安装NVIDIA时需要禁用nouveau驱动。 终端执行以下命令修改文件。 sudo vi /etc/modprobe.d/blacklist.conf 以下内容复制到文件中 blacklist nouveau blacklist lbm-nouveau options nouveau modeset=0 alias nouveau off alias lbm-nouveau off 保存退出。其中，blacklist nouveau是禁用nouveau第三方驱动，之后不需要改回来由于nouveau是构建在内核中的，所以要执行下面命令生效: sudo update-initramfs -u 重启reboot 重启后查看nouveau有没有运行,没输出代表禁用生效 lsmod | grep nouveau 关闭图形界面安装Nvidia驱动程序时，需要停止当前的图形界面。使用快捷键CTRL+ALT+F2进入超级终端，登录账号，并关闭图形界面： sudo service lightdm stop 给驱动文件添加执行权限下载好的nvidia驱动文件是.run，需要添加执行权限。使用cd指令进入下载好的驱动文件路径，如果没有改浏览器的下载路径，路径一般是/home/（你的用户名）/Downloads 。 sudo chmod +x NVIDIA***.run #记得文件名改成自己下载的文件。 驱动安装sudo ./NVIDI**.run #记得文件名改成自己下载的文件。 这个时候会出现一个页面，一系列yes，还有一个界面选择install and cover，意为安装和覆盖。然后等待几分钟。 重启reboot 这样NVIDIA驱动就装好了。 检测NVIDIA驱动是否成功安装使用nvidia-settings命令nvidia-settings 可以看到显卡数据 使用nvidia-smi命令英伟达系统管理接口（NVIDIA System Management Interface, 简称 nvidia-smi）是基于NVIDIA Management Library 的命令行管理组件,旨在帮助管理和监控NVIDIA GPU设备。 nvidia-smi 执行这条命令将会打印出当前系统安装的NVIDIA驱动信息 命令行搜索集显和独显lspci | grep VGA # 查看集成显卡 lspci | grep NVIDIA 查看nouveau是否运行lsmod | grep nouveau 集显与独显切换笔记本外出时使用集显可以节省电量，增长待机时间。可以使用插件：dde-dock-switch_graphics_cardGithub：https://github.com/zty199/dde-dock-switch_graphics_card安装后可以方便地在dock栏切换显卡 使用refind引导win10和deepin安装refind最好在deepin环境下安装refind，因为这样比较简单。 在deepin环境下安装refind有两种方法，使用终端命令行或者下载安装包。 sudo apt-add-repository ppa:rodsmith/refind sudo apt-get update sudo apt-get install refind 安装好refind后重启，你会发现电脑默认引导已经变成了refind，EFI 分区也出现了refind文件夹。但此时的引导界面有两个问题： 1、选项很多，而且界面很丑；2、选择deepin系统后还是会进入grub引导界面，浪费时间。 因此接下来我们需要修改一些东西。 修改设置grub等待时间为0在deepin中，通用&gt;启动&gt;启动延时关闭 下载好看的refind主题首先下载主题压缩包，特别推荐我自己使用的这款极简主题（自带凤凰系统的图标），下载地址： github：https://github.com/EvanPurkhiser/rEFInd-minimal 将解压后的文件放入refind文件夹下的themes文件夹（没有的话可以自行创建）内，可以在deepin环境下使用终端命令操作，也可以切换到win10系统用diskgenius软件进行操作。 修改refind配置文件使用deepin终端修改/EFI/refind/refind.conf文件，需要使用的基本命令如下： su root #获取root权限 vim 你的目录/refind.conf #使用vim修改文件 i #进入修改模式 ESC按键 #退出修改模式 :wq #保存并退出 进入vim编辑模式后，可以看到配置文件有大量的注释，需要修改的命令行其实只有如下几处： timeout 3 resolution 1920 1080 dont_scan_files /EFI/ubuntu/grubx64.efi,/EFI/UOS/fbx64.efi,/EFI/UOS/mmx64.efi,/EFI/UOS/shimx64.efi,/EFI/boot/bootx64.efi,/EFI/boot/grubx64.efi scan_all_linux_kernels false include themes/rEFInd-minimal/theme.conf 这样就可以用refind引导deepin和win10了","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://orzff.cn/tags/Deepin/"},{"name":"NVIDA驱动","slug":"NVIDA驱动","permalink":"http://orzff.cn/tags/NVIDA%E9%A9%B1%E5%8A%A8/"},{"name":"refind","slug":"refind","permalink":"http://orzff.cn/tags/refind/"}]},{"title":"C++学习笔记（三）","slug":"C-学习笔记(三)","date":"2021-05-31T11:58:00.997Z","updated":"2021-05-31T11:58:00.997Z","comments":true,"path":"/a8ec0156/","link":"","permalink":"http://orzff.cn/a8ec0156/","excerpt":"C++学习笔记（三）","text":"C++ 学习笔记(三)静态成员静态成员变量​ 在一个类中，若将一个成员变量声明为static，这种成员成为静态变量，与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝，静态成员变量，属于某个类，所有对象共享。 ​ 静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。 静态成员变量必须在类中声明，在类外定义 静态数据成员 不属于某个对象，在为对象分配空间中不包括静态对象成员所占空间 静态数据成员可以通过类名或者对象名来引用 静态成员变量在类内声明，在类外初始化 静态成员变量也有权限 静态成员函数 静态成员函数不可以访问普通的成员变量，可以访问静态成员变量 静态成员函数也是有权限的 普通成员函数可以访问普通成员变量，也可以访问静态成员变量 面向对象模型初探成员变量和函数的存储数据 和 处理数据的操作是分开存储的 C++中的非静态数据成员直接内含在类对象中，就像C struct一样 成员函数虽然内含在class声明之内，却不出现在对象中 每一个非内联成员函数只会诞生一份函数实例 空类的大小为1,每一个实例的对象，都有独一无二的地址，char维护这个地址 class Person{ public: int m_A; // 非静态成员变量，属于对象身上 void func() {}; //非静态成员函数，不属于对象身上 static int m_B; // 静态成员变量，不属于对象身上 static void func2() {}; //静态成员函数，不属于对象身上 } // 结论： 非静态成员变量，才属于对象身上 this指针this指针称为“永远指向本对象的指针”，this指针并不是对象的一部分,*this是对象本体 this指针是一种隐含指针，它隐含于每个类的非静态成员函数中，静态成员函数不能访问this指针 this指针指向被调用的成员函数所属的对象 Person p1; p1.func(Person*this);// 编译器会偷偷加上一个p1的this指针 空指针访问成员函数空指针可以访问成员函数，但是如果成员函数中用到了this指针，那么就会执行失败 const 修饰成员函数this永远指向本体，类似Person * const this,this的指向不能修改，但指针指向的值可以修改 void showInfo() const { // const加后面代表常函数，意味着不允许修改指针指向的值 this-&gt;m_B = 100; // 如果在常函数中修改，那么就在成员变量前面加mutable } mutable int m_B; 常对象常对象不允许修改属性 const Person p2; 常对象不可以调用普通的成员函数，可以调用常函数 友元友元函数可以访问类的私有成员属性 全局函数做友元全局函数可以作为类的友元函数，在类中声明全局函数，并加上friend关键字 class A{ public: friend void test(); }; void test() { // ... } 类做友元class A{ friend class B; // B作为A的友元类，可以访问A的私有成员属性 } 成员函数做友元class A{ firend void B::test(); // B的成员函数作为A的友元，可以访问A的私有成员属性 } 运算符重载如果想让自定义数据类型进行运算符运算，那么就需要重载运算符。 在成员函数或者在全局函数中，重写一个运算符重载，运算符重载也可以进行重载 对于内置数据类型的表达式运算符是不可以改变的（例如int类型的+号） +号重载class A { // 类内重载 A operator + (A &amp; b) { A tmp; // ... return tmp; } } // 全局重载 A operator + (A &amp;a, A &amp;b) { A tmp; // ... return tmp; } &lt;左移运算符不要随意使用符号重载，cout &lt;&lt;可以对自定义数据类型进行输出 ostream&amp; operator &lt;&lt; (ostream &amp;cout, A &amp;a) { // 第一个参数cout，第一个参数A cout &lt;&lt; \"A: \" &lt;&lt; a &lt;&lt; endl; }//全局重载可以在类中添加friend，访问类的私有成员属性 前置后置递增运算符重载class MyInt{ // 前置++重载 MyInt&amp; operator++(){ this-&gt;num ++; return *this;}// 后置++重载，使用int来区分 MyInt operator++(int) { MyInt tmp = *this; this-&gt;num ++; return tmp;}private: int num;} 指针运算符重载智能指针，用来托管自定义类型对象，让对象进行自动的释放 智能指针就是一个包含对象类型的类，重载-&gt;可以使得智能指针调用类内指针的成员函数以及成员变量 A * operator -&gt; () { // 加上*代表返回指针 return this-&gt;a; } A &amp; operator * () { return *this-&gt;a; } 赋值运算符重载一个类默认创建，默认构造、析构、拷贝构造 、operator=赋值元算符 class Person { // 重载= Person&amp; operator = (const Person&amp; p) { //先判断堆区是否有内容 if (this-&gt;pName != NULL) { delete[] this-&gt;pName; this-&gt;pName = NULL; } this-&gt;pName = new char[strlen(p.pName)+1]; strcpy(this-&gt;pName, p.pName); return *this; } private: char* pName; } []重载class MyArray{ public: // []重载 int&amp; operator[] (int idx) { return *this-&gt;pAddress[idx]; } private: int *pAddress; int m_Size; int m_Capacity; }; 关系运算符重载class Person{ bool operator == (Person &amp;p) { if(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) { return true; } return false; } bool operator != (Person &amp;p) { if(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) { return false; } return true; }public: string name; int age; } 函数调用运算符()重载 class MyPrint{ public: void operator() (string s) { cout &lt;&lt; s &lt;&lt; endl; } } MyPrint mp;//仿函数 MyPrint()(\"你好\") mp(\"你好\");// 匿名对象 总结 =， []，-&gt; 操作符只能通过成员函数进行重载 &lt;&lt;，&gt;&gt;只能通过全局函数配合友元函数重载 不要重载&amp;&amp;，||操作符，因为无法实现短路规则","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"吴恩达机器学习1","slug":"吴恩达机器学习1","date":"2021-05-30T04:12:23.000Z","updated":"2021-06-20T10:32:53.149Z","comments":true,"path":"/79200c28/","link":"","permalink":"http://orzff.cn/79200c28/","excerpt":"吴恩达机器学习笔记(一)","text":"什么是机器学习 $A\\ computer\\ program\\ is\\ said\\ to\\ learn\\ from\\ experience\\ E\\ with $ $respect\\ to\\ some\\ class\\ of\\ tasks\\ T\\ and\\ performance\\ measure\\ P,\\ if\\ $ $its\\ performance\\ at\\ tasks\\ in\\ T,\\ as\\ measured\\ by\\ P,\\ improves\\ with\\ $ $experience\\ E.$ 一个计算机程序可以从经验$E$中学习，执行任务$T$，由$P$做性能评估，并且他在$T$任务中的表现(由$P$衡量)随着经验$E$的提高而提高。 以下跳棋为例: $E:$ 下过很多跳棋的经验 $T：$下跳棋的任务 $P ：$下一局赢下跳棋的可能性 一般的任何机器学习都可以分类两类：监督学习和非监督学习 什么是监督学习 $In\\ supervised\\ learning,\\ we\\ are\\ given\\ a data\\ set\\ and\\ already\\ know\\ $ $what\\ our\\ correct\\ output\\ should\\ look\\ like,having\\ the\\ idea\\ that\\ there\\ $ $is\\ a\\ relationship\\ between\\ the\\ input\\ and\\ the\\ output.$ 在监督学习中，我们已知一个数据集，并且已经知道正确的输出应该是什么样的，我们知道输入与输出之间存在着一种关系。 在监督学习中，我们已经知道数据集的含义、分布，根据已知的信息来预测。 $Supervised\\ learning\\ problems\\ are\\ categorized\\ into\\ “regression”\\ and\\ $ $”classification”\\ problems.\\ In\\ a\\ regression\\ problem,\\ we\\ are\\ trying\\ to\\ $ $predict\\ results\\ within\\ a\\ continuous\\ output,\\ meaning\\ that \\ we\\ are\\ $ $trying\\ to\\ map\\ input\\ variables\\ to\\ some\\ continuous\\ function.\\ In\\ a\\ $ $classification\\ problem,\\ we\\ are\\ instead\\ trying\\ to\\ predict\\ results\\ $ $in\\ a\\ discrete\\ output.\\ In\\ other\\ words,\\ we\\ are\\ trying\\ to\\ map\\ input\\ $ $variables\\ into\\ discrete\\ categories.\\ $ 监督学习问题分为“回归”问题和“分类”问题。在回归问题中，我们试图预测连续输出中的结果，这意味着我们试图将输入变量映射到某个连续函数。在分类问题中，我们试图预测离散输出中的结果。换句话说，我们试图将输入变量映射到离散的类别中。 例子回归问题：给一张照片，去预测照片中人的年龄 分类问题：对于患有肿瘤的病人，去预测肿瘤是良性还是恶性 什么是无监督学习 $Unsupervised\\ learning\\ allows\\ us\\ to\\ approach\\ problems\\ with\\ little\\ or\\ $ $no\\ idea\\ what\\ our\\ results\\ should\\ look\\ like.\\ We\\ can\\ derive\\ $ $ structure\\ from\\ data\\ where\\ we\\ don’t\\ necessarily\\ know\\ the\\ effect\\ of\\ $ $the\\ variables.\\ $ $We\\ can\\ derive\\ this\\ structure\\ by\\ clustering\\ the\\ data\\ based\\ on\\ $ $relationships\\ among\\ the\\ variables\\ in\\ the\\ data.$ $With\\ unsupervised\\ learning\\ there\\ is\\ no\\ feedback\\ based\\ on\\ the\\ prediction\\ results.$ 无监督学习让我们在几乎不知道结果是什么的情况下处理问题。我们可以从数据中得出结构，而我们并不一定知道变量的影响。 我们可以根据数据中变量之间的关系对数据进行聚类，从而得到这种结构。 在无监督学习中，没有基于预测结果的反馈。 例子收集100万个不同的基因，然后找到一种方法将这些基因分组，这些分组在某种程度上是相似的，或者由不同的变量(如寿命、位置、角色等)相关的。 建立符号规则$m$ 表示训练集数量，对于训练集中的每一项，我们使用$x^{(i)}$表示训练集中的第$i$行输入的变量，使用$y^{(i)}$表示训练集中第$i$行输出的变量 。 一对$(x^{(i)},y^{(i)})$成为一个训练样例，$(i)$只是表示训练集中的索引，而不是次幂。还使用$X$来表示输入值的空间，$Y$表示输出值的空间。 监督学习 $To\\ describe\\ the\\ supervised\\ learning\\ problem\\ slightly\\ more\\ formally,\\ $ $our\\ goal\\ is,\\ given\\ a\\ training\\ set,\\ to\\ learn\\ a\\ function\\ h\\ :\\ X\\ →\\ Y\\ $ $ so\\ that\\ h(x)\\ is\\ a\\ “good”\\ predictor\\ for\\ the\\ corresponding\\ value\\ of\\ y.\\ $ $For\\ historical\\ reasons,\\ this\\ function\\ h\\ is\\ called\\ a\\ hypothesis.\\ $ $Seen\\ pictorially,\\ the\\ process\\ is\\ therefore\\ like\\ this:\\ $ 为了更正式地描述监督学习问题，我们的目标是，给定一个训练集，学习一个函数$h: X → Y$，使$h(X)$是对应的$Y$值的一个很好的预测器。由于历史原因，这个函数$h$被称为一个假设。从图片上看，这个过程是这样的 代价函数假设的$h$函数由$h_{\\theta}(x)=\\theta_0 + \\theta_1x$拟合而来，$\\theta_0$和$\\theta_1$是两个未知参数 我们的目的是选择最适合的$\\theta_0,\\theta_1$以便于$h_{\\theta}(x)$最接近与真正的训练集对应$Y$值的分布 代价函数$J(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum\\limits_{i=1}^m(\\hat y_i -y_i)^2=\\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$表示$h$函数与$Y$值之间的误差 $Goal:\\ \\min\\limits_{\\theta_0,\\theta_1}J(\\theta_0, \\theta_1)$ 把$\\theta_0$设成0,不同的$\\theta_1$对应的$h$函数所形成的误差在$J(\\theta_1)$的图像上呈现一个二次函数的图像，寻找$J(\\theta_1)$的最小值，就是寻找最适合，最拟合与$Y$的$h(\\theta_1)$函数 梯度下降梯度下降算法就是根据当前的参数和代价函数选择一个下降方向，最终达到局部最优解的一种算法。 $The\\ way\\ we\\ do\\ this\\ is\\ by\\ taking\\ the\\ derivative\\ (the\\ tangential$ $line\\ to\\ a\\ function)\\ of\\ our\\ cost\\ function.\\ The\\ slope\\ of\\ the\\ tangent$ $is\\ the\\ derivative\\ at\\ that\\ point\\ and\\ it\\ will\\ give\\ us\\ a\\ direction$ $to\\ move\\ towards.\\ We\\ make\\ steps\\ down\\ the\\ cost\\ function\\ in\\ the$ $direction\\ with\\ the\\ steepest\\ descent.$ 梯度下降算法是求当前代价函数的导数（也就是函数图像的切线），这一点的导数会给我们一个方向，我们按下降最陡的方向逐步降低成本函数。 $The\\ size\\ of\\ each\\ step\\ is\\ determined\\ by\\ the\\ parameter\\ α,\\ which\\ is$ $called\\ the\\ learning\\ rate.$ 每个步骤的大小由参数α决定，称为学习率。 $repeat\\ until\\ convergence\\ \\{ \\\\ \\theta_j\\ :=\\ \\theta_j\\ - \\alpha \\ \\frac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1) (for j=0 and j=1) \\\\ \\}$ $\\theta_0$和$\\theta_1$同时更新，而不是先更新$\\theta_0$，然后再更新$\\theta_1$ 梯度下降如何达到最优点我们现在使用一个简单函数来解释一下梯度下降算法 假设我们的参数只有一个 $\\theta_1 :=\\theta_1-\\alpha \\frac{\\partial}{\\partial\\theta_1}J(\\theta_0)$ 图上第一个例子：当所在点在最优解右侧时，斜率为正$\\theta$减去的时正值，$\\theta$向左边移动 图上第二个例子：当所在点在最优解左侧时，斜率为正$\\theta$减去的时负值，$\\theta$向右边移动 根据斜率（也就是导数）移动，可以移动到当前可以到达的最优点 步距 当我们的步距过大和过小时都会出现问题 过小时移动次数太多，移动距离太小 过大时会越过最优点 梯度下降如何与固定步长相结合 当点越接近最低点时，导数最小，到最低点时导数为零，这就控制了步长使得步长的移动合适 梯度下降与代价函数结合拟合函数：$h(\\theta_0,\\theta_1)=\\theta_0+\\theta_1x$ 代价函数: $J(\\theta_0, \\theta_1) = \\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$ 梯度下降:$repeat\\ until\\ convergence\\ \\{ \\\\ \\ \\ \\ \\ \\theta_j\\ :=\\ \\theta_j\\ - \\alpha \\ \\frac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1) (for j=0 and j=1) \\\\ \\} $ 结合一下: $\\frac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1)\\\\ = \\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2 \\\\ = \\frac{1}{2m}\\sum\\limits_{i=1}^m(\\theta_0+\\theta_1(x^{(i)})-y^{(i)})^2$ 经过简单的微分过程:$\\theta_0\\ j = 0 \\ :\\ \\ \\frac{\\partial}{\\partial\\theta_0}J(\\theta_0,\\theta_1)= \\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)}) \\\\ \\theta_1\\ j = 1 \\ :\\ \\ \\frac{\\partial}{\\partial\\theta_1}J(\\theta_0,\\theta_1)= \\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}((x^{(i)})-y^{(i)}) \\cdot x^{(i)}) $ $m$是训练集的大小，$\\theta_0$是常量它会随着$\\theta_1$同步变化 这种方法在每一步上看整个训练集中的每个例子，称为批梯度下降。 矩阵和向量矩阵的定义不在赘述，向量是一种特殊的矩阵，向量的结构是$n \\times 1$的矩阵 $y=\\begin{bmatrix} a\\\\ b\\\\c\\\\d\\\\ \\end{bmatrix}$ $y_i$表示第$i$个元素 向量的下标可以有不同的起始，从1开始和从0开始，在数学中通常使用从1开始，在计算机领域通常使用从0开始 $y=\\begin{bmatrix} y_1\\\\ y_2\\\\ y_3\\\\ y_4\\\\ \\end{bmatrix} , y=\\begin{bmatrix} y_0\\\\ y_1\\\\ y_2\\\\ y_3\\\\ \\end{bmatrix}$ 矩阵加法两个矩阵相加必须是规格相同的两个矩阵对应位置相加 $\\begin{bmatrix}1 &amp;&amp; 0\\\\2 &amp;&amp; 5 \\\\ 3 &amp;&amp; 1\\end{bmatrix} + \\begin{bmatrix}4 &amp;&amp; 0.5\\\\2 &amp;&amp; 5 \\\\ 0 &amp;&amp; 1\\end{bmatrix}=\\begin{bmatrix}5 &amp;&amp; 0.5\\\\4 &amp;&amp; 10 \\\\ 3 &amp;&amp; 2\\end{bmatrix}$ 矩阵乘除矩阵乘以常量就是每个矩阵的每一元素乘上常量，除法类似 $k\\times \\begin{bmatrix}1 &amp;&amp; 0\\\\2 &amp;&amp; 5 \\\\ 3 &amp;&amp; 1\\end{bmatrix} = \\begin{bmatrix}1k &amp;&amp; 0k\\\\2k &amp;&amp; 5k \\\\ 3k &amp;&amp; 1k\\end{bmatrix}$ 两个矩阵相乘必须是$m\\times n$和$n \\times k$ 形式的矩阵才能相乘 $\\begin{bmatrix} A_{11} &amp;&amp; A_{12} &amp;&amp; A_{13} \\\\ A_{21} &amp;&amp; A_{22} &amp;&amp; A_{23}\\end{bmatrix} \\times \\begin{bmatrix} B_{11} &amp;&amp; B_{12} \\\\ B_{21} &amp;&amp; B_{22} \\\\ B_{31} &amp;&amp; B_{32} \\end{bmatrix}$ 比如$2\\times 3$的矩阵和$3\\times 2$的矩阵相乘，新矩阵的元素为$a_{ij}=\\sum\\limits_{k=1}^{n}A_{ik}*B_{kj}$ 新矩阵为： $\\begin{bmatrix} (A_{11}\\times B_{11}+A_{12}\\times B_{21}+A_{13}\\times B_{31}) &amp;&amp; (A_{11}\\times B_{12}+A_{12}\\times B_{22}+A_{13}\\times B_{32}) \\\\ (A_{21}\\times B_{11}+A_{22}\\times B_{21}+A_{23}\\times B_{31}) &amp;&amp; (A_{21}\\times B_{12}+A_{22}\\times B_{22}+A_{23}\\times B_{32}) \\end{bmatrix}$ 元矩阵$\\begin{bmatrix}1 &amp;&amp; 0\\\\0 &amp;&amp; 1\\end{bmatrix}$或者 $\\begin{bmatrix}1 &amp;&amp; 0 &amp;&amp; 0\\\\0 &amp;&amp; 1 &amp;&amp; 0 \\\\ 0 &amp;&amp; 0 &amp;&amp; 1\\end{bmatrix}$ 或者更大 元矩阵通常写作$I$，对于任意矩阵$A$ $A \\cdot I=I\\cdot A=A$ 逆矩阵如果矩阵$A$是一个方矩阵$m\\times m$,那么$A$存在逆矩阵$A^{-1}$ $AA^{-1}=A^{-1}A=I$ 矩阵的转置转置就是将矩阵转过来$B_{ji}=A_{ij}$ $A=\\begin{bmatrix}1 &amp;&amp; 2 &amp;&amp; 0 \\\\ 3 &amp;&amp; 5 &amp;&amp; 9 \\end{bmatrix}$ $A^T=\\begin{bmatrix}1 &amp;&amp; 3 \\\\ 2 &amp;&amp; 5 \\\\ 0 &amp;&amp; 9 \\end{bmatrix}$ 矩阵与梯度下降结合两个矩阵，一个$A(m\\times n)$ 一个$B(n \\times o)$，我们将$B$中的每一列单独取出来最矩阵乘法，得到的结果再合并，跟原来的结果相同 类似的矩阵的每一列我们都可以看成是一个向量，把不同的$h$函数也看成向量，那么两个矩阵相乘就可以得到不同$h$函数的预测量","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"机器学习/学习笔记","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://orzff.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"机器学习笔记(一)","slug":"Learn-ML1","date":"2021-05-29T04:54:19.000Z","updated":"2021-05-31T11:58:01.147Z","comments":true,"path":"/deefd94b/","link":"","permalink":"http://orzff.cn/deefd94b/","excerpt":"机器学习笔记(一)","text":"机器学习三大步骤先写出一个带有未知参数的数学式$Function \\ with \\ Unknown \\ Parameters$ $y = b + w x_1$ 带有未知参数$b, w$的公式，叫做model(带有未知的参数的数学式) $x_1:$ 公式中已知的东西叫做feature $w:$ 不知道的参数叫做weight（权重） $b:$ 不知道的参数叫做bias （偏移） 根据训练集定义$Loss$$Loss(b,w)$是一个函数，输入是$b,w$ Loss代表训练出来的函数对于训练集的拟合程度 $Loss: L = \\frac{1}{N}\\sum\\limits_n{e_n} (e = |y - y’|)$ 每项$e$是$model$对于训练集的误差 最佳化$w^, b^ = arg \\ \\min\\limits_{w,b}L$ $Gradient\\ Descent$ 随机选取一个初始点$w^0$ 计算微分 $\\frac{\\partial L}{\\partial w}|_{w= w^0}$ 根据微分的正负选择向前或向后移动$\\eta\\frac{\\partial L}{\\partial w}|_{w= w^0}$, $\\eta$学习速率，自己设置 迭代的更新$w$值 $model$ 的限制对于一次项的$model$是一条单纯的斜线，可能无法很好的拟合数据集，这叫做$Model$的$bias$，解决方法，写一个更复杂的，有更多未知参数的$model$ 例如需要拟合一个复杂的函数（红色线段）， 可以在每次的转折点添加一个蓝色线段，斜率保持相同即可，按理说，越是复杂的红色线段所需要的蓝色线段越多 对于连续的曲线可以选择足够多的点，就可以来使用蓝色线段拟合 如何来表达蓝色线段通过一个函数来逼近蓝色线段 $y = c \\frac{1}{1 + e ^{-(b+wx_1)}}$ 即 $y = c \\ sigmoid (b + wx_1)$ 调整$b, w, c$就可以得到各种各样的蓝色线段，改变$w$可以改变斜率，改变$b$会改变偏移，改变$c$会改变高 对于不同的蓝色线段使用不同的$b,w,c$来通过$sigmoid$逼近，那么红色线段的函数式就为$y = b + \\sum\\limits_{i}c_i\\ sigmoid(b_i + w_ix_1)$ 线性代数表达对于数据$x_1, x_2, x_3$ $\\sum\\limits_{i}c_i\\ sigmoid(b_i + w_ix_1)$可以表示为 r_1 = b_1 + w_1x_1\\\\ r_2 = b_2 + w_2x_2 \\\\ r_3 = b_3 + w_3 x_3矩阵写法 \\begin {bmatrix} r_1\\\\r_2\\\\r_3 \\end {bmatrix} = \\begin {bmatrix} b_1\\\\b_2\\\\b_3 \\end {bmatrix} + \\begin {bmatrix} w_1 \\ 0 \\ 0\\\\0\\ w_2\\ 0\\\\0 \\ 0\\ w_3 \\end {bmatrix}\\begin {bmatrix} x_1\\\\x_2\\\\x_3 \\end {bmatrix}$r = b + Wx$ 在对每一个$r$做$sigmoid$运算 $a = \\partial(r)$ 红色线段函数: $y = b + \\sum\\limits_{i}c_i \\ a$ 使用线性代数表达方式: $y = b + c^T a$ 使用$\\theta $ 来包含所有的未知参数$\\theta = \\begin{bmatrix} \\theta_1\\\\ \\theta_2 \\\\ \\theta_3 \\\\ \\dots \\\\ \\end{bmatrix}$ $Loss$ 使用$\\theta $参数$Loss$现在使用写成$L(\\theta)$ 新的$Loss$表示为：$Loss: \\ L = \\frac{1}{N}\\sum\\limits_ne_n$ 迭代最好的$model$$\\theta^* = arg \\ \\min\\limits_{\\theta}L$ 随机选择一个初始的$\\theta^0$， 对$\\theta$的每一项进行微分得到一个向量$g$ , $g = \\begin{bmatrix} \\frac{\\partial L}{\\partial \\theta_1}|_{\\theta = \\theta^0} \\\\ \\frac{\\partial L}{\\partial \\theta_2}|_{\\theta = \\theta^0} \\\\ \\frac{\\partial L}{\\partial \\theta_3}|_{\\theta = \\theta^0} \\\\ \\dots \\end{bmatrix}= \\nabla L (\\theta ^0)$ 在$\\theta = \\theta^0$的位置把所有的参数都对$L$做微分 更新$\\theta$的值 $\\begin{bmatrix} \\theta_1^1 \\\\ \\theta_2^1\\\\ \\dots \\end{bmatrix} \\longleftarrow \\begin{bmatrix} \\theta_1^0 \\\\ \\theta_2^0\\\\ \\dots \\end{bmatrix} - \\begin{bmatrix} \\eta \\frac{\\partial L}{\\partial \\theta_1}|_{\\theta = \\theta^0} \\\\ \\eta \\frac{\\partial L}{\\partial \\theta_2}|_{\\theta = \\theta^0} \\\\ \\dots \\end{bmatrix}$ 新的$\\theta$由原先的$\\theta^0$ 减去 微分的向量 × $\\eta$ $\\theta^1 \\longleftarrow \\theta^0 - \\eta g$ 步骤： 先随机选取$\\theta^0$，通过计算$gradient$ 得到 $ g = \\nabla L (\\theta ^0)$,在如此迭代得到$\\theta^1, \\theta^2,…$直到无法在计算$gradient$时结束 实际操作时，将数据集分为多组，利用每一组来计算$gradient$更新$\\theta$ 从 $sigmoid$到$RELU$利用$RELU$来拟合函数 $c\\ max(0, b+wx_1)$ $ y = b + \\sum\\limits_i c_i \\ sigmoid(b_i + \\sum\\limits_jw_{ij}x_j)$ $y = b + \\sum\\limits_{2i}c_i max(0, b_i+\\sum\\limits_jw_{ij}x_j)$ $sigmoid$ 和 $RELU$ 统称为$activation\\ function$, $RELU$更好一些 过拟合当拟合的函数次数过多时，对于训练数据会出现拟合效果好，但是对于测试数据拟合率爆炸的情况。","categories":[{"name":"ML 学习","slug":"ML-学习","permalink":"http://orzff.cn/categories/ML-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"ML 学习笔记","slug":"ML-学习笔记","permalink":"http://orzff.cn/tags/ML-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++学习笔记(五)","slug":"C-学习笔记(五)","date":"2021-05-10T03:03:12.000Z","updated":"2021-05-31T11:58:01.022Z","comments":true,"path":"/2c61a387/","link":"","permalink":"http://orzff.cn/2c61a387/","excerpt":"C++学习笔记(五)","text":"C++ 学习笔记（五）C++类型转换尽量少使用类型转换，除非用来解决特殊问题 静态转换static_cast目标类型 目标对象 = static_cast&lt;目标类型&gt;(原对象); 用于类层次结构中的基类和派生类之间指针或引用的转换，没有父子关系的不能转换 进行上行转换（派生类的指针或引用转换成基类）是安全的 进行下行转换（基类指针或引用转换成派生类）时，由于没有动态类型检查，所以时不安全的 用于基本数据类型之间的转换，如将int转换成char，把char转换成int，这种转换的安全性也要开发人员来保证 动态转换dynamic_castdynamic_cast非常严格，失去精度或者不安全都不可以转换 目标类型 目标对象 = dynamic_cast&lt;目标类型&gt;(原对象); 基础类型之间不能转换 dynamic_cast如果发生了多态，那么可以让基类转为派生类，向下转换 常量转换const_cast用来修改const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 常量引用被转换成非常量引用，并且仍然指向原来的对象 注意:不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的const const int * p = NULL; int *newp = const_cast&lt;int *&gt; (p); int * p1 = NULL; const int *newp1 = const_cast&lt;const int *&gt; (p1); 重新解释转换reinterpert_cast最不安全，不推荐使用 异常try{ // 试图执行的内容 // 在可能出现异常的地方抛出异常throw } catch() { // try下面catch捕获异常 // catch(捕获类型) ... 代表所有其他类型 // 如果不想处理异常，继续向上抛出throw } 跳级 异常基本处理int myd(int a, int b){ if(b == 0) { // return -1; 早期处理方式，返回-1 throw -1; // 抛出int类型异常，异常必须处理，如果不处理就挂掉 } return a/b; } void test() { int a = 10, b = -10; int ret = myd(a, b); // 早期如果返回-1， 无法区分到底是结果还是异常 try{ myd(a, b); } catch(int) {// 捕获int类型异常 // 如果不想在这处理，就抛出，返回上一层处理,类型不变 throw; //. 异常处理 } catch(...) { //其他类型异常捕获 } } void test2() { try{ test(); }catch(int) { // 如果异常都没有处理，那么成员terminate函数是程序中断 // ... } } 自定义异常类class MyException{ public : void printError(); } // try{ 抛出异常 // throw MyException(); // } // 捕获异常 catch(MyException e) { e.printError(); } 栈解旋 从try开始到throw抛出异常之前，所有栈上的对象，都会被释放，这个过程称为栈解旋 栈上对象构造和析构顺序相反 异常的接口声明void func() throw(int) { //thrwo(int) 只能抛出int类型异常 throw 3.14; // 抛出double类型直接挂掉 } void func() throw() { //thrwo() 不跑出任何类型异常 throw 3.14; } 异常变量声明周期异常变量的构造是在throw抛出异常时构造，析构实在catch处理完以后析构 class MyException{ public : void printError(); } void dowork() { throw MyException(); } void test() { try { dowork(); }catch(MyException e) { // catch时通过拷贝构造又会有一份数据，所以建议使用&amp; // catch(MyException &amp;e) } } // 返回指针，使用new，在堆区开辟内存，然后手动delete void dowork() { throw new MyException(); } void test() { try { dowork(); }catch(MyException * e) { // catch时通过拷贝构造又会有一份数据，所以建议使用&amp; // catch(MyException &amp;e) delete e; } } 异常的多态利用多态来实现printError同一个接口的使用 系统的异常库#include &lt;stdexcept&gt; 文件读写头文件#include &lt;fstream&gt; 写文件void test() { ofstream ofs(path， ios::out|ios::trunc); if(!ofs.is_open) { //... 打开失败 } ofs &lt;&lt; \"content\" &lt;&lt; endl;} 读文件void test() { ifstream ifs(path, ios::in); if(!ifs.is_open) { //... 打开失败 } // 第一种方式 char buf[1024]; while(ifs &gt;&gt; buf) { // 按行读取 cout &lt;&lt; buf &lt;&lt; endl; } // 第二种方式 while(!ifs.enf()) { // enf读到文件尾 ifs.getline(buf, sizeof(buf)); cout &lt;&lt; buf &lt;&lt; endl; } // 第三种方式 不推荐 按单个字符读取 char c; while((c = ifs.get()) != EOF) { cout &lt;&lt; c &lt;&lt; endl; } }","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++学习笔记(四)","slug":"C-学习笔记(四)","date":"2021-05-08T10:29:45.000Z","updated":"2021-05-31T11:58:01.055Z","comments":true,"path":"/2acaf4fa/","link":"","permalink":"http://orzff.cn/2acaf4fa/","excerpt":"C++学习笔记(四)","text":"C++学习笔记（四）继承class 子类 : 继承方式 父类 继承权限 继承方式 特点 父类私有属性能不能访问 public 父类的属性权限不变 不能 protect 父类的属性全变为protect 不能 private 父类的属性全变为private 不能 子类中会继承父类的私有成员，但是被编译器隐藏了起来 继承中的构造与析构构造： 先执行父类的构造函数，在调用子类的构造函数 析构：先执行子类的析构，在执行父类的析构 子类并不能继承父类的构造和析构函数，只有父类自己知道自己构造和析构的属性 如果父类没有默认构造，那么子类在构造时可以通过初始化列表的方式显示调用父类的有参构造 class Base{ Base(int a) ; } class Son : public Base{ Son(int a): Base(a) { } } 继承中的同名处理子类与父类属性或函数同名时，根据就近原则，属性为子类的值，如果想使用父类的值，那么就在调用时加上作用域 class Base{ public: int m_a; } class Son : punlic Base{ public; Son(int a) { this-&gt;m_a = 200; } int m_a; } void test() { Son s; cout &lt;&lt; s.m_a &lt;&lt; endl; // 子类的m_a cout &lt;&lt; s.Base::m_a &lt;&lt; endl;// 父类的m_a } 如果子类与父类的成员函数名称相同，子类会把父类的所有同名版本全隐藏，像调用父类的方法，必须加作用域 继承中的静态成员处理静态成员属性，子类可以继承下来，使用时直接在静态成员属性前加作用域即可 静态成员函数，子类也可以继承下来，使用时 Son::func() // 子类的func Son::Base::func() // 父类的func 非自动继承的函数不是所有的函数都能继承到子类，构造和析构函数不能继承，operator=也不能继承，因为它完成类似构造函数的行为 多继承一个类可以继承多个类 class A: public B, public C 二义性多继承中如果多继承的多个类有相同的成员属性，那么子类在调用父类相同的属性时会引发二义性 class A: public B, public C A a; cout &lt;&lt; a.m_a &lt;&lt; endl; // 如果B和C中都有m_a会引发二义性 cout &lt;&lt; a.B::m_a &lt;&lt; a.C::m_a &lt;&lt; endl;// 使用时在前面加上作用域 菱形继承子类继承的父类继承自同一个基类，会导致二义性的产生 class A; class B: public A; class C: public A; class D: public B, public C; 菱形继承解决方案虚继承class A; class B: virtual public A; //虚基类B class C: virtual public A; // 虚基类C class D: public B, public C; 虚继承后，子类中会有一个虚指针，指向一张虚基类表，通过表找到偏移量可以找到共有数据 多态多态分为编译时多态（静态多态）和运行时多态（动态多态），运算符重载和函数重载是编译时多态，派生类和虚函数是运行时多态 静态联编： 地址早绑定，编译阶段绑定好地址 动态联编： 地址晚绑定，运行时绑定号地址 多态： 父类的引用或指针 指向子类对象 class Animal { public: virtual void speak() { cout &lt;&lt; \"animal speak\" &lt;&lt; endl; } }; class Cat : public Animal { public: void speak() { cout &lt;&lt; \"cat speak\" &lt;&lt; endl; } }; // 调用dospeak，没有使用virtual时 speak函数的地址早就绑定好了，静态联编， 编译阶段确定好了地址 // 如果想使用cat的speak，那么就不能提前绑定函数的地址，所以需要运行时确定函数地址 // 动态联编，写法 dospeak 改为虚函数，在父类上声明虚函数，发生了多态 // 父类的引用或指针 指向子类对象 void doSpeak(Animal&amp; animal) { // 使用虚函数时 Animal &amp; animal = cat animal.speak(); } void test() { Cat cat; //如果发生了继承，编译器允许进行类型转换 doSpeak(cat); } 当Animal有了虚函数后，内部结构发生了改变， 内部多了一个虚指针，指向Animal的虚函数表 ,Cat内部也有一个虚指针，继承自Animal的虚指针，指向自己内部的虚函数表，父类和子类的虚函数表相同但是地址不同。如果Cat没有重写Animal的speak函数，那么虚函数表中的函数就是Animal的speak，如果重写了，那么就是Cat自身的speak Animal * animal = new Cat; animal-&gt;spead()； // 调用的是cat的speak，因为父类指针指向子类对象，指向时，子类已经发生多态，调用的也是多态后的函数 纯虚函数virtual int abc() = 0; // 告诉编译器在vtable中保留一个位置 如果父类有纯虚函数，那么子类必须实现纯虚函数 如果父类有了纯虚函数，那么父类就无法实例化对象，变成抽象类 虚析构和纯虚析构普通析构函数是不会调用子类的析构的，所以可能导致释放不干净，虚析构可以解决这个问题 纯虚析构需要声明并且实现，在类内声明，在类外实现，只声明不实现会报错，如果类出现了纯析构函数，那么这个类也算抽象类 类型转换 基类转派生类，向下转换，不安全 Animal * animal = new Animal; Cat *cat = (Cat*)animal; 派生类转基类，向上转换，安全 Cat * cat = new Cat; Animal *animal = (Animal*)cat; 如果发生了多态，总是安全的 模板int swap(int &amp;a, int &amp;b) { int tmp = a; a = b; b = tmp; } double swap(double &amp;a, double &amp;b) { int tmp = a; a = b; b = tmp; } 对于逻辑相似类型不同的函数，可以使用泛型编程—模板技术 template&lt;class T&gt; // 告诉编译器下面如果出现T，不要报错， T是一个通用类型 //template &lt;typename T&gt; class与typename 作用相同 void swap(T &amp;a, T &amp;b) { T tmp = a; a = b; b = tmp; } 模板特点： 自动类型推导，自动推导传参的数据类型到模板 swap(a, b) // 自动类型推导，按照a，b的类型来替换T 显示指定类型 swap&lt;int&gt; (a, b) 模板必须指定出T才可以使用 函数模板必须紧跟着template&lt;class T&gt; 函数模板与普通函数的区别以及调用规则 普通函数可以进行隐式类型转换，函数模板不可以进行隐式类型转换 如果函数模板与普通函数出现了重载，那么优先使用普通函数，如果没有实现，出现错误。如果想强制调用模板，可以使用空参数列表 swap&lt;&gt;(a, b); 函数模板可以发生重载 template&lt;class T&gt; swap(T a, T b, T c); 如果函数模板可以产生更好的匹配，那么调用函数模板 char a, b; swap(a, b); //调用函数模板 模板机制 编译器并不是把函数模板处理成能够处理任何类型的函数 函数模板通过具体类型产生不同的函数 编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译 模板局限性对于自定义的数据类型，使用具体化自定义数据类型解决 class Person{ int m_age; int m_name; }; template&lt;class T&gt; bool Compare(T &amp;a, T &amp;b) { if(a == b) return true; return false; } template&lt;&gt; bool Compare&lt;Person&gt;(Person &amp;a, Person&amp;b) { if(a.m_age == b.m_age) return true; return false; } 如果具体化能够优先匹配，那么就选择具体化 template&lt;&gt; 返回值 函数名&lt;具体类型&gt; (参数) 类模板template&lt;class NameType, class AgeType=int&gt; class Person{ public: Person(NameType name, AgeType age) { this-&gt;m_name = name; this-&gt;m_age = age; } NameType m_name; AgeType m_age; } 类模板不支持自动类型推导 类模板参数可以设默认值 需要指点显示类型 Person&lt;string, int&gt; p('abc', 18); 成员函数一开始不会创建出来，而是运行时才去创建 类模板做函数的参数//指定传入类型 void dowork(Person&lt;string, int&gt; &amp;p); template&lt;class T1, class T2&gt; // 参数模板化 void dowork2(Person&lt;T1, T2&gt; &amp;p); void test() { Person&lt;string, int&gt; p('ab', 18); dowork2(p); } // 整体类型化 template&lt;class T&gt; void dowork3(T &amp;p); void test() { Person&lt;string, int&gt; p('aa', 18); dowork3(p); } 类模板和继承template &lt;class T&gt; class Base{ public: T m_a; } // child 继承与base必须告诉base中的T的类型，否则T无法分配内存 class Child : public Base&lt;int&gt;{ } // childr2 也是模板类 template&lt;class T1, class T2&gt; class Child2 : public Base&lt;T2&gt;{ public: T1 m_b; } 基类如果是模板类，必须让子类告诉编译器基类中的T是什么类型，如果不告诉，那么就无法分配内存 利用参数列表class Child : public Base&lt;int&gt; 类模板类外实现成员函数template&lt;class T1, class T2&gt; class Person{ public: Person(T1 name, T2 age); T1 m_name; T2 m_age; } template&lt;class T1, class T2&gt; Person&lt;T1,T2&gt;::Person(T1 name, T2 age) { this-&gt;m_name = name; this-&gt;m_age = age; } 类模板分文件编写问题以及解决--- Person.h --- Person.cpp --- main.cpp Person.h写Person模板类的声明，Person.cpp写Person模板类的实现，在main.cpp中导入Person.h时，由于类模板的成员函数运行阶段才会去创建，所以编译器在编译时不会对Person.cpp中的方法进行创建，导致在链接时无法链接到方法。无法解析外部命令 解决方法：将类的声明和实现写到同一文件，后缀为.hpp 类模板和友元函数 友元函数类内实现跟普通类实现相同 声明时需要加上&lt;&gt;代表声明的是模板函数 template&lt;class T1, class T2&gt; class Person; // 让编译器看到Person声明 template&lt;class T1, class T2&gt; void printPerson(Person&lt;T1, T2&gt; &amp;p); // 让编译器提前看到printPerson声明 template&lt;class T1, class T2&gt; class Person{ friend void printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p); // 加上&lt;&gt;代表模板函数 public: Person(T1 name, T2 age); T1 m_name; T2 m_age; } template&lt;class T1, class T2&gt; // 友元函数类外实现 void printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p) { // ... }","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++学习笔记(二)","slug":"C-学习笔记(二)","date":"2021-05-04T06:21:25.000Z","updated":"2021-05-31T11:58:01.011Z","comments":true,"path":"/5287e3ee/","link":"","permalink":"http://orzff.cn/5287e3ee/","excerpt":"C++学习笔记(二)","text":"C++学习笔记（二）类类是对对象的抽象 对象是对类的实例 class 类名{ public: 公共权限 设置 成员属性 设置 成员函数 } 设计一个圆类，求圆的周长/* 设计一个类，求圆的周长 */ const double pi = 3.1415926535; class Circle{ //class 代表声明一个类，后面紧跟的是类的名称 public: //公共权限 // 半径 成员属性 int m_R; // 求圆周长的函数 double calZC() { // 类里面的函数，叫作成员函数 return 2 * pi * m_R; } // 设置半径的成员方法 成员函数通常可以修改成员属性 void setR(int r) { m_R = r; } }; 设计学生类class Student { public: string m_Name; // 姓名 int m_Id; // 学号 void setName(string name) { m_Name = name; } void setId(int id) { m_Id = id; } void showInfo() { cout &lt;&lt; \"姓名:\" &lt;&lt; m_Name &lt;&lt; \" 学号:\" &lt;&lt; m_Id; } }; 内联函数​ 宏函数只是简单的在编译期进行替换，所以宏函数无法对传参进行检查，也会出现歧义。内联函数是一个真正的函数，会检查函数参数列表，并返回值。内联函数在编译期也会进行替换，所以内联函数会占用空间，但是内联函数相对于普通函数的优势是省去了函数调用时的压栈，跳转和返回的开销。我们可以理解为内联函数以空间换时间。类中的成员函数默认是内联函数。 ​ 内联仅仅是给编译器的一个建议，编译器不一定会接受这种建议，如果你没有江汉数声明为内联函数，那么编译器也可能将此函数做内联编译，一个好的编译器将会内联小的、简单的函数。 函数默认参数void test(int a = 10, int b = 20, int c = 30) { cout &lt;&lt; a + b + c&lt;&lt; endl; } // 形参b设置默认值，那么后面的形参c也需要设置默认值，如果一个位置有个默认参数，那么后面的参数也必须有默认值 void test(int a, int b = 20, int c = 30) {} // 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能在设置默认参数 void test(int a = 0, int b = 0); // 声明时 void test(int a, int b) { //定义时 // ... } 占位参数void test(int a, int = 1) {} ​ 占位参数，函数调用时必需提供这个参数，但是用不到参数，可以有默认值 函数重载实现重载的条件 同一个作用域 参数个数不同 参数类型不同 参数顺序不同 当函数重载碰到默认参数时，要注意避免二义性问题 void func2(int a, int b = 10) {} void func2(int a){} 这里出现了二义性问题 引用的重载 void func(int &amp;a) {} //引用必需要合法的空间 void func(const int &amp;a) {} //const 也可以作为重载的条件 void test() { func(10); } 函数重载的原理​ 编译器为了实现重载，会用不同的参数来修饰不同的函数名，比如void func(); 编译器可能会将函数名修饰成_func，当编译器碰到void func(int x);编译器可能会将函数名修饰为_func_int，当编译器遇到void func(int x, char c);编译器可能会将函数名修改为_func_int_char。这个可能字眼是因为不同的编译器有不同的规则 extern C在C++中函数可以重载，在编译器会将函数名称偷偷改变，但是如果想调用C语言的方法时，也会将函数名改变，但是C中是没有重载的，所以编译会出错。这时使用extern可以将函数以C语言方式做链接。 extern \"C\" void show(); 也可以在C的头文件中加上 #ifdef __cplusplus extern \"C\"{ #endif void show(); #ifdef __cplusplus } #endif 封装​ 封装就是将现实中的具体的事物抽象化，把其具有的属性和操作合成一个整体，封装到一个类中。 ​ C语言使用struct来进行封装，但是在C语言中的struct不能写成员函数，属性和行为是分离的，类型检测不够，写起来比较麻烦。 ​ C++ 中的封装，严格类型转换检测，让属性和行为绑定到一起。属性和行为作为一个整体来表示生活中的事物。C++中控制权限 public公共权限、private私有权限、protect保护权限。 ​ 在C++中struct和class是一个意思，唯一的不同是默认权限，struct是public，但是class的默认权限是private。 class Animal{ void eat(); // 如果不声明权限，默认权限是private //所谓私有权限就是私有成员（属性、函数），在类内部可以访问，类外部不可以访问 public： int height; // 公共权限，在类内部和类外部都可以访问 protected: int wight; // 保护权限，类内部可以访问，（当前类的子类可以访问），类外部不可以访问 } 关键词 类内访问 类外访问 子类访问 public 可以 可以 可以 protect 可以 不可以 可以 private 可以 不可以 不可以 封装一个立方体类class Cube{ public: void setL(int l) {m_L = l;} int getL() {return m_L;} void setW(int w) {m_W = w;} int getW() const{return m_W;} //成员函数加const，代表这个成员函数没有修改成员属性 void setH(int h) {m_H = h;} int getH() {return m_H;} void getCubeS() { cout &lt;&lt; \"立方体面积为:\" &lt;&lt; 2 * m_L*m_W + 2 * m_W * m_H + 2 * m_L * m_H &lt;&lt; endl; } void getCubeV() { cout &lt;&lt; \"立方体体积:\" &lt;&lt; m_L * m_W * m_H &lt;&lt; endl; } //成员函数判断是否相等 bool compareCubeByClass(Cube &amp; cube) { //... } private: int m_L; int m_W; int m_H; }; // 传入参数如果加了const，那么只能调用const方法 bool compareCube(Cube &amp; cub1, Cube &amp; cub2) { // ... } 对象的构造和析构构造函数没有返回值，没有void，类名相同，可以发生重载，可以有参数 析构函数写法，与类名相同，类名前面加上一个符号 ~ ,也没有返回值，不写void，不可以有参数（不能发生重载） class Person { public: // 构造函数写法，与类名相同，没有返回值，可以发生重载（可以有参数） // 构造函数由编译器自动调用，而不是手动，而且只会调用一次 Person() { cout &lt;&lt; \"构造函数\" &lt;&lt; endl; } // 析构函数写法，与类名相同，类名前面加上一个符号 ~ ,也没有返回值，不写void，不可以有参数（不能发生重载） // 自动调用，只会调用一次 ~Person(){ cout &lt;&lt; \"析构函数\" &lt;&lt; endl; } }; void test() { Person p1; //默认调用构造和析构，是系统提供的两个空函数 } 构造函数的分类及调用按照参数进行分类 分为无参构造函数，有参构造函数 按照类型进行分类 分为普通构造函数，拷贝构造函数 无参构造写法和调用 Person p1; 注意不能写成Person p1(), 因为编译器认为这个是函数声明 有参构造写法和调用 Person p2(10)或者 Person p2 = Person(10) Person(10)匿名对象，执行当前行后就会释放这个对象 拷贝构造函数 Person(const Person &amp;p) Person p1(p2) 或者 Person p1 = Person(p2) 不能用拷贝构造函数初始化匿名对象 如果写成 Person (p1) 这种写法等价于 Person p1 写到右值可以做拷贝构造函数 Person p = 100 ,隐式类型转换，相当于调用 Person=Person(100) class Person { public: // 构造和析构必须写在public下 Person() { // 默认 无参构造函数 cout &lt;&lt; \"构造\"; } Person(int a) { //有参构造函数 cout &lt;&lt; a &lt;&lt; endl; } Person(const Person&amp; p) { // 拷贝函数 cout &lt;&lt; \"拷贝函数\" &lt;&lt; endl; } ~Person() { cout &lt;&lt; \"析构函数调用\" &lt;&lt; endl; } }; int main() { Person p3; //默认构造函数不加(),加（），编译器认为这是函数的声明 Person(100); // 叫匿名对象，匿名对象特定，如果编译器发现了对象是匿名对象，那么这行执行完，就执行析构函数 Person p1 = Person(100); // 这时声明了一个匿名对象并将其命名为p1 Person(p1); // 不能用拷贝构造来初始化匿名对象 Person p4 = Person(p3); //如果写成左值，编译器认为你写Person p4,对象的声明，如果写成右值，那么可以 Person p6 = 100; //相当于调用了Person p7 = Person(100)， 隐式类型转换 return 0; } 拷贝构造调用的时机 用已经创建好的对象来初始化新的对象 以值传递的方式给函数参数传值 void dowork(Person p1) {}// Person p1 = Person(p) 以值的方式返回局部对象 void dowork2() { Person p1; return p1; } void test() { Person p = dowork2(); } 构造函数调用规则系统默认给一个类提供3个函数，默认构造、拷贝构造、析构函数 当提供了有参构造函数，那么系统就不会给我们提供默认构造函数，但是系统还会提供默认拷贝构造函数 当我们提供了 拷贝构造，那么系统就不会提供其他构造了 深拷贝和浅拷贝类在进行指针类型的拷贝时，浅拷贝只是简单的复制堆区地址，会导致重复释放内存的异常，而深拷贝是重新开辟一片内存空间。 Person(const Person &amp;p) { m_age = p.m_age; m_name = (char*)malloc(strlen(p.m_name)+1); strcpy(n_name, p.m_name) } //析构函数 ~Person(){ if(m_name != NULL) { free(m_name); m_name = NULL; } } 初始化列表构造函数后面 +: 属性(参数),属性(参数) … //利用初始化列表初始化数据 Person(int a,int b,int c): m_a(a), m_b(b), m_c(c) {} 类对象作为成员构造时，类中的类成员先执行构造函数，类自身在执行构造。析构相反 explicit防止隐式类型转换 new 和delete new在堆区开辟空间 所有new出来的对象，都会返回该类型的指针，malloc返回void *使用时需要强转 malloc不会调用构造函数，new会调用 new是运算符，malloc是系统的一个函数 delete也是运算符，配合new使用，malloc与free配合使用 使用void *来接收new出来的指针，会出现释放问题 new会调用默认构造函数 new申请内存是无需指定内存块大小，malloc需要 Person *pa = new Person[10]; delete [] pa; // new 数组时需要有默认构造函数 // delete 数组时需要加[] // new 的时候加[], 那么delete时加上，new的时候不加，那么delete时也不加","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++学习笔记(一)","slug":"C-学习笔记(一)","date":"2021-05-02T06:54:52.000Z","updated":"2021-05-31T11:58:00.996Z","comments":true,"path":"/b34cf332/","link":"","permalink":"http://orzff.cn/b34cf332/","excerpt":"C++学习笔记(一)","text":"C++ 学习笔记（一）双冒号运算符作用域运算符 ::全局作用域 int a = 200; void test() { int a = 100; cout &lt;&lt; a &lt;&lt; endl; // 输出 100 cout &lt;&lt; ::a &lt;&lt; endl; //输出200 std::cout &lt;&lt; \"nihao\"; //::前面加std则是说明cout是std作用域下的 } namespace的使用namespace命名空间主要用于解决命名冲突 命名空间下可以放函数、变量、结构体、类 命名空间必须定义在全局作用域下 命名空间可以检讨命名空间 命名空间是开放的，可以随时往原先的命名空间添加内容 一个命名空间分开写会自动合并 命名空间可以匿名，匿名命名空间内的变量相当于static 命名空间可以起别名 using 声明和using 编译using 声明使用using声明时要避免二义性问题， namespace KG{ int sunwukongId = 10; } void test() { int sumwukongId = 20; using KG::sunwukongId; // 写了using 声明后，说明以后的所有sunwukongId都是KG下的， // 但是编译器又有就近原则，这就造成了二义性 cout &lt;&lt; sunwukongId &lt;&lt; endl; } using 编译void test2() { int sunwukongId = 20; using namespace KG; //打开命名空间KG，可以执行 cout &lt;&lt; sunwukongId &lt;&lt; endl; } C++对C的增强全局变量检测增强//全局变量中 int a; int a = 10; //在C语言中可以通过编译 //在C++中不能通过编译 函数检测增强// 函数 参数类型增强 int getRecS(w, h) { // 无返回值可以通过C编译不能通过C++编译 } // 在C中可以通过编译 // 在C++中不可以通过编译 //参数检测增强 void test02() { getRecS(10, 10, 10)； } 类型转换检测增强void test03() { char *p = malloc(sizeof(64)); //malloc返回值是void* } // C可以通过编译，因为C认为void*是一个万能指针，可以转换成char*， // 而C++不行，C++ 版本须为 // char *p = (char*)malloc(sizeof(64)); struct增强struct Person{ int m_Age; void plusAge(); // C中struct不能加函数，C++可以 } void test04() { struct Person p1; // C语言必须加上struct } bool类型增强// C中没有bool类型，在C++中bool类型 非0的值都是1 三目运算符增强void test05() { int a = 10; int b = 20; printf(\"%d\\n\", a &gt; b ? a : b); a &gt; b ? a : b = 100; // 三目运算符，C语言中返回值，C++返回的是变量 // C语言模仿C++写法 // *(a &gt; b ? &amp;a : &amp;b) = 100 } const增强const int m_A = 10; //全局const，在C和C++中都不能修改 void test07() { const int m_B = 20; //C中伪常量，C++中真常量 int *p = (int*)&amp;m_B; printf(\"%d\\n\", *p); // 在C中const的作用仅仅是不允许修改，但是可以通过指针来修改 // 在C++中通过指针修改的仅仅是*p, 而m_B并没有变 // int arr[m_B] 在C中不能来定义数组，在C++中可以 } C语言中，const修饰的变量，是伪常量，编译器是会分配内存的，只要分配内存就可以更改 C++中，const不会分配内存，在C++中int *p = (int*)&amp;m_B的*p指向的是编译器临时开辟的一块内存空间 const在C中默认是外部外部链接，在其他文件中使用extern可以找到变量，而在C++中则是默认内部链接 const分配内存，取地址会分配临时内存，使用extern时编译器也会给const变量分配内存，用普通变量初始化const变量也会给const分配内存 int a = 10; const int b = a; //会分配内存 自定义数据类型，加const也会分配内存 struct Person{ string m_Name; int m_Age; } void test() { const Person p1; // 分配了内存 Person *p = (Person*)&amp;p1; p-&gt;m_Name = \"abc\"; (*p).m_Age = 18; } const和define区别总结 1. const 有类型，可进行编译器类型安全检查，#define五类性，不可进行检查 2. const 有作用域，而#define 不重视作用域，默认定义处到文件结尾，如果定义在指定作用域下有效的常量，那么#define就 不能用，#define可以用undef 来结束作用周期 引用引用是C++对C的重要扩充。在C/C++中指针的作用基本都是一样的，但是C++增加了另一种给函数传递地址的途径，这就是按引用传递，他也存在与其他一些编程语言中，并不是C++的发明。 变量名实质上是一段连续内存的别名，是一个标号（门牌号） 程序中通过变量来申请并命名内存空间 通过变量的名字可以使用存储空间 int a = 10; int &amp;b = a; b = 200;//修改b时，a也会修改 引用引用使用格式：type &amp;别名=原名 引用 就是起别名，这里a的b都指向同一片地址空间，&amp;写到左侧叫引用，写到右侧是取地址。 引用必须初始化，引用初始化后不可以修改 void test() { //int &amp;a;//编译不通过 int a = 10; int &amp;b = a; //引用初始化后不可以修改 int c = 20; b = c;//这里是把c的值赋给b，而不是b引用c，初始化后不可以修改 } 对数组建立引用 void test() { int arr[10]; for (int i = 0; i &lt; 10; i ++) arr[i] = i; int (&amp;parr[i])[10] = arr; for (int i = 0; i &lt; 10; i ++) { cout &lt;&lt; parr[i]; } } 参数传递// 值传递，直接传递a，b的值，不更改a与b的值 void swap1(int a, int b){ int tmp = a; a = b; b = tmp; } // 指针传递，传递a，b的指针，更改a，b的值 void swap2(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } //引用传递，类似传递地址，相当于int &amp;a = a，可以通过引用改变a，b的值 void swap3(int &amp;a, int &amp;b) { int tmp = a; a = b; b = tmp; } void test() { int a = 10, b = 20; swap1(a, b); swap2(&amp;a, &amp;b); swap3(a, b); } 引用注意事项 引用必需引一块合法的内存空间 void test() { int &amp;a = 10;//引用必需引一块合法的内存空间 } 不要返回局部变量的引用 int &amp;dowork() { int a = 10; return a; } int&amp; work2() { static int a = 10; return a; } void test() { int &amp;ret = dowork(); // 局部引用已经销毁，数据不准确 dowork2() = 1000; // 如果函数的返回值引用，那么这个函数调用可以作为左值， //相当于写了a=1000 } 引用的本质引用的本质在C++内部实现是一个指针常量 指针的引用struct Person{ int m_age; } // 通过指针给对对象分配内存 void allocat(Person **p) { *p = (Person *)malloc(sizeof(Person)); (*p)-&gt;m_age = 100; } void test01() { Person *p = NULL; allocat(&amp;p); } // 利用指针引用开辟空间 void allocat(Person* &amp;p) { p = (Person*)malloc(sizeof(Person)); p-&gt;m_age = 100; } void test02() { Person *p = NULL; allocat(p); } 常量引用void test() { int &amp;ref = 10; // 引用了不合法的内存，不可以 const int &amp;ref = 10; //加入const后，编译器处理方式为 // int tmp = 10; const int &amp;ref = tmp; // 常量引用ref可以通过指针来修改 int *p = (int*)&amp;ref; *p = 1000; } 常量引用使用场景，通常用来修饰形参 void showValue(const int &amp;val) { //如果只是想展示内容，而不修改内容，那么就用const来修饰这个形参 } 483","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Qt无法输入中文","slug":"Qt无法输入中文","date":"2021-04-29T06:13:29.000Z","updated":"2021-05-31T11:58:01.150Z","comments":true,"path":"/20641ee8/","link":"","permalink":"http://orzff.cn/20641ee8/","excerpt":"Qt无法输入中文","text":"安装fcitx-frontend-qt5sudo apt-get install fcitx-frontend-qt51 查看`fcitx-frontend-qt5的安装目录。 dpkg -L fcitx-frontend-qt5 一般是这个 /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so 复制到安装目录我安装的是QT6 sudo cp libfcitxplatforminputcontextplugin.so {QT安装目录}/6.0.3/gcc_64/plugins/platforminputcontexts sudo cp libfcitxplatforminputcontextplugin.so {QT安装目录}Tools/QtCreator/lib/Qt/plugins/platforminputcontexts","categories":[{"name":"报错处理","slug":"报错处理","permalink":"http://orzff.cn/categories/%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://orzff.cn/tags/QT/"}]},{"title":"VI和VIM基本操作","slug":"VI和VIM基本操作","date":"2021-04-28T16:21:54.000Z","updated":"2021-05-31T11:58:01.150Z","comments":true,"path":"/a67e3062/","link":"","permalink":"http://orzff.cn/a67e3062/","excerpt":"VI和VIM基本操作","text":"Vi和Vim 基本操作Vi的插入 按键 功能 a 光标位置右边插入文字 i 光标位置当前处插入文字 o 光标位置下方开启新行 O 光标位置上方开启新行 I 光标所在行首插入文字 A 光标所在行尾插入文字 Vi 的退出 按键 功能 ZZ(shift+z+z) 保存退出 :wq 保存退出 :x 保存退出 :w filename 保存在指定文件 :q 退出，如果文件修改但没有保存，会提示无法退出 :q! 退出，不保存 :!命令 暂时离开vi，执行命令 Vi的删除和修改功能 按键 功能 [n]x 删除光标后n的字符 [n]X 删除光标前n的字符 D 删除光标所在开始到此行尾的字符 [n]dd 删除从当前行开始的n行（准确来说，是剪切，剪切不粘贴即为删除） [n]yy 复制从当前行开始的n行，向下复制 p 把粘贴板上的内容插入到当前行 dG 删除光标所在开始到文件尾的所有字符 J 合并两行，将光标所在行和下一行进行合并，在两行中间加入一个空格 . 执行上一次的操作 u 撤销前一个命令 Vi的行定位功能 按键 功能 ctrl+f 向前滚动一个屏幕 ctrl+b 向后滚动一个屏幕 gg 到文件第一行行首 G 到文件最后一行行首，G必需大写 :$ 到文件最后一行（行首） mG或mgg 到指定行，m为目标行数 /内容 查找指定内容 Vi的文本查找功能 按键 功能 /字符串 查找指定字符串 n 寻找下一个 N 回到前一个 ? 查找上一个 /^字符串 查找以字符串开始的行 /字符串$ 查找以字符串结尾的行 /a.b 查找字符串a任意字符b Vi的替换功能 按键 功能 r 替换当前光标字符 :r 文件名 在光标当前位置下一行载入另一个文件 :s/p1/p2/g 将当前行中所有p1均用p2替代 :g/p1/s//p2/g 将文件中所有p1均用p2替代 :n1,n2 s/p1/p2/g 将n1到n2行中所有p1用p2替代 Vi的set指令 按键 功能 :set ic 搜寻是忽略大小写 :set noic 搜寻是不忽略大小写 :set nu 显示行号 :set nonu 不显示行号","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://orzff.cn/tags/Vim/"}]},{"title":"Linux系统管理","slug":"Linux系统管理","date":"2021-04-27T14:51:51.000Z","updated":"2021-05-31T11:58:01.149Z","comments":true,"path":"/6c72ecbc/","link":"","permalink":"http://orzff.cn/6c72ecbc/","excerpt":"Linux系统管理","text":"Linux系统管理日历 calcal命令用户查看当前日历，-y显示整年日历 显示或设置时间date设置时间格式 date [MMDDhhmm[CC]YY][.ss] + format CC为年的前两位yy为年的后两位，前两为的mm为月，后两位的mm为分钟，dd为天，hh为小时，ss为秒 查看进程信息 ps进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元， ps命令可以查看进程的详细状况，常用选项（选项可以不加-） 进程 含义 -a 显示终端上所有进程，包括其他用户的进程 -u 显示进程的详细状态 -x 显示没有控制终端的进程 -w 显示加宽，一边显示更多的信息 -r 只显示正在运行的进程 动态显示进程 toptop命令用来动态显示运行中的进程，top命令能够在运行后，在指定时间间隔更新显示信息，可以在使用top命令时加上-d&lt;interval&gt;来指定显示信息更新时间间隔。 在top命令执行后，可以按下按年得到对显示结果进行排序 按键 含义 M 根据内存使用量来排序 P 根据CPU占有率来排序 T 根据进程运行时间的长短来排序 U 可以根据后面输入的用户名来筛选进程 K 可以根据后面输入的PID来杀死进程 结束进程 KILLkill命令指定进程号的进程，需要配合ps使用 kill [-signal] pid 信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。 后台程序 &amp;、jobs、fg 用户可以将一个前台执行的程序调入后台执行，方法为：命令 &amp; 如果程序已经在执行，ctrl+z可以 将程序调入后台 jobs查看后台运行程序 fg编号（编号为通过jobs查看的编号），将后台运行程序调出到前台 关机重启 reboot、shutdown、init 命令 含义 reboot 重新启动操作系统 shutdown -r now 重新启动操作系统，shutdown会给别的用户提示 shutdown -h now 立刻关机，其中now相当于时间为0的状态 shutdown -h 20：25 系统在今天20：25会关机 shutdown -h +10 系统再过十分钟会自动关机 init 0 关机 init 6 重启 字符界面和图形界面切换在redhat平台下，可通过命令进行切换 init 3 ： 切换到字符界面 init 5 ： 切换到图形界面 通过快捷键切换（适用于大部分平台） Ctrl+Alt+F2 切换到字符界面 Ctrl+Alt+F7 切换到图形界面 检测磁盘空间 dfdf命令用户检测文件系统的磁盘空间占用和空余情况，可以显示所有文件系统对节点和磁盘块的使用情况。 选项 含义 -a 显示所有文件系统的磁盘使用情况 -m 以1024字节为单位显示 -t &lt;fs&gt; 显示各指定文件系统的磁盘空间使用情况 -T 显示文件系统 ## 格式化 `mkfs` mkfs命令相当于DOS/WINDOWS系统中的格式化命令，用户创建指定的文件系统 mkfs [选项] 设备文件名 [blocks] 选项 含义 -V 详细显示模式 -t &lt;.fs&gt; 指定文件系统类型，默认值为ext2 -c 在创建文件系统的同时，进行磁盘坏块检查 blocks 文件系统块的大小 应用软件安装和卸载在Linux系统中，几乎所有的软件均通过RPM进行安装、卸载及关机等操作。 rpm [选项] [软件包名] 选项 含义 -i 指定安装的软件包 -h 使用#显示详细的安装过程和进度 -v 显示安装的详细信息 -q 查询系统是否已安装指定的软件包 -a 查看系统以安装的所有软件包 -e 卸载软件包 -nodeps 配合-e参数使用，强制卸载不检查依赖项 -force 强制操作，如强制安装删除等 查看或配置网卡信息 ifconfig如果，我们只是敲ifconfig，它会显示所有网卡的信息 显示字段 说明 eh0 网络接口名称 Link encap 链路封装协议 Hwaddr 网络接口的MAC地址 Inet addr IP地址 Bcast 广播地址 Mask 子网掩码 UP 网络接口状态标识，UP已经启用，DOWN已经停用 BROADCAST 广播协议，表示网络接口是否支持广播 RUNNING 传播协议，表示网络接口是否已经开始传输分组数据 MULTICAST 多播协议，表示网络接口是否支持多播 MTU,Metric MTU最大传输单位，单位：字节，Metric度量值，用于RIP建立 RX bytes 接受数据字节统计 TX bytes 发送数据字节统计 测试远程主机连通性 ping ping通过ICMP协议向远程主机发送ECHO_REQUEST请求，期望主机回复ECHO_REPLY消息 通过ping命令可以检查是否与远程主机建立了TCP/IP连接 网络路由设置 routeroute可以增加、修改、显示路由信息 route [-v] [-A family] add default [gw 默认网关地址] [[dev interface]] 监控网络状态 netstatnetstat命令监控网络状态，包括接口设置、`IP路由、各种网络协议的统计","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux 系统管理","slug":"Linux-系统管理","permalink":"http://orzff.cn/tags/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}]},{"title":"Linux用户权限","slug":"Linux用户权限","date":"2021-04-27T13:53:40.000Z","updated":"2021-05-31T11:58:01.148Z","comments":true,"path":"/e7492e71/","link":"","permalink":"http://orzff.cn/e7492e71/","excerpt":"Linux用户权限","text":"Linux 用户权限用户查看当前用户whoamiwhoami该命令用户查看当前系统帐号的用户名，可通过cat /etc/passwd查看系统用户信息。 由于系统管理员通常需要使用多种身份登录系统，例如通常使用普通用户登录系统，然后再以su命令切换到root身份对传统进行管理，这时就可以使用whoami来查看当前用户身份。 查看登录用户 whowho命令用户查看当前所有登录系统的用户信息 常用选项 选项 含义 -m或am I 只显示运行who的用户名，登录终端和登录时间 -q或--count 只显示用户的登录帐号和登录用户的数量 -u 在登录时间后显示该用户最后一次操作到当前时间的时间间隔 -u或--heading 显示列标题 查看登录用户 ww命令也可以查看登录当前系统的用户信息，与who命令相比，w命令的功能更强大，它不但可以显示当前有哪些用户登录到系统，还可以显示这些用户正在进行的操作，并给出更加详细和科学的统计数据。 w [选项] [用户名] 如果w命令携带用户名，则只显示指定用户的信息，否则显示当前所有登录用户的信息。 常用选项 选项 含义 -h 只显示运行who命令的用户名、登录终端和登录时间 -l 显示详细信息列表，此为预设值 -s 使用短列表，不显示用户登录时间、JCPU和PCPU时间 -u 忽略执行程序的程序，以及程序的PCPU时间 推出登录账户 exit 如果是图形界面，推出当前终端 如果是使用ssh远程登录，推出登录帐号 如果是切换后的登录用户，退场则返回上一个登录帐号 切换用户 su可以通过su命令切换用户，su后面可以加-，su和su -命令不同之处在与，su -切换到对应的用户会将当前的工作目录自动切换到切换后用户主目录。 添加、删除组帐号：groupadd、groupdel groupadd新建组帐号 groupdel删除组帐号 cat /etc/group 查看用户组 创建工作组： groupadd 组名 删除工作组： groupdel 组名 注意： 需要切换到 root用户 修改组 usermodusermod -g 用户组 用户名 修改用户所在组：usermod -g 组名 用户名 添加用户帐号 useradd在Unix/Linux中添加用户帐号可以使用adduser或useradd命令，因为adduser命令是指向useradd命令的一个链接，因此，这两个命令的使用格式完全一样。 useradd [参数] 新建用户帐号 参数 含义 -d &lt;dirname&gt; 指定用户登录系统时的主目录，如果不使用该参数，系统自动在/home目录下建立与用户名同名目录为主目录 -m 自动建立目录 -g 指定组名称 修改文件权限 chmodchmod修改文件权限有两种使用格式：字母法和数字法 字母法：chmod u/g/o/a +/-/= rwx 文件 u/g/o/a 含义 u user表示该文件所有者 g group表示与该文件的所有者属于同一组（group）者，及用户组 o other表示其他以外的人 a all表示这三者皆是 +-= 含义 + 增加权限 - 撤销权限 = 设定权限 rwx 含义 r read表示可读取，对于一个目录，如果没有r权限，那么就意味这不能通过ls查看这个目录的内容 w wriet表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新文件 x excute表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录 数字法： rwx 这些权限可以用数字代替 r: 读取权限，数字代号为 4 w：写入权限，数字代号为 2 x：执行权限，数字代号为 1 chmod 741 file -R （-R 代表递归给目录加上相同的权限） 修改文件所有者 chownchown 用户名 文件或目录名 修改文件所属组 chgrpchgrp 用户组名 文件或目录名","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"用户权限","slug":"用户权限","permalink":"http://orzff.cn/tags/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/"}]},{"title":"Linux 命令","slug":"Linux-命令","date":"2021-04-27T08:24:09.000Z","updated":"2021-05-31T11:58:01.147Z","comments":true,"path":"/9da1ef6b/","link":"","permalink":"http://orzff.cn/9da1ef6b/","excerpt":"Linux 命令","text":"Linux命令格式：命令 选项 参数 通配符 通配符 含义 * 匹配任意多个字符 ? 匹配任意一个字符 [] [和]将字符组扩起来，表示可以匹配字符组中任意一个，-用户表示字符范围 [abc] 匹配a、b、c中任意一个 [a-z] 匹配从a到z范围内任意一个字符 \\ 转义字符，将通配字符转义成普通字符 查看文档命令 --help man 命令 快捷键 快捷键 含义 tab 智能补全，如果没有重复的选项 ，自动补全，如果有重复项，按下两个tab，显示列表 ⬆ ⬇ 历史记录 常用命令 指令 命令 打开终端 ctrl+alt+t 在终端中锁定 ctrl+c 清屏 ctrl+l 查看文件 ls 指令 命令 查看文件 ls 查看隐藏文件 ls -a 查看文件详细信息 ls -l 配合-l以人性化方式显示文件大小 ls -lh 输出重定向 指令 含义 &gt; 输出重定西会覆盖原来的内容 &gt;&gt; 输出重定向则会追加到文件的尾部 man 功能键 功能键 功能 空格 显示手册下一屏 Enter 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 推出man命令 h 列出所有功能键 /word 搜索word字符串 创建目录 mkdirmkdir 目录名 -p 递归创建 通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。 删除文件 rmrm 文件 rmdir 删除文件夹 rmkdir 目录名 目录一定是空的 可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能回恢复。为了放置文件误删，可以在rm后使用-i参数一逐个确认要删除的文件。 参数 含义 -i 已进行交互方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹是必需加此参数 建立链接文件 lnln 源文件 链接文件 硬链接 ln -s 源文件 链接文件 软链接 软链接文件不占磁盘空间，但是删除源文件会影响软链接文件 硬链接文件站磁盘空间，但是删除源文件不会影响硬链接文件 硬链接和复制的区别，无论你修改了哪一个链接之后的文件，另一个会改变，但拷贝不会 文本搜索 grepgrep [-选项] ’搜索内容串‘ 文件名 常见选项 选项 含义 -v 显示不包括匹配文本的所有行（相当与求反） -n 显示匹配行以及行号 -i 忽略大小写 grep后的搜索规则也可以是正则表达式 通配符 含义 ^a 以a为起始的字符搜索文件 a$ 以a为结尾的字符搜索文件 . 匹配任意一个非换行的字符 * 匹配任意字符（大于0的整数） 计算文件的行数与字数 wc wc [-选项] 文件名 选项 含义 -l 统计行数 -w 统计字数，一个字被定义为有空白、跳格或换行的字符分隔的字符串 -c 统计字节数 -m 统计字符数，这个标志不能与-c标识一起使用 文件搜索 find在特定目录下搜索符合条件的文件也可以用来搜索特定用户属主的文件 find 目录 参数 文件名（可以使用通配符） -name 文件名 -size 大小 -perm 权限 常见用法： 命令 含义 find ./ -name test.sh 查找当前目录下所有名为test.sh的文件 find ./ -name '*.sh' 查找当前目录下所有后缀为.sh的文件 find ./ -name \"[A-Z]*\" 查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M 查找在/tmp目录下等于2M的文件 find /tmp -size +2M 查找在/tmp目录下大于2M的文件 find /tmp -size -2M 查找在/tmp目录下小于2M的文件 find ./ -size +4k -size -5M 查找当前目录下大于4k小于5k的文件 find ../ -perm 0777 查找当前目录下权限为777的文件或目录 拷贝 cpcp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS中的copy命令。 常见选项 选项 含义 -a 该选项通常在复制目录时使用，她保留链接、文件属性，并递归的复制目录，简单而言，保持文件与原有属性。 -f 删除已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录或文件，目标文件必须为一个目录名 -v 显示拷贝进度 移动 mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。 常用选项 选项 含义 -f 禁止交互式操作，如有覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件 -v 显示移动进度 获取文件类型 filelinux系统文件类型不是根据文件扩展名分类的，通过file命令可以确认文件具体类型。 归档管理 tar计算机的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。 tar [参数] 打包文件名 文件 归档： tar -cvf 归档文件名.tar 文件1 文件2 目录1 目录2 解归档：tar -xvf 归档文件名.tar 路径 tar命令很特殊，其参数前面可以使用-，也可以不使用 文件压缩解压gzip tar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz gzip [选项] 被压缩文件 压缩： gzip 归档文件名.tar 生成一个文件 归档文件名.tar.gz 文件大小小于归档文件大小[归档文件名.tar] 不存在了 解压缩： gzip -d 归档文件名.tar.gz 生成一个文件 归档文件名.tar 一步归档压缩： tar -czvf 文件名.tar.gz 文件1 文件2 目录1 目录2 一步解归档压缩： tar -xzvf 文件名.tar.gz -C 路径 常用选项 选项 含义 -d 解压 -r 压缩所有子目录 bzip2一步归档压缩： tar -cjvf 文件名.tar.bz2 文件1 文件2 目录1 目录2 一步解归档压缩： tar -xjvf 文件名.tar.bz2 -C 路径 zip,unzip一步归档压缩： zip [-r] 目标文件（没有扩展名） 源文件 zip 文件名 文件1 文件2 目录1 目录2 生成一个文件为： 文件.zip 一步解归档压缩： unzip -d 解压后目录文件 压缩文件 unzip 文件名.zip -C 路径 查看命令位置 whichwhich ls 管道一个命令的输出可以通过管道作为另一个命令的输入。","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux 命令","slug":"Linux-命令","permalink":"http://orzff.cn/tags/Linux-%E5%91%BD%E4%BB%A4/"}]},{"title":"Linux 目录和文件","slug":"Linux-目录和文件","date":"2021-04-27T08:23:54.000Z","updated":"2021-05-31T11:58:01.148Z","comments":true,"path":"/920965dc/","link":"","permalink":"http://orzff.cn/920965dc/","excerpt":"Linux 目录和文件","text":"Linux 目录与文件目录与路径[绝对路径]文件位置： windows: 盘符:\\文件夹\\文件 linux: /home/文件夹/0612/day01/a [相对路径]当前目录所在位置0612 ./day01/a .代表当前目录 .. 上一级文件夹 目录创建规则 长度不超过256 不能包含特殊字符 见名知意 Linux 目录结构 /: 根目录，一般根目录下只存放目录，在linux下有且只有一个根目录。 /bin,/usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。 /boot: 放置linux系统启动是用到的一些文件，如Linux的内核文件 /boot/vmlinuz，系统引导管理器:/boot/grub。 /dev: 放置linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/chrom/mnt。 /etc:系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d/、/etc/X11、/etc/sysconfig、/etc/xinetd.d。 /home:系统默认的用户家目录，新增用户帐号时，用户的家目录都存放在此目录，~表示当前用户的家目录，~edu表示用户edu的家目录。 /lib、/usr/lib、/usr/local/lib:系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。 /lost+fount:系统异常产生错误时，会将一些遗失的片段放置与此目录下。 /mnt、/media:光盘默认挂载点，通常光盘挂载与/mnt/chrom下，也不一定，可以选择任意位置挂载。 /opt:给主机额外安装软件所摆放的目录。 /proc:此目录的数据都在内存中，如系统核心、外部设备、网络状态，由于数据都存放在内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等。 /root:系统管理员root的家目录。 /sbin、/usr/bin、/usr/local/sbin:放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等，与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能查看而不能设置和使用。 /tmp: 一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要的数据不可放置在此目录下。 文件计算机中一切皆文件 在windows中区分文件通过扩展名区分文件，在linux中通过颜色区分也可以通过命令区分 file 文件名 文件分类 普通文件 目录文件 设备文件 字符设备文件 块设备文件 管道文件 链接文件 文件权限读[r]， 写[w]，执行[x] d rwx rwx rwx 目录 文件所属用户 文件所属组 其他用户","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux目录文件","slug":"Linux目录文件","permalink":"http://orzff.cn/tags/Linux%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6/"}]},{"title":"vultr+cloudflare","slug":"vultr-cloudflare","date":"2021-03-03T15:42:11.000Z","updated":"2021-05-31T11:58:01.167Z","comments":true,"path":"/4e01c297/","link":"","permalink":"http://orzff.cn/4e01c297/","excerpt":"vultr+cloudflare","text":"申请免费域名+ cloudflare 托管域名：申请免费域名+域名托管 注意freenom 申请到的域名设置DNS只需要设置cloudflare的解析得到的dns，不需要设置80.80.80.80 cloudflare 解析时使用的ip是VPS服务器的ip VPS 搭建服务器搭建 Trojan 服务器搭建Trojan服务器 centos8以上的不需要升级内核，内核升级可能造成服务器无法启动， 搭建 Vless服务器（推荐）搭建 Vless服务器](http://luyiminggonnabeok.cn/2020/10/13/Vless-ws-tls一键脚本教程/)) BBR加速bbr加速","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"飞机","slug":"飞机","permalink":"http://orzff.cn/tags/%E9%A3%9E%E6%9C%BA/"}]},{"title":"Django与mysql相连","slug":"Django与mysql相连","date":"2020-12-27T08:55:14.000Z","updated":"2021-05-31T11:58:01.146Z","comments":true,"path":"/3a7fd0d4/","link":"","permalink":"http://orzff.cn/3a7fd0d4/","excerpt":"Django与mysql相连","text":"Django与mysql相连Django链接数据库在项目根setting.py中更改默认配置 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'test', 'USER': 'root', 'PASSWORD': '****', 'HOST': '****', 'PORT': '3306' } } ENGINE 用于特定的数据库引擎的配置，一般选项如下 django.db.backends.sqlite3 django.db.backends.postgresql django.db.backends.mysql django.db.backends.oracle NAME:要连接的数据库名称的配置USER:配置连接数据库的用户账号PASSWORD:配置连接数据库的登录密码HOST:配置数据库所在的主机IP地址 PORT:配置连接数据库的端口号CHARSET:配置连接数据库交互数据编码格式 创建模型Django项目中定义模型数据，其实就是定义class类型，通过类型创建的对象来封装管理数据，一定要在这里明确关联和对应关系 程序 数据库 class类型 table 表格 attr属性 field字段 object对象 record记录 模型中的属性与数据库中的字段对应 对象中的属性类型定义 表中的字段类型 AutoField() auto_increment 自动增长 BOoleanField() bool 布尔类型 NullNooleanField() bool or null 扩展布尔类型 CharField() varchar 字符串 TextField() text 长文本 IntegerField() int 整数 DecimalField() double 双精度 FloatField() float 单精度 DateField() date 日期 TimeField() time 时间 DateTimeField() datetime 日期时间 FileField() blob 二进制 ImageField() bolb二进制 每个字段定义时，都有自己的一些特殊选项指定 选项 描述 null 如果为True，将NULL空值存储到数据库中，默认False blank 如果为True，表示该字段允许存储空值，默认False db_column 字段名称，如果不指定，直接使用类型属性的名称作为字段名称 db_index 如果设置为True，表示个当前字段添加索引支持 default 给字段默认值 primary_key 是否设置当前字段为主键 unique 如果为True，该字段储存的值必须时唯一的 在大部分项目汇总，还会涉及到多表关联 选项 描述 ForeignKey 一对一关联，该字段定义在多个一方 ManToManyField 多对多关联关系，该字段两方都需要定义 OneToOneField 一对一关联，该字段可以定义在任意一方 项目结构 ├── backend │ ├── __init__.py │ ├── admin.py │ ├── migrations │ │ └── __init__.py │ ├── models.py │ ├── tests.py │ └── views.py ├── manage.py └── ulb_manager ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py 在根目录的setting.py中添加 INSTALLED_APPS = [ ///... 'backend', ] 修改backend/models.py from django.db import models # Create your models here. class User(models.Model): id = models.AutoField(primary_key = True) account = models.CharField(max_length=20) password = models.CharField(max_length=20) def __str__(self): # 表中每条数据显示账号 return u'account: %s' % self.account class Class(models.Model): id = models.AutoField(primary_key = True) name = models.CharField(max_length=20) model中定义两个类，代表两个表User，Class， 创建两个表 python manage.py makemigrations 同步到mysql python manage.py migrate 这时在mysql中可以看到新增加的表 mysql&gt; show tables; +----------------------------+ | Tables_in_test | +----------------------------+ | auth_group | | auth_group_permissions | | auth_permission | | auth_user | | auth_user_groups | | auth_user_user_permissions | | backend_class | | backend_user | | django_admin_log | | django_content_type | | django_migrations | | django_session | | user | +----------------------------+ 后台显示数据库在backend/admin.py中注册模型 from django.contrib import admin from .models import * # Register your models here. admin.site.register(User) admin.site.register(Class) 运行django python manage.py runserver 8888 在http://127.0.0.1:8888/admin/中可以看到后台登录界面 创建超级用户python manage.py createsuperuser 账号和密码都是admin，其他可以随便填 这时可以通过后台登录界面进入后台看到数据库数据 修改 语言和时区在根目录/setting.py中修改 语言和时区 LANGUAGE_CODE = 'zh-Hans' TIME_ZONE = 'Asia/Shanghai' 后台界面可以显示中文，通过增加可以添加数据","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://orzff.cn/tags/Django/"},{"name":"连接MySQL","slug":"连接MySQL","permalink":"http://orzff.cn/tags/%E8%BF%9E%E6%8E%A5MySQL/"}]},{"title":"axios与django通信","slug":"axios与django通信","date":"2020-12-26T15:37:50.000Z","updated":"2021-05-31T11:58:01.156Z","comments":true,"path":"/5218864/","link":"","permalink":"http://orzff.cn/5218864/","excerpt":"axios与django通信","text":"axios实例import axios from 'axios' import qs from 'qs' export function request (config) { const instance = axios.create({ //实例，配置一些基础信息 baseURL: 'http://192.168.0.100:8888/api/', timeout: 5000, withCredentials: true }) instance.interceptors.request.use(config =&gt; { //请求拦截器 console.log(config) if (config.method == \"POST\") { config.data = qs.stringify(config.data) // post的数据要经过处理 } return config }, err =&gt; { console.log(err) }) instance.interceptors.response.use(res =&gt; {//接收拦截器 return res.data }, err =&gt; { console.log(err) }) return instance(config) } 具体get与postimport { request } from './request' export function getBooks () { return request({ url: 'books' }) } export function postLogin (config) { return request({ method: 'post', url: 'books', data: config, headers: { 'Content-Type': 'application/x-www-form-urlencoded' // 发送数据的类型 } }) } 表单数据&lt;template&gt; &lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" placeholder=\"login\" v-model=\"name\" /&gt; &lt;input type=\"text\" placeholder=\"pwd\" v-model=\"pwd\" /&gt; &lt;input type=\"submit\" value=\"登录\" @click=\"submitForm\" /&gt; &lt;/form&gt; &lt;!-- &lt;button @click=\"submitForm\"&gt;submit&lt;/button&gt; --&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { getBooks } from 'network/home' import { postLogin } from 'network/home' export default { el: '#app', data () { return { name: \"1234\", pwd: '1234', } }, created () { getBooks().then(res =&gt; { console.log(res) this.content = res.data }) }, methods: { submitForm (event) { console.log(this.name) let formData = new FormData() formData.append('name', this.name) formData.append('pwd', this.pwd) postLogin(formData).then(res =&gt; { console.log(res) }) } } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; django配置MIDDLEWARE = [ 'django.middleware.csrf.CsrfViewMiddleware', # 注释掉csrf ] APPEND_SLASH=False","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://orzff.cn/tags/Django/"},{"name":"Axios通信","slug":"Axios通信","permalink":"http://orzff.cn/tags/Axios%E9%80%9A%E4%BF%A1/"}]},{"title":"Django + Vue 快速构建项目","slug":"Django-Vue-快速构建项目","date":"2020-12-24T12:14:26.000Z","updated":"2021-05-31T11:58:01.146Z","comments":true,"path":"/b2788495/","link":"","permalink":"http://orzff.cn/b2788495/","excerpt":"Django + Vue 快速构建项目","text":"使用Vue+Django搭建项目参考 构建Django项目命令： django-admin startproject ulb_manager 结构： . ├── manage.py └── ulb_manager ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py 进入项目根目录，创建一个 app 作为项目后端命令： cd ulb_manager python manage.py startapp backend 即：app 名叫做 backend 结构： . ├── backend │ ├── __init__.py │ ├── admin.py │ ├── migrations │ │ └── __init__.py │ ├── models.py │ ├── tests.py │ └── views.py ├── manage.py └── ulb_manager ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py 将Vue打包的dist文件放入url_manager. ├─backend │ ├─migrations │ └─__pycache__ ├─vue-fonter │ └─dist │ └─static │ ├─css │ ├─fonts │ ├─img │ └─js └─ulb_manager └─__pycache__ Vue-CLI3.x在打包时不会生成static文件 使用vue ui，导入Vue项目，在配置/基础配置/ 修改资源目录 为static 这样在进行打包就会生成static文件 使用Django的通用视图 TemplateView找到项目根urls.py(ulb_manager/urls.py)，使用通用视图创建最简单的模板控制器，访问 『/』时直接返回index.html urlpatterns = [ path('admin/', admin.site.urls), path('', TemplateView.as_view(template_name=\"index.html\")), path('api/', include('backend.urls')) ] 配置Django项目的模板搜索路径上一步使用了Django的模板系统，所以需要配置一下模板使Django知道从哪里找到index.html 打开 settings.py (ulb_manager/settings.py)，找到TEMPLATES配置项，修改如下: TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 'DIRS': [], **'DIRS': ['vue-fonter/dist']**, 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 注意这里的vue-fonter是VueJS项目目录，dist则是运行 npm run build构建出的index.html与静态文件夹static 的父级目录 这时启动Django项目，访问/则可以访问index.html，但是还有问题，静态文件都是404错误，下一步我们解决这个问题 配置静态文件搜索路径打开 settings.py (ulb_manager/settings.py)，找到STATICFILES_DIRS 配置项，配置如下: # Add for vuejs STATICFILES_DIRS = [ os.path.join(BASE_DIR, \"vue-fonter/dist/static\"), ] 这样Django不仅可以将/ 映射到index.html，而且还可以顺利找到静态文件 backend 配置在backend中创建urls from django.urls import path from . import views urlpatterns = [ path('books/', view = views.books, name=\"books\") ] 在backend/views.py中 from django.shortcuts import render from django.http.response import JsonResponse # Create your views here. def books(request): books = [ {'id': 1, 'title': \"python\", \"price\": 89} ] return JsonResponse(books, safe=False) 此时访问/我们可以看到使用Django作为后端的VueJS前端,访问/api/books我们可以看到json数据 解决开发时的跨域问题使用corsheaders pip install corsheaders 在setting.py中加入 INSTALLED_APPS = [ //... 'corsheaders', ] MIDDLEWARE = [ //...... 'corsheaders.middleware.CorsMiddleware', # 添加cors，在第三行，位置不能改 'django.middleware.common.CommonMiddleware', ] CORS_ORIGIN_ALLOW_ALL = True # 允许请求携带cookies CORS_ALLOW_CREDENTIALS= True 以上是从网上找的解决方法，但是并没有解决问题， 先看一下同源的定义 同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 vue启动server是的ip是192.168.0.100:8080，django启动服务时的ip是127.0.0.1:8000， 试着修改了一下django的启动ip 在setting.py中加入 ALLOWED_HOSTS = [ '192.168.0.100', '127.0.0.1', '0.0.0.0', 'localhost', ] 然后启动 django ./manage.py runserver 192.168.0.100:8888 然后启动vue npm run serve 这时不在出现跨域问题 成功！ 开发模式利用vscode 写前端vue，pycharm写django后端 ，调试时pycharm打开django服务，vscode 打开vue，","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://orzff.cn/tags/Django/"},{"name":"Vue","slug":"Vue","permalink":"http://orzff.cn/tags/Vue/"}]},{"title":"Django+Vue+Nginx+uWSGI部署","slug":"Django-Vue-Nginx-uWSGI部署","date":"2020-12-24T08:02:06.000Z","updated":"2021-05-31T11:58:01.133Z","comments":true,"path":"/1ae14b31/","link":"","permalink":"http://orzff.cn/1ae14b31/","excerpt":"使用Django+Vue+Nginx+uWSGI部署网页的前端和后台服务器","text":"Django+Vue+Nginx+uWSGI部署参考 准备工作ip:123.56.252.111 vue: dist django: django_server ├── backend │ ├── admin.py │ ├── apps.py │ ├── __init__.py │ ├── migrations │ │ └── __init__.py │ ├── models.py │ ├── __pycache__ │ │ ├── __init__.cpython-39.pyc │ │ ├── urls.cpython-39.pyc │ │ └── views.cpython-39.pyc │ ├── tests.py │ ├── urls.py │ └── views.py ├── db.sqlite3 ├── element-test │ └── dist │ ├── header.ico │ ├── index.html │ └── static │ ├── css │ ├── fonts │ ├── img │ └── js ├── manage.py ├── media ├── mysite │ ├── asgi.py │ ├── __init__.py │ ├── __pycache__ │ │ ├── __init__.cpython-39.pyc │ │ ├── settings.cpython-39.pyc │ │ ├── urls.cpython-39.pyc │ │ └── wsgi.cpython-39.pyc │ ├── settings.py │ ├── urls.py │ └── wsgi.py ├── static │ ├── admin │ ├── css │ ├── fonts │ ├── img │ └── js ├── test.py ├── uwsgi.ini ├── uwsgi.log ├── uwsgi_nginx.sock └── uwsgi.pid 虚拟环境在服务器配置有详细介绍 Django在服务器配置有详细介绍 uWSGI安装uWSGIpip install uwsgi 简单测试一下创建test.py # test.py def application(env, start_response): start_response('200 OK', [('Content-Type','text/html')]) return [b\"Hello World\"] # python3 #return [\"Hello World\"] # python2 运行 uWSGI: uwsgi --http :8000 --wsgi-file test.py 选项的含义： http :8000 使用http 协议，8000端口。 wsgi-file test.py 使用test.py 作为与 uWSGI交互的文件。 访问 123.56.252.111:8000，输出“Hello World”，说明该程序是这么工作的： graph LR; 客户端 --http:8000--&gt; uWSGI uWSGI --&gt; Python 测试Django测试django在创建的django目录，执行 python manage.py runserver 0.0.0.0:8000 先将IP设置下ALLOWHOSTS中 在服务器配置有详细介绍 在浏览器输入123.56.255.111:8000即出现django欢迎界面 测试uWSGIuwsgi --http :8000 --module mysite.wsgi 在浏览器输入123.56.255.111:8000出现Internal Server Error属于正常现象，因为没有资源 graph LR; 客户端 --http:8000--&gt; uWSGI uWSGI --&gt; Djano Nginx安装nginx在服务器配置有详细介绍 启动nginx#centos 7 systemctl start nginx 在浏览器输入123.56.255.111:80出现CenOS或Nginx的欢迎界面 配置nginx开启这三个端口： 80端口 显示Nginx欢迎界面，测试Nginx是否能正常运行 8000端口 Nginx接收请求的端口，自行处理静态请求，动态请求则转发给uWSGI的8001端口处理 8001端口 uWSGI接收动态请求的端口，处理完毕后将处理结果发给Nginx的8000端口 检查一下是否有uwsgi_params文件（后面的配置文件需要用到），它应该在nginx的目录里（/etc/nginx/），如果没有，可以点击这里下载。 创建/etc/nginx/sites-available的目录，在目录里创建support_center_nginx.conf配置文件进行配置： # support_center_nginx.conf # the upstream component nginx needs to connect to upstream django { server 127.0.0.1:8001; # for a web port socket (we'll use this first) } # configuration of the server server { # the port your site will be served on listen 8000; # the domain name it will serve for server_name 123.56.252.111; # substitute your machine's IP address or FQDN charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Django media location /media { alias /root/mysite/media; # your Django project's media files - amend as required } location /static { alias /root/mysite/static; # your Django project's static files - amend as required } # Finally, send all non-media requests to the Django server. location / { uwsgi_pass django; include /etc/nginx/uwsgi_params; # the uwsgi_params file you installed } 创建一个软链接(/etc/nginx/sites-enabled)指向它： ln -s /etc/nginx/sites-available /etc/nginx/sites-enabled 在/etc/nginx/nginx.conf中将该文件夹包含进去，使得Nginx启动时，能够将文件夹中配置的项目运行起来：include /etc/nginx/sites-enabled/*.conf 注意，这个语句添加在http中，server外 http { server { listen 8888; # listen [::]:80 default_server; server_name _; # root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { root /root/mysite/element-test/dist; try_files $uri $uri/ @router; index index.html index.htm; } location @router{ rewrite ^.*$ /index.html last; } error_page 404 /404.html; location = /404.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } include /etc/nginx/sites-enabled/*.conf; } 处理静态文件运行Nginx之前，得先把Django的静态文件集中到一个文件夹中（该文件夹就是STATIC_ROOT的值）：先向settings.py中添加： STATIC_ROOT = '/root/mysite/static' 然后，将静态资源集中： python manage.py collectstatic nginx测试systemctl restart nginx 向media文件夹中放一张图media.jpg用于测试， media的位置在上面support_center_nginx.conf中的location /media的指定位置 在浏览器输入123.56.255.111:8000/media/picture.png出现一张图片 graph LR; 客户端 --http--&gt; Nginx Nginx --uwsgi--&gt; uWSGI uWSGI --&gt; Python 使用.ini对uWSGI进行设置创建uwsgi.ini [uwsgi] # 项目路径 chdir = /root/mysite #django的wsgi文件路径 wsgi-file = /root/mysite/wsgi.py # 使用mmcsite.wsgi模块 module = mysite.wsgi # 虚拟环境的路径 home = /root/Envs/Django # 启用master master = true # 启动五个进程 processes = 10 # 每个进程启动30个线程 threads = 30 # 指定socket监听的地址和端口 socket = 0.0.0.0:8001 # socket权限 chmod-socket = 666 # 结束后清理环境 vacuum = true # 日志文件 daemonize = /root/mysite/uwsgi.log # pid文件 pidfile = /root/mysite/uwsgi.pid # 允许用内嵌的语言启动线程，这将允许你在app程序中产生一个子线程 enable-threads = true 然后，启动 uWSGI uwsgi --ini uwsgi.ini 转发80端口将/etc/nginx/sites-available/support_center_nginx.conf重命名/etc/nginx/sites-available/nginx_backend.conf cd /etc/nginx/sites-available/ mv support_center_nginx.conf nginx_backend.conf` 新建一个文件/etc/nginx/sites-available/nginx_fonter.conf vim nginx_fonter.conf 在文件中加入 server { # 监听端口 listen 8888; #ip server_name 123.56.252.111; # 编码规则 charset utf-8; client_max_body_size 75M; # 主页面内容， # root：指向vue的dist文件 # try_files：使用vue内部的路由转发 # index： location / { root /root/mysite/element-test/dist; try_files $uri $uri/ @router; index index.html index.htm; } location @router { rewrite ^.*$ /index.html last; } error_page 404 /404.html; location = /404.html{ } error_page 500 502 503 504 /50x.html; location = /50x.html{ } } 修改/etc/nginx/nginx.conf http { server { listen 8888; # listen [::]:80 default_server; server_name _; # root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { proxy_set_header Host $host:$server_port; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Connection \"\"; proxy_set_header X-Nginx-Proxy true; proxy_pass http://123.56.252.111:8888/; } location @router{ rewrite ^.*$ /index.html last; } error_page 404 /404.html; location = /404.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } include /etc/nginx/sites-enabled/*.conf; } 简单说下这样做的目的： 客户的所有请求都是通80端口，与默认端口通信是不需要加:80的，nginx从80端口接收到浏览器的请求，转发到8888端口，8888接收到在/etc/nginx/sites-available/fonter.conf文件处理 后端界面客户不会主动访问所以不用转发来隐藏端口， /etc/nginx/sites-available/fonter.conf 和 /etc/nginx/sites-available/nginx_backend.conf，都在 /etc/nginx/sites-available中，通过软连接/etc/nginx/sites-enabled在/etc/nginx/nginx.conf中的include /etc/nginx/sites-enabled/*.conf;导入nginx.conf文件,与主配置文件分离","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://orzff.cn/tags/Django/"},{"name":"Vue","slug":"Vue","permalink":"http://orzff.cn/tags/Vue/"},{"name":"Nginx","slug":"Nginx","permalink":"http://orzff.cn/tags/Nginx/"}]},{"title":"服务器配置","slug":"服务器配置","date":"2020-12-23T12:13:41.000Z","updated":"2021-05-31T11:58:01.201Z","comments":true,"path":"/7dfc688d/","link":"","permalink":"http://orzff.cn/7dfc688d/","excerpt":"服务器配置","text":"centos安装python3参考 centos下安装python3详细教程1.python位置使用whereis python得到python位置 [root@iz2ze3g6pyat2fqpma7zdvz django_test]# whereis python python: /usr/bin/python /usr/bin/python.config /usr/bin/python2.7 /usr/bin/python.bak /usr/bin/python2.7-config /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz 得到python的位置在 /usr/bin目录 [root@iz2ze3g6pyat2fqpma7zdvz ~]# cd /usr/bin [root@iz2ze3g6pyat2fqpma7zdvz bin]# ll python* lrwxrwxrwx 1 root root 32 Dec 22 19:40 python -&gt; /usr/local/python3/bin/python3.9 lrwxrwxrwx 1 root root 9 Dec 22 18:30 python2 -&gt; python2.7 -rwxr-xr-x 1 root root 7144 Nov 17 06:23 python2.7 -rwxr-xr-x 1 root root 1835 Nov 17 06:23 python2.7-config lrwxrwxrwx 1 root root 16 Dec 22 18:30 python2-config -&gt; python2.7-config lrwxrwxrwx 1 root root 32 Dec 23 18:43 python3 -&gt; /usr/local/python3/bin/python3.9 lrwxrwxrwx 1 root root 7 Dec 22 18:30 python.bak -&gt; python2 lrwxrwxrwx 1 root root 39 Dec 22 19:36 python.config -&gt; /usr/local/python3/bin/python3.9-config lrwxrwxrwx 1 root root 14 Dec 22 18:30 python-config.bak -&gt; python2-config python_django: total 20 drwxr-xr-x 2 root root 4096 Dec 23 15:33 bin drwxr-xr-x 2 root root 4096 Dec 23 15:33 include drwxr-xr-x 3 root root 4096 Dec 23 15:33 lib drwxr-xr-x 3 root root 4096 Dec 23 15:33 lib64 -rw-r--r-- 1 root root 201 Dec 23 15:33 pyvenv.cfg 进入/usr/bin目录使用ll python*我们可以得到python的各种版本 -&gt;是软连接，意味这个文件是后面文件的软链接，这个python也可以看成命令 2 python3的依赖yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make 3 安装pipcentos7没有安装pip #运行这个命令添加epel扩展源 yum -y install epel-release #安装pip yum install python-pip 4 用pip安装wgetpip install wget 5 用wget下载python3在官网找到想要的版本链接 wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz 6 编译python3源码包#解压 xz -d Python-3.6.4.tar.xz tar -xf Python-3.6.4.tar #进入解压后的目录，依次执行下面命令进行手动编译 cd Python-3.6.4 ./configure prefix=/usr/local/python3 make &amp;&amp; make install # 如果出现can't decompress data; zlib not available这个错误，则需要安装相关库 #安装依赖zlib、zlib-devel yum install zlib zlib yum install zlib zlib-devel 7 添加软连接#将原来的链接备份 mv /usr/bin/python /usr/bin/python.bak #添加python3的软链接 ln -s /usr/local/python3/bin/python3.6 /usr/bin/python #测试是否安装成功了 python -V 如果本身没有python3的软链接，可以再 ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3 8 更改yum配置因为yum使用python2，所以需要更改一个yum的配置 vi /usr/bin/yum 把#! /usr/bin/python修改为#! /usr/bin/python2 vi /usr/libexec/urlgrabber-ext-down 把#! /usr/bin/python 修改为#! /usr/bin/python2 virtualenv和virtualenvwrapperpython虚拟环境 简单点说python的虚拟环境就是给每个项目一个独立的python配置，各个项目之间的配置不影响， 1 下载virtualenvpip install virtualenv 2 创建新项目virtualenv env 3 使用虚拟环境source env/bin/activate 4 退出虚拟环境deactivate 5 virtualenvwrapper安装virtualenvwrapper 可以对虚拟环境进行集中管理 pip install virtualenvwrapper 6 添加~/.bashrc在~/.bashrc添加 export WORKON_HOME=~/Envs source /usr/local/bin/virtualenvwrapper.sh 读入配置文件 source ~/.bashrc #读入配置文件，立即生效 7 virtualenvwrapper基本使用 创建虚拟环境 mkvirtualenv mkvirtualenv venv 这样会在WORKON_HOME变量指定的目录下新建名为venv的虚拟环境。 指定python版本 --python指定python解释器 mkvirtualenv --python=/usr/local/python3.5.3/bin/python venv 查看当前虚拟环境目录 workon 切换到虚拟环境 workon xxx 退出虚拟环境 deactivate 删除虚拟环境 rmvirtualenv xxx 8 出错处理出现 ModuleNotFoundError: No module named '_ctypes' 安装libffi-devel yum install libffi-devel -y 重装python 使用make &amp;&amp; make install django1 下载使用pip install django 2 创建django项目django-admin startproject xxx 3 启动djangopython manage.py runserver 0.0.0.0:80 4 配置文件进入setting.py文件 在allowHost中添加自己的ip ALLOWED_HOSTS = [ '123.56.252.111', 'localhost', '0.0.0.0:8000', '127.0.0.1' ] 这样在运行后就可以用http://123.56.252.111:8000/来访问 5 报错处理参考 出现 django.core.exceptions.ImproperlyConfigured: SQLite 3.8.3 or later is required (found 3.7.17). 在官网找到想要版本的链接 使用wget下载 #链接最好重新获取，否则可能不是最新版本 wget https://www.sqlite.org/2019/sqlite-autoconf-3300100.tar.gz 解压安装 [root@localhost home]# tar zxvf sqlite-autoconf-3300100.tar.gz [root@localhost home]# cd sqlite-autoconf-3300100/ [root@localhost sqlite-autoconf-3300100]# ./configure [root@localhost sqlite-autoconf-3300100]# make &amp; make install 查看版本 #检查新安装的sqlite3版本 [root@localhost home]# /usr/local/bin/sqlite3 --version 3.30.1 2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b #检查旧的sqlite3版本 [root@localhost home]# /usr/bin/sqlite3 --version 3.7.17 2013-05-20 00:56:22 118a3b35693b134d56ebd780123b7fd6f1497668 # 把旧的sqlite3改个名字 [root@localhost home]# mv /usr/bin/sqlite3 /usr/bin/sqlite3_old # 设置软链接 [root@localhost home]# ln -s /usr/local/bin/sqlite3 /usr/bin/sqlite3 #查看sqlite3版本 [root@localhost home]# sqlite3 --version 3.30.1 2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b 添加到bashrc文件 在~/.bashrc中添加 export LD_LIBRARY_PATH=\"/usr/local/lib\" 检查sqlite3版本 [root@localhost home]# python3 Python 3.6.5 (default, Jul 9 2019, 20:03:55) [GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; import sqlite3 &gt;&gt;&gt; sqlite3.sqlite_version '3.30.1' &gt;&gt;&gt; exit() [root@localhost home]# nginx参考 1 安装添加Nginx 存储库 sudo yum -y install epel-release 安装nginx sudo yum -y install nginx 2 启动启动nginx sudo systemctl start nginx 3 防火墙允许http通信 sudo firewall-cmd --permanent --zone=public --add-service=http 允许https通信 sudo firewall-cmd --permanent --zone=public --add-service=https 重启防火墙 sudo firewall-cmd --reload 4 测试在浏览器输入地址 5 卸载停止nginx service nginx stop // centos 7 sysyemcyl stop nginx 删除自启动 chkconfig nginx off 从源头删除nginx rm -rf /usr/sbin/nginx rm -rf /etc/nginx rm -rf /etc/init.d/nginx 使用yum清理 yum remove nginx 修改root@后面的名字centos7 hostnamectl set-hostname dhl # hostname #查看 vim /etc/hosts # 编辑hosts文件，给127.0.0.1添加hostname 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 dhl 重启shell生效","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://orzff.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"服务器与本地传输文件","slug":"服务器与本地传输文件","date":"2020-12-20T10:18:22.000Z","updated":"2021-05-31T11:58:01.188Z","comments":true,"path":"/7ff886e9/","link":"","permalink":"http://orzff.cn/7ff886e9/","excerpt":"服务器与本地传输文件","text":"SCP首先确保服务器与本地通过ssh能进行链接，确保有scp 传输 远程拷贝文件 scp 本地文件 远程服务器用户名@远程服务器ip地址：指定拷贝到远程服务器路径 scp 远程服务器用户名@远程服务器ip地址：远程服务器文件 指定拷贝到本地电脑的路径 远程拷贝目录 scp -r本地文件 远程服务器用户名@远程服务器ip地址：指定拷贝到远程服务器路径 scp -r 远程服务器用户名@远程服务器ip地址：远程服务器文件 指定拷贝到本地电脑的路径 -r 表示递归拷贝整个目录 传输文件至服务器 scp 1.txt root@123.56.252.111:/root 从服务器拷贝目录 scp -r root@123.56.252.111:/root/select_test C:/Users/64371/Desktop","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://orzff.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"爬取wallpaper图片","slug":"爬取wallpaper图片","date":"2020-12-07T06:21:42.000Z","updated":"2021-05-31T11:58:01.203Z","comments":true,"path":"/2514ad2c/","link":"","permalink":"http://orzff.cn/2514ad2c/","excerpt":"爬取wallpaper图片","text":"1. user_agent_list这里是从网上获得的user_agent列表， 稍加修改就可以了 import random # 返回一个随机的请求头 headers def getheaders(): # 各种PC端 user_agent_list_2 = [ # Opera \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60\", \"Opera/8.0 (Windows NT 5.1; U; en)\", \"Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50\", # Firefox \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0\", \"Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10\", # Safari \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2\", # chrome \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16\", # 360 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36\", \"Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko\", # 淘宝浏览器 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11\", # 猎豹浏览器 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)\", # QQ浏览器 \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", # sogou浏览器 \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)\", # maxthon浏览器 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Maxthon/4.4.3.4000 Chrome/30.0.1599.101 Safari/537.36\", # UC浏览器 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36\", ] # 各种移动端 user_agent_list_3 = [ # IPhone \"Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", # IPod \"Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", # IPAD \"Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5\", \"Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", # Android \"Mozilla/5.0 (Linux; U; Android 2.2.1; zh-cn; HTC_Wildfire_A3333 Build/FRG83D) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", \"Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", # QQ浏览器 Android版本 \"MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", # Android Opera Mobile \"Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10\", # Android Pad Moto Xoom \"Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13\", # BlackBerry \"Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+\", # WebOS HP Touchpad \"Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0\", # Nokia N97 \"Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124\", # Windows Phone Mango \"Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)\", # UC浏览器 \"UCWEB7.0.2.37/28/999\", \"NOKIA5700/ UCWEB7.0.2.37/28/999\", # UCOpenwave \"Openwave/ UCWEB7.0.2.37/28/999\", # UC Opera \"Mozilla/4.0 (compatible; MSIE 6.0; ) Opera/UCWEB7.0.2.37/28/999\" ] # 一部分 PC端的 user_agent_list_1 = [ \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\", \"Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\" ] user_agent_list = user_agent_list_1 + user_agent_list_2 + user_agent_list_3; UserAgent = random.choice(user_agent_list) header = {\"User-Agent\": UserAgent} return header 2.免费代理这里只是列举了几个免费代理的网站，从上面爬取ip:port 和类型组装成字典输出即可 import requests import user_agent_list import re import random class SpiderProxy(): def __init__(self): self.url = [\"https://www.kuaidaili.com/free/inha/1/\", \"https://www.7yip.cn/free/?action=china&amp;page=2\", \"https://www.7yip.cn/free/?action=china&amp;page=3\", ] self.header = user_agent_list.getheaders() self.proxy = {} self.proxies_list = [] self.run() def get_proxies_list(self, url): try: response = requests.get(url, headers=self.header, timeout=3) response_data = response.content.decode('utf-8') ip_list = re.findall(r'&lt;td data-title=\"IP\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) port_list = re.findall(r'&lt;td data-title=\"PORT\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) type_list = re.findall(r'&lt;td data-title=\"类型\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) for index in range(len(ip_list)): self.proxies_list.append(\"{\\'%s\\':\\'%s:%s\\'}\" % (type_list[index], ip_list[index], port_list[index])) except Exception as e: print(e) # for tmp_proxy in tmp_list: # proxy = eval(tmp_proxy) # response = requests.get(\"www.baidu.com\", headers=self.header, proxies=proxy) # if response.status_code == 200: # self.proxies_list.append(tmp_proxy) def get_proxy(self): while 1: try: self.proxy = eval(random.choice(self.proxies_list)) response = requests.get(\"http://www.baidu.com\", headers=self.header, proxies=self.proxy, timeout=3) if response.status_code == 200: return except Exception as e: print(\"getProxy ------&gt; ERROR\", e) def run(self): for url in self.url: self.get_proxies_list(url) 3. loopRequests自己封装的循环访问的方法，可以解决部分网络延迟问题 在使用代理方面，每50次访问就更换代理，避免被封IP import requests import spider_proxy import time class LoopRequest(): def __init__(self): self.proxies = spider_proxy.SpiderProxy() self.count = 50 def get(self, url, **args): return self.request('GET', url, **args) def post(self, url, **args): return self.request('POST', url, **args) def get_proxy(self): if self.count &lt;= 0: self.proxies.get_proxy() self.count = 50 self.count -= 1 def request(self, method, url, **args): self.get_proxy() args['headers'] = self.proxies.header args['proxies'] = self.proxies.proxy args['timeout'] = 5 args['verify'] = False loop = 50 while loop: try: print(\"loopRequest: %s 第 %s 次尝试\" % (url, 51-loop)) requests.packages.urllib3.disable_warnings() response = requests.request(method, url, **args) print(\"loopRequest: %s 链接成功\" % url) return response except Exception as e: print(\"loopRequest: \" + e) time.sleep(5) if loop == 0: return \"get error\" loop -= 1 request = LoopRequest() 4. cookie由于wallpaper登录以后可以看到更多图片，所以这里要模仿登录来拿到cookie session在这里并不能起到很好的效果，所以直接使用cookie来模拟登录 详细信息挫这里: wallpaper 模拟登录 | Mug-9’s blog (orzff.cn) import requests import re import loopRequest class SpiderCookies(): def __init__(self): self.get_url = \"https://wallhaven.cc/login\" self.post_url = \"https://wallhaven.cc/auth/login\" self.request = loopRequest.request self.data = {} self._token = \"\" self.cookies = {} self.Is = False self.update() # 1. 请求页面获得_token 和 cookie def get_html(self): response = self.request.get(self.get_url) response_data = response.content.decode('utf-8') self._token = re.findall(r'&lt;meta name=\"csrf-token\" content=\"(.*?)\"&gt;', response_data, re.S) cookies = \"\" for cookie in response.cookies: cookies += cookie.name + \"=\" + cookie.value + \";\" # 用header来携带cookie self.request.proxies.header['Cookie'] = cookies # 2.装填data def combined_data(self): self.data = { '_token': self._token, 'username': '643719884@qq.com', 'password': 'dhl643719884' } # 3. 组装cookie def combined_cookie(self): response = self.request.post(self.post_url, data=self.data) # 这里拿到的cookie是相对比较齐全的cookie，主要用这个cookie来组装 post_cookies = response.request.headers['Cookie'] post_cookies_list = post_cookies.split(\"; \") # 这里cookie只要__cfduid temp_cookie = self.request.proxies.header['Cookie'] temp_cookie_list = temp_cookie.split(\";\") # 组装 self.cookies.update(__cfduid = temp_cookie_list[0].split('=')[1]) for cookie in post_cookies_list: self.cookies[cookie.split('=')[0]] = cookie.split('=')[1] # header pop掉Cookie self.request.proxies.header.pop('Cookie') # 4.登录 def post_html(self): response = self.request.get(self.post_url, cookies=self.cookies) response_data = response.content.decode('utf-8') if response.status_code == 200: print(\"WallPaper: Cookies获取成功\") self.Is = True else: print(\"WallPaper: Cookies获取失败\") def update(self): self.get_html() self.combined_data() self.combined_cookie() self.post_html() 5. spider 图片5.1 先获取页面上所有图片二级页面的url# 1. 获取页面信息,获取每张战片所在页面的url def get_html(self, url): response = self.request.get(url, cookies=self.cookies.cookies) response_data = response.content.decode('utf-8') href_list = re.findall(r'&lt;a class=\"preview\" href=\"(.*?)\" target=\"_blank\" &gt;&lt;/a&gt;', response_data, re.S) return href_list 5.2 对于每张图片页面，获取每张图片的页面使用etree+xpath即可拿到每张图片的url 为防止网络问题，这里进行了5次重复 # 2. 进入页面 获取图片的url def get_img_url(self, url): loop = 5 img_url = [] while loop: response = self.request.get(url) response_data = response.content.decode('utf-8') response_html = etree.HTML(response_data) img_url = response_html.xpath('//*[@id=\"wallpaper\"]/@src') if len(img_url): return img_url loop -= 1 self.error_log.write(url) print(url, \"ERROR\") return img_url 5.3 下载下载到本地E:\\picture\\当天日期 检查本地log看是否已存在相同图片 # 3. 下载 def img_download(self, url): with self.sem: img_name = url.split('/')[-1] if self.file_check(img_name): print(\"---%s 已存在\" % img_name) return picture_mkdir = \"E:\\\\picture\" if not os.path.exists(picture_mkdir): os.mkdir(picture_mkdir) os.chdir(picture_mkdir) data_mkdir = \"%s\\\\%s\" % (picture_mkdir, datetime.date.today()) if not os.path.exists(data_mkdir): os.mkdir(data_mkdir) os.chdir(data_mkdir) response = self.request.get(url) response_data = response.content print(\"---%s 开始写入\" % img_name) threadLock.acquire() with open(\"%s\" % img_name, \"wb\") as f: f.write(response_data) threadLock.release() print(\"---%s 写入完毕 -- count: %s\" % (img_name, self.count)) threadLock.acquire() self.download_log.write(img_name) self.count -= 1 threadLock.release() 5.4 检查本地log检查看是否已存在图片 # 4. 本地log def file_check(self, img_name): threadLock.acquire() self.download_log.seek(0, 0) file_content = self.download_log.read() threadLock.release() if img_name in file_content: return True else: return False 5.5 run计划每次下载100张图片，网页页数从2-100 # 6.run def run(self): loop = 50 while loop: if self.cookies.Is: break else: self.cookies.update() time.sleep(2) loop -= 1 if loop &lt;= 0: self.error_log.write(\"Cookies 获得失败\") return for i in range(2, 100): url = \"%s%s\" % (self.url, i) href_list = self.get_html(url) for html_url in href_list: img_url = self.get_img_url(html_url) if len(img_url) and self.count &gt; 0: threading.Thread(target=self.img_download, args=(img_url[0],)).start() 6. github地址Mug-9/Python-Spider: Spider (github.com)","categories":[{"name":"Spider","slug":"Spider","permalink":"http://orzff.cn/categories/Spider/"},{"name":"小项目","slug":"Spider/小项目","permalink":"http://orzff.cn/categories/Spider/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"爬图片","slug":"爬图片","permalink":"http://orzff.cn/tags/%E7%88%AC%E5%9B%BE%E7%89%87/"}]},{"title":"python 生成requirements.txt","slug":"python-生成requirements-txt","date":"2020-12-06T02:49:16.000Z","updated":"2021-05-31T11:58:01.158Z","comments":true,"path":"/3d982a67/","link":"","permalink":"http://orzff.cn/3d982a67/","excerpt":"python 生成requirements.txt","text":"生成requirements在要生成requirements的目录的控制台输入 pip freeze &gt; requirements.txt 安装requirement要根据requirements安装时，在控制台输入 pip install -r requirements.txt","categories":[{"name":"Python","slug":"Python","permalink":"http://orzff.cn/categories/Python/"}],"tags":[{"name":"requirements","slug":"requirements","permalink":"http://orzff.cn/tags/requirements/"}]},{"title":"gitee和github同步更新","slug":"码云和github同步更新","date":"2020-12-05T16:44:13.000Z","updated":"2021-05-31T11:58:01.223Z","comments":true,"path":"/2d45259f/","link":"","permalink":"http://orzff.cn/2d45259f/","excerpt":"gitee和github同步更新","text":"码云由于众所周知的原因，在github上clone很慢，所以采用码云来加速clone 1 在码云上导入github项目 2 修改configgit clone到本地，在视图中显示隐藏项目，进入.git找到config 3 加上github的链接由于是在gitee上clone的项目，所以在config中只有gitee的链接，在github链接下面加上gitee的链接 注意： 一定是github下面加gitee的链接 成功这样就可以在push的时候同时更新了","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"github","slug":"github","permalink":"http://orzff.cn/tags/github/"},{"name":"gitee","slug":"gitee","permalink":"http://orzff.cn/tags/gitee/"}]},{"title":"win10 terminal 配置","slug":"win10-terminal-配置","date":"2020-12-04T15:29:20.000Z","updated":"2021-05-31T11:58:01.178Z","comments":true,"path":"/e96d644/","link":"","permalink":"http://orzff.cn/e96d644/","excerpt":"win10 terminal 配置","text":"主题配置// This file was initially generated by Windows Terminal 1.4.3243.0 // It should still be usable in newer versions, but newer versions might have additional // settings, help text, or changes that you will not see unless you clear this file // and let us generate a new one for you. // To view the default settings, hold \"alt\" while clicking on the \"Settings\" button. // For documentation on these settings, see: https://aka.ms/terminal-documentation { \"$schema\": \"https://aka.ms/terminal-profiles-schema\", \"defaultProfile\": \"{574e775e-4f2a-5b96-ac1e-a2962a402336}\", // You can add more global application settings here. // To learn more about global settings, visit https://aka.ms/terminal-global-settings // If enabled, selections are automatically copied to your clipboard. \"copyOnSelect\": false, // If enabled, formatted data is also copied to your clipboard \"copyFormatting\": false, \"tabWidthMode\": \"equal\", \"theme\": \"light\", // A profile specifies a command to execute paired with information about how it should look and feel. // Each one of them will appear in the 'New Tab' dropdown, // and can be invoked from the commandline with `wt.exe -p xxx` // To learn more about profiles, visit https://aka.ms/terminal-profile-settings \"profiles\": { \"defaults\": { // Put settings here that you want to apply to all profiles. \"fontFace\": \"CaskaydiaCove NF\", \"fontSize\": 16, \"cursorShape\": \"filledBox\", }, \"list\": [ { \"guid\": \"{574e775e-4f2a-5b96-ac1e-a2962a402336}\", \"hidden\": false, \"name\": \"PowerShell 7\", \"source\": \"Windows.Terminal.PowershellCore\", \"tabTitle\": \"PowerShell 7\", // morec // 背景图片 \"acrylicOpacity\": 0.5, \"backgroundImage\": \"E:/picture/2020-12-18/wallhaven-o3d3w7.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"useAcrylic\": true, \"padding\": \"0, 0, 0, 0\", // 键入时窗口滚动到输入行 \"snapOnInput\": true, // 打开时的目录 \"startingDirectory\": \".\", // tab标题 \"tabTitle\": \"powershell\", // 使用acrylic \"useAcrylic\": false, //主题 \"colorScheme\": \"Solarized Dark Higher Contrast\", }, { \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\", \"hidden\": false, \"name\": \"PowerShell\", \"commandline\": \"powershell.exe\", \"tabTitle\": \"PowerShell\", // morec // 背景图片 \"acrylicOpacity\": 0.25, \"backgroundImage\": \"E:/picture/2020-12-07/wallhaven-y87dxx.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"padding\": \"0, 0, 0, 0\", // 键入时窗口滚动到输入行 \"snapOnInput\": true, // 打开时的目录 \"startingDirectory\": \".\", // tab标题 \"tabTitle\": \"powershell\", // 使用acrylic \"useAcrylic\": false, //主题 \"colorScheme\": \"Cobalt Neon\", }, { // Make changes here to the cmd.exe profile. \"guid\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\", \"name\": \"Command Prompt\", \"commandline\": \"cmd.exe\", \"hidden\": false, // more \"acrylicOpacity\": 0.25, \"backgroundImage\": \"E:/picture/wallhaven-1kjqdw.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"padding\": \"0, 0, 0, 0\", \"snapOnInput\": true, \"startingDirectory\": \"%USERPROFILE%\", \"tabTitle\": \"cmd\", \"useAcrylic\": false, //主题 \"colorScheme\": \"Thanatos Dark\", }, { // 通过terminal连接服务器 \"guid\": \"{B5F0BC97-C32E-67A0-97E1-6112A50DF336}\", \"name\": \"aliyun\", \"commandline\": \"ssh root@123.56.252.111\", \"acrylicOpacity\": 0.4, \"backgroundImage\": \"E:/picture/2020-12-18/wallhaven-6oq5lq.jpg\", \"backgroundImageOpacity\": 0.4, \"backgroundImagerStretchMode\": \"fill\", \"padding\": \"0, 0, 0, 0\", \"snapOnInput\": true, \"startingDirectory\": \"%USERPROFILE%\", \"tabTitle\": \"aliyun\", \"useAcrylic\": false, \"icon\": \"ms-appx:///ProfileIcons/{9acb9455-ca41-5af7-950f-6bca1bc9722f}.png\", // 图标 //主题 \"colorScheme\": \"Thanatos Dark\", }, { \"guid\": \"{db1d57fc-a9c1-4051-9677-f0232f905f60}\", \"hidden\": false, \"name\": \"Tencent Server\", \"commandline\": \"ssh root@81.71.14.51\", \"icon\": \"ms-appdata:///roaming/TencentServer.png\", // morec // 背景图片 \"acrylicOpacity\": 0.5, \"backgroundImage\": \"E:/picture/2020-12-23/wallhaven-o3dvv9.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"useAcrylic\": true, \"padding\": \"0, 0, 0, 0\", // 键入时窗口滚动到输入行 \"snapOnInput\": true, // 打开时的目录 \"startingDirectory\": \".\", // tab标题 \"tabTitle\": \"powershell\", // 使用acrylic \"useAcrylic\": false, //主题 \"colorScheme\": \"Thanatos Dark\", \"cursorColor\" : \"#FFFFFF\", }, { \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\", \"hidden\": false, \"name\": \"Azure Cloud Shell\", \"source\": \"Windows.Terminal.Azure\" }, ] }, // Add custom color schemes to this array. // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes \"schemes\": [ { \"name\": \"Thanatos Dark\", \"background\" : \"#1a2b3c\", \"foreground\" : \"#e09887\", \"selectionBackground\": \"#fef8ec\", \"black\": \"#65737e\", \"blue\": \"#0e9bd1\", \"brightBlack\": \"#acacac\", \"brightBlue\": \"#7899ba\", \"brightCyan\": \"#0099ad\", \"brightGreen\": \"#0de1b1\", \"brightRed\": \"#d47186\", \"brightWhite\": \"#fef8ec\", \"brightYellow\": \"#d8cb32\", \"brightPurple\": \"#ab43aa\", \"purple\": \"#928ba6\", \"cyan\": \"#008486\", \"green\": \"#0099ad\", \"red\": \"#ce4559\", \"white\": \"#fef8ec\", \"yellow\": \"#d8cb32\" }, { \"name\": \"Cobalt Neon\", \"black\": \"#142631\", \"red\": \"#ff2320\", \"green\": \"#3ba5ff\", \"yellow\": \"#e9e75c\", \"blue\": \"#8ff586\", \"purple\": \"#781aa0\", \"cyan\": \"#8ff586\", \"white\": \"#ba46b2\", \"brightBlack\": \"#fff688\", \"brightRed\": \"#d4312e\", \"brightGreen\": \"#8ff586\", \"brightYellow\": \"#e9f06d\", \"brightBlue\": \"#3c7dd2\", \"brightPurple\": \"#8230a7\", \"brightCyan\": \"#6cbc67\", \"brightWhite\": \"#8ff586\", \"background\": \"#142838\", \"foreground\": \"#8ff586\" }, { \"name\": \"Aurora\", \"black\": \"#23262e\", \"red\": \"#f0266f\", \"green\": \"#8fd46d\", \"yellow\": \"#ffe66d\", \"blue\": \"#0321d7\", \"purple\": \"#ee5d43\", \"cyan\": \"#03d6b8\", \"white\": \"#c74ded\", \"brightBlack\": \"#292e38\", \"brightRed\": \"#f92672\", \"brightGreen\": \"#8fd46d\", \"brightYellow\": \"#ffe66d\", \"brightBlue\": \"#03d6b8\", \"brightPurple\": \"#ee5d43\", \"brightCyan\": \"#03d6b8\", \"brightWhite\": \"#c74ded\", \"background\": \"#23262e\", \"foreground\": \"#ffca28\" }, { \"name\": \"FunForrest\", \"black\": \"#000000\", \"red\": \"#d6262b\", \"green\": \"#919c00\", \"yellow\": \"#be8a13\", \"blue\": \"#4699a3\", \"purple\": \"#8d4331\", \"cyan\": \"#da8213\", \"white\": \"#ddc265\", \"brightBlack\": \"#7f6a55\", \"brightRed\": \"#e55a1c\", \"brightGreen\": \"#bfc65a\", \"brightYellow\": \"#ffcb1b\", \"brightBlue\": \"#7cc9cf\", \"brightPurple\": \"#d26349\", \"brightCyan\": \"#e6a96b\", \"brightWhite\": \"#ffeaa3\", \"background\": \"#251200\", \"foreground\": \"#dec165\" }, { \"name\": \"Solarized Dark Higher Contrast\", \"black\": \"#002831\", \"red\": \"#d11c24\", \"green\": \"#6cbe6c\", \"yellow\": \"#a57706\", \"blue\": \"#2176c7\", \"purple\": \"#c61c6f\", \"cyan\": \"#259286\", \"white\": \"#eae3cb\", \"brightBlack\": \"#006488\", \"brightRed\": \"#f5163b\", \"brightGreen\": \"#51ef84\", \"brightYellow\": \"#b27e28\", \"brightBlue\": \"#178ec8\", \"brightPurple\": \"#e24d8e\", \"brightCyan\": \"#00b39e\", \"brightWhite\": \"#fcf4dc\", \"background\": \"#142838\", \"foreground\": \"#9cc2c3\" } ], // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \"unbound\". // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \"actions\": [ // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json. // These two lines additionally bind them to Ctrl+C and Ctrl+V. // To learn more about selection, visit https://aka.ms/terminal-selection { \"command\": {\"action\": \"copy\", \"singleLine\": false }, \"keys\": \"ctrl+c\" }, { \"command\": \"paste\", \"keys\": \"ctrl+v\" }, // Press Ctrl+Shift+F to open the search box { \"command\": \"find\", \"keys\": \"ctrl+shift+f\" }, // Press Alt+Shift+D to open a new pane. // - \"split\": \"auto\" makes this pane open in the direction that provides the most surface area. // - \"splitMode\": \"duplicate\" makes the new pane use the focused pane's profile. // To learn more about panes, visit https://aka.ms/terminal-panes { \"command\": { \"action\": \"splitPane\", \"split\": \"auto\", \"splitMode\": \"duplicate\" }, \"keys\": \"alt+shift+d\" } ] } cmd 连接服务器客户端生成ssh公私钥ssh-keygen 本地ssh公钥追加到服务器将id_rsa.pub的内容复制到tmp.pub cd ~ vi tmp.pub mkdir .ssh &amp;&amp; chmod 700 .ssh touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys cat tmp.pub &gt;&gt; .ssh/authorized_keys rm tmp.pub 重启terminal成功！ 解决终端链接服务器长时间不操作卡死在服务器中执行 vim /etc/ssh/sshd_config ClientAliveInterval 60 // 每隔60S向客户端发送请求消息，并等待客户端响应 ClientAliveCountMax 10 // 客户端超过十次没响应，自动断开（即10分钟） //重启sshd服务 //centos6 service ssh restart //centos7 systemctl restart sshd 进入所在用户的.ssh目录, root用户的目录在：/root/.ssh/创建config文件vim /root/.ssh/config在文件中添加：ServerAliveINterval 60(没写错，就是INterval，我也不知道为什么，)保存退出，重新从终端通过ssh进入服务器后不会因为长时间操作断开。 加入这句之后，ssh客户端会每隔一段时间自动与ssh服务器通信一次，所以长时间操作不会断开。 terminal 添加右键检查常量echo %USERPROFILE% echo %LOCALAPPDATA% 获取图标创建Terminal文件夹 mkdir \"%USERPROFILE%\\AppData\\Local\\Terminal\" 保存这个 图标 添加注册表文件新建一个文件 new.reg Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt] @=\"Windows Terminal here\" \"Icon\"=\"%USERPROFILE%\\\\AppData\\\\Local\\\\Terminal\\\\terminal.ico\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command] @=\"C:\\\\Users\\\\[你的电脑用户名！你的电脑用名！]\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe\" @后面的[]改成电脑的用户名 如果第一步USERPROFILE没有东西打印出来，那么这里的USERPROFILE也改成C:\\Users\\你的用户名 第5行时图标保存的地址 执行reg文件，可以发现右键多了一个windows termianl here 当前目录在配置文件中添加或修改 // 打开时的目录 \"startingDirectory\": \".\", 这样也有一个缺点，直接打开termianl时目录为C:\\Windows\\System32目前没有解决方法 PowerShell主题参考 安装oh-my-posh主题在terminal输入 Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser 输入Y同意安装 更新配置文件在terminal输入$PROFILE 得到当前电脑的powershell_profile文件 PS C:\\Windows\\System32&gt; $PROFILE C:\\Users\\64371\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 PS C:\\Windows\\System32&gt; 继续输入 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE 在打开的文件夹中添加 Import-Module posh-git Import-Module oh-my-posh Set-Theme Honukai Set-Theme Honukai是主题设置，其他可选主题 Agnoster、Avit、Darkblood、Fish、Honukai、Paradox、Sorin、tehrob 更新配置 输入你用$PROFILE得到的路径 C:\\Users\\64371\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 有些主题的样式可能会有些小空格，这时因为字体不支持poweline,推荐选择Hack NF字体，支持编程连字和poweline字形 下载链接 我的样式 powershell 5 power shell 7 Centos-terminal 主题参考 查看系统当前shellecho $SHELL 结果 /bin/bash 查看/bin下是否有zsh包 cat /etc/shells ********************************************** 返回的结果是: /bin/sh /bin/bash /sbin/nologin /usr/bin/sh /usr/bin/bash /usr/sbin/nologin PS.默认没有安装zsh 安装zshsudo yum install -y zsh 在/bin下查看 /bin/sh /bin/bash /sbin/nologin /usr/bin/sh /usr/bin/bash /usr/sbin/nologin /bin/zsh 将zsh设置成默认shellchsh -s /bin/zsh 修改zsh为默认shell需要将以前在~/.bashrc中的设置，复制到~/.zshrc中 安装oh-my-zsh需要先装git sudo yum install git 修改host vim /etc/hosts 添加 199.232.28.133 raw.githubusercontent.com 下载 sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 配置主题主题 选择一款主题，修改~/.zshrc vim ~/.zshrc 将ZSH_THEME更改为选择的主题 jonathan 更新配置 source ~/.zshrc 重启 reboot 我的样式 aliyun Centos7 tencent Centos7 管理员在powershell中执行 PowerShell -Command \"Set-ExecutionPolicy RemoteSigned -scope Process; iwr -useb https://raw.githubusercontent.com/gerardog/gsudo/master/installgsudo.ps1 | iex\" 安装过程会询问你是否打算使用sudo作为gsudo的别名，这里可以根据个人需要进行选择。运行结尾显示Done即表明安装完成 安装完成后，在setting.json中添加list { \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\", \"hidden\": false, \"name\": \"PowerShell Administra\", \"commandline\": \"sudo.exe powershell.exe\", \"tabTitle\": \"PowerShell Administra\", // morec // 背景图片 \"acrylicOpacity\": 0.25, \"backgroundImage\": \"E:/picture/2020-12-07/wallhaven-y87dxx.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"padding\": \"0, 0, 0, 0\", // 键入时窗口滚动到输入行 \"snapOnInput\": true, // 打开时的目录 \"startingDirectory\": \".\", // tab标题 \"tabTitle\": \"powershell\", // 使用acrylic \"useAcrylic\": false, //主题 \"colorScheme\": \"Cobalt Neon\", }, 在普通的powershell中执行sudo，也可以升级成管理员","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"win Terminal","slug":"win-Terminal","permalink":"http://orzff.cn/tags/win-Terminal/"}]},{"title":"利用hexo多个设备更新博客","slug":"利用hexo多个设备更新博客","date":"2020-12-04T14:30:57.000Z","updated":"2021-05-31T11:58:01.179Z","comments":true,"path":"/1351aa80/","link":"","permalink":"http://orzff.cn/1351aa80/","excerpt":"利用hexo多个设备更新博客","text":"多台电脑控制一个hexo博客1.下载Git2.下载Node.jsNode.js 版本不要太高 3.新电脑创建新的ssh密钥在Git-bash中 ssh-keygen -t rsa -C 'your_email@example.com' 在github-&gt;setting-&gt;SSH &amp;&amp; GPG keys-&gt;new ssh key 测试是否成功 ssh -T git@github.com 如果出现 Hi username! You've successfully authenticated, but GitHub does not provide shell access. 3.1 设置用户信息$ git config --global user.name \"用户名\" $ git config --global user.email \"你希望的邮箱名\" 4. 资源配置依赖4.1 更换淘宝镜像npm config set registry https://registry.npm.taobao.org npm i -g express 4.2 安装hexonpm install -g hexo-cli 4.3 利用package.json部署资源{ \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": { \"version\": \"3.9.0\" }, \"dependencies\": { \"acorn\": \"^7.1.1\", \"core-js\": \"^3.2.1\", \"dependencies\": \"0.0.1\", \"eslint\": \"^6.6.0\", \"hexo\": \"^3.9.0\", \"hexo-abbrlink\": \"^2.0.5\", \"hexo-asset-image\": \"0.0.1\", \"hexo-deployer-git\": \"^1.0.0\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-feed\": \"^1.2.2\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-json-content\": \"^4.1.6\", \"hexo-generator-searchdb\": \"^1.0.8\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-less\": \"^0.1.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-kramed\": \"^0.1.4\", \"hexo-renderer-less\": \"^1.0.0\", \"hexo-renderer-mathjax\": \"^0.6.0\", \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-server\": \"^0.3.3\", \"hexo-symbols-count-time\": \"^0.6.3\", \"hexo-wordcount\": \"^6.0.1\", \"peer\": \"^0.2.10\" } } npm install 5.hexo提交hexo clean hexo g hexo d","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://orzff.cn/tags/Hexo/"}]},{"title":"vscode 配置Vue","slug":"vscode-配置Vue","date":"2020-11-29T03:20:30.000Z","updated":"2021-05-31T11:58:01.162Z","comments":true,"path":"/9c6f56ad/","link":"","permalink":"http://orzff.cn/9c6f56ad/","excerpt":"vscode 配置Vue","text":"插件Auto Close Tag自动关闭标签 background-cover可以设置壁纸 BetterComments注释可以变颜色，便于区分 默认五种颜色 Bracket Pair Colorizer 2括号匹配并能标颜色 Code Spell Checker检查错误单词，并给出相近单词 EditorConfig fot VS Code让vscode支持.editorconfig文件 .editorconfig文件可以规范编码风格和设置 在项目根目录建立.editorconfig文件[*.{js,jsx,ts,tsx,vue}] indent_style = space indent_size = 2 trim_trailing_whitespace = true insert_final_newline = true ESLint对文件进行校验，并可在保存时自动修复错误 在vscode配置文件中{ // eslint配置项，保存时自动修复错误 \"editor.codeActionsOnSave\": { \"source.fixAll\": true } } 在项目根目录建立.eslintrc.js文件module.exports = { root: true, env: { node: true, }, extends: ['plugin:vue/essential', '@vue/standard'], parserOptions: { parser: 'babel-eslint', }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', }, } Live Server本地预览界面，右键html文件选择Open with Live Seriver Prettier对js html文件格式化 在项目根目录建立.prettierrc文件{ \"semi\": false, \"singleQuote\": true } 在VScode 配置文件中加入// 保存时自动格式化代码 \"editor.formatOnSave\": true, // 默认使用prettier格式化支持的文件 \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", // 指定 *.vue 文件的格式化工具为vetur，防止和prettier冲突 \"[vue]\": { \"editor.defaultFormatter\": \"octref.vetur\" }, // 指定 *.js 文件的格式化工具为vscode自带，以符合ESLint规范 \"[javascript]\": { \"editor.defaultFormatter\": \"vscode.typescript-language-features\" } Vetur代码高亮，代码片段，Emmet语法支持，语法错误校验检查，格式化代码，代码提醒，对第三方UI框架支持 在vscode配置文件中// 将vetur的js格式化工具指定为vscode自带的 \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", // 移除js语句的分号 \"javascript.format.semicolons\": \"remove\", // 在函数名后面加上括号，类似这种形式 foo () {} \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true Eva ThemeEva 主题 我的配置文件{ \"editor.fontFamily\": \"Cascadia Code\", \"editor.fontSize\": 20, \"editor.fontWeight\": \"300\", \"editor.fontLigatures\": true, \"terminal.integrated.fontSize\": 20, \"terminal.integrated.fontWeight\": \"300\", \"terminal.integrated.cursorStyle\": \"underline\", \"debug.console.fontSize\": 18, \"workbench.iconTheme\": \"material-icon-theme\", \"explorer.confirmDelete\": false, \"files.autoSave\": \"onFocusChange\", // 保存时自动格式化代码 \"editor.formatOnSave\": true, // eslint配置项，保存时自动修复错误 \"editor.codeActionsOnSave\": { \"source.fixAll\": true }, // 让vetur使用vs自带的js格式化工具，以便在函数前面加个空格 \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", \"javascript.format.semicolons\": \"remove\", \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true, // 指定 *.vue 文件的格式化工具为vetur \"[vue]\": { \"editor.defaultFormatter\": \"octref.vetur\" }, // 指定 *.js 文件的格式化工具为vscode自带 \"[javascript]\": { \"editor.defaultFormatter\": \"vscode.typescript-language-features\" }, // 默认使用prettier格式化支持的文件 \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", \"better-comments.multilineComments\": true, \"better-comments.highlightPlainText\": false, \"cSpell.enableFiletypes\": [\"vue\", \"vue-html\"], \"workbench.colorTheme\": \"Eva Dark Italic\", \"explorer.confirmDragAndDrop\": false, \"editor.tabSize\": 2, \"backgroundCover.imagePath\": \"e:\\\\picture\\\\2020-12-11\\\\wallhaven-e7ozz8.png\", \"git.confirmSync\": false, \"git.autofetch\": true, \"backgroundCover.randomImageFolder\": \"e:\\\\picture\\\\2020-12-07\", \"backgroundCover.autoStatus\": false, \"backgroundCover.opacity\": 0.5, \"javascript.updateImportsOnFileMove.enabled\": \"always\", \"git.enableSmartCommit\": true, \"window.zoomLevel\": 1 }","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://orzff.cn/tags/Vue/"},{"name":"VSCode","slug":"VSCode","permalink":"http://orzff.cn/tags/VSCode/"}]},{"title":"记录一下利用tcp使得服务器与android客户端相连","slug":"记录一下利用tcp使得服务器与android客户端相连","date":"2020-10-21T14:11:20.000Z","updated":"2021-05-31T11:58:01.223Z","comments":true,"path":"/b4b2d023/","link":"","permalink":"http://orzff.cn/b4b2d023/","excerpt":"记录一下利用tcp使得服务器与android客户端相连","text":"云服务器租一个简单的服务器， 防火墙首先将我们需要的端口打开 firewall-cmd --zone=public --add-port=6666/tcp --permanent # 开放6666端口 firewall-cmd --reload # 配置立即生效 用firewall-cmd --zone=public --list-ports 查看一下是否开启 有时阿里云服务器的端口也得打开，这个自行百度即可。 seriver.c#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;ctype.h&gt; #include &lt;stdlib.h&gt; #define SERV_PORT 6666 char rbuf[1024]; int main() { int sockfd,clientfd, size, ret, on = 1; struct sockaddr_in saddr, raddr; // 设置地址信息，ip信息 size = sizeof(struct sockaddr_in); bzero(&amp;saddr, size); saddr.sin_family = AF_INET; saddr.sin_port = htons(SERV_PORT); saddr.sin_addr.s_addr = htonl(INADDR_ANY); // 创建UDP套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if(sockfd &lt; 0) { perror(\"Socket failed.\"); exit(1); } //设置端口复用 setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)); // 绑定地址信息，IP信息 ret = bind(sockfd, (struct sockaddr*)&amp;saddr, sizeof(struct sockaddr)); if(ret &lt; 0) { perror(\"sbind failed.\"); exit(2); } listen(sockfd, 128); socklen_t val = sizeof(struct sockaddr); puts(\"waiting connect...\"); clientfd = accept(sockfd, (struct sockaddr*)&amp;raddr, &amp;val); puts(\"get!\"); // 循环接受客户端发来的信息 while(1) { puts(\"waiting data....\"); read(clientfd, rbuf, sizeof(rbuf)); printf(\"客户端传来数据: %s\\n\", rbuf); strncpy(rbuf, \"hello world too.\\n\", sizeof(\"hello world too.\\n\")); write(clientfd, rbuf, sizeof(rbuf)); printf(\"发送给客户端数据: %s\", rbuf); bzero(rbuf, 50); } close(sockfd); close(clientfd); return 0; } Android 客户端NDK应为tcp的服务端是用c语言写的，所以为了android能够连接，我使用了ndk，ndk具体的配置可以自行百度。 网络权限因为要进行网络连接，所以我们必须在mainfests文件中申请网络权限。如果没有权限创建socket会直接失败。 在application上面加上一句即可 &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; layout文件&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;Button android:id=\"@+id/send_link\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"发送连接\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.498\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.374\" /&gt; &lt;TextView android:text=\"TextView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/send_link\" android:layout_alignStart=\"@+id/send_link\" android:layout_marginTop=\"69dp\" android:id=\"@+id/textView\" tools:ignore=\"MissingConstraints\" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; MainActivity文件package com.example.test2; import androidx.appcompat.app.AppCompatActivity; import android.annotation.SuppressLint; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.TextView; import android.widget.Toast; public class MainActivity extends AppCompatActivity { // Used to load the 'native-lib' library on application startup. static { System.loadLibrary(\"native-lib\"); } public EditText editText; public static native String linkTest(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Example of a call to a native method Button button = findViewById(R.id.send_link); editText = findViewById(R.id.editText); button.setOnClickListener(new View.OnClickListener() { @SuppressLint(\"WrongConstant\") @Override public void onClick(View v) { new Thread(new Runnable() { //网络连接必须在子线程中 @Override public void run() { String ret = linkTest(); Log.d(\"s\", ret); //Toast.makeText(getApplicationContext(), linkTest(), 1).show(); } }).start(); } }); } } cpp文件#include &lt;jni.h&gt; #include &lt;string&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #include &lt;android/log.h&gt; #define LOG_TAG \"mysocket\" #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__) #define SERV_IP \"123.56.252.111\" #define SERV_PORT 6666 extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_test2_MainActivity_linkTest(JNIEnv *env, jclass clazz) { int cfd; struct sockaddr_in serv_addr; socklen_t serv_addr_len; cfd = socket(AF_INET, SOCK_STREAM, 0); if(cfd &lt; 0) { return env-&gt;NewStringUTF(\"socket failed.\"); } LOGI(\"socket successful\"); memset(&amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(SERV_PORT); inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr); LOGI(\"connecting!\"); int ret = connect(cfd, (sockaddr *)&amp;serv_addr, sizeof(serv_addr)); if(ret &lt; 0) { LOGI(\"connect failed.\"); return env-&gt;NewStringUTF(\"连接失败\"); } LOGI(\"connect successful\"); char buf[1024] = \"hello world\\n\"; write(cfd, buf, sizeof(buf)); bzero(buf, 1024); read(cfd, buf, sizeof(buf)); return env-&gt;NewStringUTF(buf); } 连接我们点击模拟器中的连接按钮，可以在android日志中发现连接成功，并成功相互发送数据","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"连接服务器","slug":"连接服务器","permalink":"http://orzff.cn/tags/%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"android","slug":"android","permalink":"http://orzff.cn/tags/android/"}]},{"title":"windows下远程服务器mysql连接","slug":"远程服务器连接","date":"2020-05-25T08:54:31.000Z","updated":"2021-05-31T11:58:01.224Z","comments":true,"path":"/c700630f/","link":"","permalink":"http://orzff.cn/c700630f/","excerpt":"windows远程服务器mysql连接","text":"云服务器因为项目需要一个数据库，所以就在阿里云哪里用云翼计划买了一个小型服务器，虽然小但是也够用 centos 安装mysql安装mysqlwget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm yum -y install mysql57-community-release-el7-10.noarch.rpm yum -y install mysql-community-server 设置数据库启动mysqlsystemctl start mysqld.service 查看运行状态systemctl status mysqld.service 修改密码先查看原始密码 grep \"password\" /var/log/mysqld.log 利用原始密码进入数据库 mysql -uroot -p 修改密码规则 mysql&gt; set global validate_password_policy=0; mysql&gt; set global validate_password_length=1; 修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; windows mysql安装下载 &amp; 解压链接 配置系统变量找到bin目录的位置：E:\\Config\\mysql\\mysql-5.7.32-winx64\\bin 在环境变量的path中加入路径 安装生成data文件以管理员身份运行cmd 进入E:\\Config\\mysql\\mysql-5.7.32-winx64\\bin中 执行命令：mysqld --initialize-insecure --user=mysql 在E:\\Config\\mysql\\mysql-5.7.32-winx64\\下和bin同级目录生成data目录 安装mysql继续执行 mysqld -install 启动服务net start MySQL 登录mysqlmysql -u root -p 初始数据库没密码，直接回车 修改密码执行 ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; 创建数据库使用ubuntu下的命令就可以自动安装mysql数据库 sudo apt-get install mysql-server apt-get isntall mysql-client sudo apt-get install libmysqlclient-dev 安装成功后输入下面指令 sudo netstat -tap | grep mysq 如果是下图这样 那么就成功安装了，下面就是通过mysql -u root -p就可以登录mysql数据库 注意，在第一次登录mysql时输入的密码即为你的初始密码，不输就是空 远程连接在ubuntu下，修改/etc/mysql/mysql.conf.d/mysqld.cnf文件，将 bind-address = 127.9.0.1语句注释掉或者改成bind-address=0.0.0.0 bind-address = 127.9.0.1 意味着只允许本地登录，而把他改成0.0.0.0就代表允许所有的ip登录 但是这还不够，当我们连接远程数据库时，会新建一个root 用户，但是这个root只允许本地登录，不允许远程登陆，我们可以通过 use mysql select host, user from user; 来验证发现这个root的 host只有一个localhost 这是我们要通过设置来使他允许远程用户登录 在mysql 中输入 # 允许所有root用户登录 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root用户密码' WITH GRANT OPTION; # 允许指定ip的root用户登录 GRANT ALL PRIVILEGES ON *.* TO root@'指定的IP地址' IDENTIFIED BY 'root用户密码' WITH GRANT OPTION; 然后重载授权表 FLUSH PRIVILEGES; 这时我们再来验证一下root的权限 这时就应该可以连接上了 但是 ,如果这时还是连接不上，就可能是防火墙的问题，输入ufw disable把防火墙关闭 如果还不行的话，就有可能是阿里云的问题了，因为我用的是一个轻量级的服务器，所以在防火墙中把端口3306打开即可 结束经过以上步骤mysql的远程连接基本上就可以搞定了 mysql -h IP -u root -p","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"连接MySQL","slug":"连接MySQL","permalink":"http://orzff.cn/tags/%E8%BF%9E%E6%8E%A5MySQL/"}]},{"title":"爬取88ys视频exe版","slug":"爬取88ys视频exe版","date":"2020-03-01T06:57:56.000Z","updated":"2021-05-31T11:58:01.202Z","comments":true,"path":"/581490d4/","link":"","permalink":"http://orzff.cn/581490d4/","excerpt":"爬取88ys视频exe版","text":"爬取88ys视频使用方式点击dist中的main.exe 找到想下载的视频主页面 粘贴到url文本框","categories":[{"name":"Spider","slug":"Spider","permalink":"http://orzff.cn/categories/Spider/"},{"name":"小项目","slug":"Spider/小项目","permalink":"http://orzff.cn/categories/Spider/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"爬视频","slug":"爬视频","permalink":"http://orzff.cn/tags/%E7%88%AC%E8%A7%86%E9%A2%91/"}]},{"title":"wallpaper 模拟登录","slug":"wallpaper 模拟登录","date":"2020-02-11T07:26:29.000Z","updated":"2021-05-31T11:58:01.173Z","comments":true,"path":"/72810b67/","link":"","permalink":"http://orzff.cn/72810b67/","excerpt":"wallpaper 模拟登录","text":"在模拟登录wallhaven是，发现了一些问题，用request.session登录并保存cookie并不奏效 所以决定自己手动保存cookie 先是登录因为登录信息中有_token，所以要先get一下获取网页的_token ，并且用get到的cookie来请求登录 def __init__(self): self.get_url = \"https://wallhaven.cc/login\" self.post_url = \"https://wallhaven.cc/auth/login\" self.proxies = spider_proxy.SpiderProxy() self.data = {} self._token = \"\" self.cookies = {} self.Is = False # 1. 请求页面获得_token 和 cookie def get_html(self): response = requests.get(self.get_url, headers=self.proxies.header, proxies=self.proxies.proxy) response_data = response.content.decode('utf-8') self._token = re.findall(r'&lt;meta name=\"csrf-token\" content=\"(.*?)\"&gt;', response_data, re.S) cookies = \"\" for cookie in response.cookies: cookies += cookie.name + \"=\" + cookie.value + \";\" # 用header来携带cookie self.proxies.header['Cookie'] = cookies # 2.装填data def combined_data(self): self.data = { '_token': self._token, 'username': '643719884@qq.com', 'password': 'dhl643719884' } 这样可以登录，但是在用这个user-agent去请求数据是，不是登录后的状态， 抓包后发线登录以后的cookie和未登录的cookie只有remeber_web的差别 而remeber_web在请求登录的post的返回值里，那么 # login以后的cookie请求 __cfduid=d7e60a37935c5d9c6f53f05ab1064e1681580787848; remember_web_59ba36addc2b2f9401580f014c7f58ea4e30989d=eyJpdiI6ImROQ29VNGRicnZsOW0wQW5BTzZVa1E9PSIsInZhbHVlIjoiTmNQT0h2TE03YW5yaUdhbWZDZnlQYlZzanN3UTV4aUdiMHh1bUl5cjVJMXdQbzIxYnF6bElYcFpmMERPY0ZcL3FnZ21xcU5WdXlvMlBBK21CeEs2K2FWV1pUK05sTmdDdFlHSWl4TlBwUHpuaEprV1dXYmZRbkZzWU1STjV6S3JONWsxNjBsekttbXFqd1BQTzhENlcwNzF0dVRvUit6eURxdHhrN1pZblo4U3lUMys2ekNLdTlXTllBXC82dkI3VUEiLCJtYWMiOiJkYmNiOTZiNDU3M2NjY2M3OGJjZWM4ZTBjZmJlZmIwMTBhMTM5MTcwMTA3ZDc1NjliNDM0ZmM1OWFkY2VhN2YwIn0%3D _pk_ref.1.01b8=%5B%22%22%2C%22%22%2C1581400207%2C%22http%3A%2F%2Flocalhost%3A63342%2FPyCharnPython%2Fday04%2Fawewall.html%3F_ijt%3Dog5l1ar0obspirlv150bfq3d1o%22%5D _pk_id.1.01b8=e6d2c9622d153c11.1580787918.21.1581400207.1581400207. XSRF-TOKEN=eyJpdiI6IjE4NzVZTlQrXC9pWFBmVlFsMUFvVFpBPT0iLCJ2YWx1ZSI6Im91OUROUEFZVHlsNWJ5bjdLa2pyQkV5R0RYZmNMNVN1TkJ5bERSTmFWaGFGRjUyaDI0K09aYzVVTUhZYzhnM0oiLCJtYWMiOiI0MTgzZmMyYzg0YmYyYmE2ZjgxNTEzMDBjYjI1NjFhOGYyMDZhNmJlZjkyYzBlMzhhYTNmNzA0MjBlZDQ3MDZhIn0%3D wallhaven_session=eyJpdiI6IjZQNVJcL3F0bXJhNndKUkc3QUVCTTZ3PT0iLCJ2YWx1ZSI6IjVSNHlRRjl0cU1sNEFMUGdCUkpFU0lOWXpZUjAzc1d4cHo1NnpLYlk2SU9kXC9zMldpekJKQ1NSMTI2aHIrWDJGIiwibWFjIjoiOWI3YjRlZGU0YTZiZWNkYjZmMWI4MGVlOGFhOThmNzdhOGUwZWQ2ODAxZjFjMGU4MzA1NDJiYjMwZDE3YzQ1OSJ9 # 没有login的cookie请求 __cfduid=d7e60a37935c5d9c6f53f05ab1064e1681580787848 _pk_ref.1.01b8=%5B%22%22%2C%22%22%2C1581402095%2C%22http%3A%2F%2Flocalhost%3A63342%2FPyCharnPython%2Fday04%2Fawewall.html%3F_ijt%3Dog5l1ar0obspirlv150bfq3d1o%22%5D _pk_ses.1.01b8=1 _pk_id.1.01b8=e6d2c9622d153c11.1580787918.22.1581402949.1581402095. XSRF-TOKEN=eyJpdiI6InRCSDFCT2dvZTZDeXVjR0w0NzZRNGc9PSIsInZhbHVlIjoiY1dzU1J4cHdENzN4eGVuU0I0NmxcL3NCblgyOWdVWEs2dTZ6QTNadHA4OHhISnZHWTFFamNIZGpibmZJQTRPcWUiLCJtYWMiOiJiNmMwMjhmMGYzYmY0MGViMWU2M2VhNTNjMTI1YTY0NThiYjU0MWFiYjYxMzRmODRkMGE5OWE5NmFlNTVkNTBjIn0%3D wallhaven_session=eyJpdiI6IkJoY1dITVJtQWJ4bzRqamJOVkxKeFE9PSIsInZhbHVlIjoiZjBXZUI3azVRWFAwY2tZeDlHakc1Nm5sSTZFUWVLT2FsT2JFVm5VUXQ0YmszYzVwMk9HcXlaV2R5YXpheG5lMCIsIm1hYyI6IjRjNzk1M2Q4NmE1ZDI4MjAwZDY2NDczNmRlZDVjYmVlN2Y2ZDA0NjYxOTI5NTZkYWM5OWY5MTY5MDQ2YTg4NWUifQ%3D%3D 我们就直接组装一个cookie # 3. 组装cookie def combined_cookie(self): response = requests.post(self.post_url, headers=self.proxies.header, proxies=self.proxies.proxy, data=self.data) # 这里拿到的cookie是相对比较齐全的cookie，主要用这个cookie来组装 post_cookies = response.request.headers['Cookie'] post_cookies_list = post_cookies.split(\"; \") # 这里cookie只要__cfduid temp_cookie = self.proxies.header['Cookie'] temp_cookie_list = temp_cookie.split(\";\") # 组装 self.cookies.update(__cfduid = temp_cookie_list[0].split('=')[1]) for cookie in post_cookies_list: self.cookies[cookie.split('=')[0]] = cookie.split('=')[1] # header pop掉Cookie self.proxies.header.pop('Cookie') # 4.登录 def post_html(self): response = requests.get(self.post_url, headers=self.proxies.header, proxies=self.proxies.proxy, cookies=self.cookies) print(response) if response.status_code == 200: print(\"Cookies获取成功\") self.Is = True else: print(\"Cookies获取失败\") def update(self): self.__init__() self.get_html() self.combined_data() self.combined_cookie() self.post_html() 这样我们就得到了登陆后访问toplist的页面 完整项目地址: Mug-9/Python-Spider: Spider (github.com) session 登录这里不可行,其他地方可行 import requests import sys #登录时需要POST的数据 data = { data } #设置请求头 headers = {'User-agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36'} #登录时表单提交到的地址（用开发者工具可以看到） login_url = 'login_url' #构造Session session = requests.Session() #在session中发送登录请求，此后这个session里就存储了cookie #可以用print(session.cookies.get_dict())查看 resp = session.post(login_url, data) #登录后才能访问的网页 url = 'url' #发送访问请求 resp = session.get(url) print(resp.content.decode('utf-8'))","categories":[{"name":"Spider","slug":"Spider","permalink":"http://orzff.cn/categories/Spider/"}],"tags":[{"name":"模拟登录","slug":"模拟登录","permalink":"http://orzff.cn/tags/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"}]},{"title":"爬虫爬取压缩过的数据","slug":"python-爬取压缩过的数据","date":"2020-02-06T05:16:57.000Z","updated":"2021-05-31T11:58:01.157Z","comments":true,"path":"/757817fb/","link":"","permalink":"http://orzff.cn/757817fb/","excerpt":"python 爬取压缩过的数据","text":"在爬取bilibili的历史记录是，发现出现了UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0x8b in position 1: invalid start byte 错误，后来发现是因为data = response.read().decode(\"utf-8\")这一句的data是压缩后的数据，无法正常解析后来对data进行解码就可以了 import urllib.request import urllib.parse from io import BytesIO import gzip import user_agent_list url = 'https://www.bilibili.com/account/history' random_user_agent = user_agent_list.getheaders() request = urllib.request.Request(url) request.add_header(\"User-Agent\", random_user_agent) response = urllib.request.urlopen(request) data = response.read() buf = BytesIO(data) zip = gzip.GzipFile(fileobj=buf) data = zip.read().decode('utf-8') with open(\"cookies.html\", \"w\", encoding='utf-8') as f: f.write(data)","categories":[{"name":"Spider","slug":"Spider","permalink":"http://orzff.cn/categories/Spider/"}],"tags":[{"name":"爬虫报错处理","slug":"爬虫报错处理","permalink":"http://orzff.cn/tags/%E7%88%AC%E8%99%AB%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"}]},{"title":"爬虫爬取免费代理","slug":"python-爬取免费代理","date":"2020-02-06T02:37:03.000Z","updated":"2021-05-31T11:58:01.157Z","comments":true,"path":"/28d5d8e8/","link":"","permalink":"http://orzff.cn/28d5d8e8/","excerpt":"python 爬取免费代理","text":"使用python爬取网站，可以用handler来隐藏user-agent，和使用高匿的代理ip，下面就是用不同的user-agent来爬取免费代理 首先要有一个user-agent的列表，我把它放在同一目录下然后import导入 import requests import user_agent_list import re import random class SpiderProxy(): def __init__(self): self.url = [\"https://www.kuaidaili.com/free/inha/1/\", \"https://www.7yip.cn/free/?action=china&amp;page=2\", \"https://www.7yip.cn/free/?action=china&amp;page=3\", ] self.header = user_agent_list.getheaders() self.proxy = {} self.proxies_list = [] self.run() def get_proxies_list(self, url): try: response = requests.get(url, headers=self.header, timeout=3) response_data = response.content.decode('utf-8') ip_list = re.findall(r'&lt;td data-title=\"IP\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) port_list = re.findall(r'&lt;td data-title=\"PORT\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) type_list = re.findall(r'&lt;td data-title=\"类型\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) self.proxies_list = [] for index in range(len(ip_list)): self.proxies_list.append(\"{\\'%s\\':\\'%s:%s\\'}\" % (type_list[index], ip_list[index], port_list[index])) except Exception as e: print(e) # for tmp_proxy in tmp_list: # proxy = eval(tmp_proxy) # response = requests.get(\"www.baidu.com\", headers=self.header, proxies=proxy) # if response.status_code == 200: # self.proxies_list.append(tmp_proxy) def get_proxy(self): while 1: self.proxy = eval(random.choice(self.proxies_list)) try: response = requests.get(\"http://www.baidu.com\", headers=self.header, proxies=self.proxy, timeout=3) if response.status_code == 200: return except Exception as e: print(\"getProxy ------&gt; ERROR\", e) def run(self): for url in self.url: self.get_proxies_list(url) 项目地址：Python-Spider/爬取代理 at master · Mug-9/Python-Spider (github.com)","categories":[{"name":"Python","slug":"Python","permalink":"http://orzff.cn/categories/Python/"},{"name":"Spider","slug":"Python/Spider","permalink":"http://orzff.cn/categories/Python/Spider/"}],"tags":[{"name":"爬代理","slug":"爬代理","permalink":"http://orzff.cn/tags/%E7%88%AC%E4%BB%A3%E7%90%86/"}]},{"title":"杭电多校第七场","slug":"杭电多校第七场","date":"2019-10-13T06:12:27.000Z","updated":"2021-05-31T11:58:01.202Z","comments":true,"path":"/8f3d60e0/","link":"","permalink":"http://orzff.cn/8f3d60e0/","excerpt":"杭电多校第七场","text":"J: Just Repeat题意小C和小Q打牌，两个人轮流出牌，小C先出，小C手中有n张牌，小Q有m张牌，两个人知道对方手中有什么牌，如果对手已经出过了某个数字的牌，那么自己就不能再出这种数字的牌，而对方可以一直出，问最后谁先不能出牌。 思路首先对于双方都有的牌，我们肯定是要封对面尽量多的牌同时自己能出的牌也尽量多，我们我们就把这两个条件加一起把牌排一个序贪心拿即可， AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; typedef pair&lt;int, int&gt; pis; int a[maxn], b[maxn]; int n, m, p, cnt, mod; unordered_map&lt;int, int&gt; mp; int num[2][maxn&lt;&lt;1]; vector&lt;int&gt; vec[maxn&lt;&lt;1]; int read(){ int ans=0; char last=' ',ch=getchar(); while(ch&lt;'0' || ch&gt;'9') { last=ch; ch=getchar(); } while(ch&gt;='0' &amp;&amp; ch&lt;='9') { ans=ans*10+ch-'0'; ch=getchar(); } if(last=='-') ans=-ans; return ans; } unsigned long long k1, k2; unsigned long long rng() { unsigned long long k3 = k1, k4 = k2; k1 = k4; k3 ^= k3 &lt;&lt; 23; k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26); return k2 + k4; } int gai(int x) { if(!mp[x]) mp[x] = ++cnt; return mp[x]; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { mp.clear(); for (int i = 1; i &lt;= cnt; i ++) num[0][i] = num[1][i] = 0; cnt = 0; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;p); int sumn = n, summ = m; if(p == 1) { for (int i = 1; i &lt;= n; i ++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= m; i ++) scanf(\"%d\", &amp;b[i]); }else { scanf(\"%lld %lld %d\", &amp;k1, &amp;k2, &amp;mod); for (int i = 1; i &lt;= n; i ++) a[i] = rng() % mod; scanf(\"%lld %lld %d\", &amp;k1, &amp;k2, &amp;mod); for (int i = 1; i &lt;= m; i ++) b[i] = rng() % mod; } for (int i = 1; i &lt;= n; i ++) num[0][gai(a[i])] ++; for (int i = 1; i &lt;= m; i ++) num[1][gai(b[i])] ++; int Max = 0; for (int i = 1; i &lt;= cnt; i ++) { if(num[0][i] &amp;&amp; num[1][i]) { sumn -= num[0][i]; summ -= num[1][i]; int sumc = num[0][i] + num[1][i]; vec[sumc].push_back(num[0][i]); Max = max(Max, sumc); } } int cur = 0; for (int i = Max; i &gt;= 1; i --) { for (int v: vec[i]) { if(!cur) sumn += v; else summ += i - v; cur ^= 1; } vec[i].clear(); } if(sumn &gt; summ) printf(\"Cuber QQ\\n\"); else printf(\"Quber CC\\n\"); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"CodeForces EduRound 74","slug":"CodeForces-EduRound-74","date":"2019-10-10T12:12:20.000Z","updated":"2021-05-31T11:58:01.059Z","comments":true,"path":"/b223976b/","link":"","permalink":"http://orzff.cn/b223976b/","excerpt":"CodeForces EduRound 74","text":"E: Keyboard Purchase题意给你一个有小写字母组成的字符串，让你给每个字母编号，使得$\\sum\\limits_{i=1}^{n}|S_i-S_{i-1}|$的值最小 思路 因为字母种类很小，所以我们可以用类似状压来记录中间值，具体的是$dp[(1&lt;&lt;m)]$来记录当前状态出现的字母种类与还未出现的字母种类的距离。 我们现在先想象一个键盘，$dp[i]$的二进制表示就是键盘前几个的键，那么$dp[i]$的转移就是由$dp[i^(1&lt;&lt;j)]$新加了一位j转移得来： for (int i = 1; i &lt; (1&lt;&lt;m); i ++) { dp[i] = 0x3f3f3f3f; for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) dp[i] = min(dp[i], dp[i^(1&lt;&lt;j)]); } 得到的就是当前状态下的最小花费， 那么这样的话，原来的$dp[i^(1&lt;&lt;j)]$的状态不确定的这一位已经确定，那么其他还尚未却动的键与当前已经确定的键之间的距离要$+1$， for (int i = 1; i &lt; (1&lt;&lt;m); i ++) { dp[i] = 0x3f3f3f3f; for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) dp[i] = min(dp[i], dp[i^(1&lt;&lt;j)]); for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) for (int k = 0; k &lt; m; k ++) if(!((i&gt;&gt;k)&amp;1)) dp[i] += adj[j][k]; } AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; int dp[(1&lt;&lt;21)]; int adj[30][30]; int main() { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); string st; cin &gt;&gt; st; for (int i = 1; i &lt; st.size(); i ++) { adj[st[i]-'a'][st[i-1]-'a'] ++; adj[st[i-1]-'a'][st[i]-'a'] ++; } for (int i = 1; i &lt; (1&lt;&lt;m); i ++) { dp[i] = 0x3f3f3f3f; for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) dp[i] = min(dp[i], dp[i^(1&lt;&lt;j)]); for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) for (int k = 0; k &lt; m; k ++) if(!((i&gt;&gt;k)&amp;1)) dp[i] += adj[j][k]; } printf(\"%d\\n\", dp[(1&lt;&lt;m)-1]); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"CodeForces","slug":"CodeForces","permalink":"http://orzff.cn/tags/CodeForces/"}]},{"title":"牛客多校第十场","slug":"牛客多校第十场","date":"2019-09-12T09:20:18.000Z","updated":"2021-05-31T11:58:01.214Z","comments":true,"path":"/b961061/","link":"","permalink":"http://orzff.cn/b961061/","excerpt":"牛客多校第十场","text":"思路一个随机排列的数列，问前缀和大于$a$的时候小于$b$的概率 思路 大意就是枚举最后一次抽的牌的点数，找在剩下的$n-1$个牌中，前$i$个牌的前缀和范围在$[a-x,min(a,b-x)]$的概率 概率是$\\frac{i!(n-i-1)!}{n!}$，这个概率可以预处理出来。 然后就是用可逆背包和滚动数组来求dp AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 510; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; double dp[2][maxn][maxn], p[maxn]; int x[maxn]; int main() { int n, a, b; scanf(\"%d %d %d\", &amp;n, &amp;a, &amp;b); dp[0][0][0] = 1; for (int i = 1; i &lt;= n; i ++) { scanf(\"%d\", &amp;x[i]); memcpy(dp[i&amp;1], dp[(i&amp;1)^1], sizeof(dp[0])); for (int j = 1; j &lt;= n; j ++) for (int k = x[i]; k &lt;= b; k ++) dp[i&amp;1][j][k] += dp[(i&amp;1)^1][j-1][k-x[i]]; } p[1] = 1./n; for (int i = 2; i &lt;= n; i ++) p[i] = p[i-1] * (i-1) / (n-i+1); double ans = 0; for (int i = 1; i &lt;= n; i ++) { for (int j = 1; j &lt;= n; j ++) for (int k = x[i]; k &lt;= b; k ++) dp[n&amp;1][j][k] -= dp[n&amp;1][j-1][k-x[i]]; for (int j = 0; j &lt; n; j ++) for (int k = max(0, a-x[i]+1); k &lt;= a &amp;&amp; k + x[i] &lt;= b; k ++) ans += dp[n&amp;1][j][k] * p[j+1]; for (int j = n; j &gt;= 1; j --) for (int k = b; k &gt;= x[i]; k --) dp[n&amp;1][j][k] += dp[n&amp;1][j-1][k-x[i]]; } printf(\"%.15f\\n\", ans); return 0; } H: Wood Processinghttp://www.orzff.cn/f1b7e3b7/","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"2019ACM-ICPC南昌网络赛","slug":"2019ACM-ICPC南昌网络赛","date":"2019-09-10T06:13:02.000Z","updated":"2021-05-31T11:58:00.951Z","comments":true,"path":"/4e0518cb/","link":"","permalink":"http://orzff.cn/4e0518cb/","excerpt":"2019ACM-ICPC南昌网络赛","text":"H: The Nth Item题意$F(0)=0,F(1)=1$ $F(n)= 3\\times F(n-1)+2\\times F(n-2)(n\\ge 2)$ 求第n项，n个询问，强制在线 思路好像直接1e6进制矩阵快速幂就可以直接过，预先打个1e6的表，但这个好像是卡过，多交几次就会T掉 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e6; const int ll mod = 998244353; struct Matrix{ ll mat[2][2]; Matrix() {memset(mat, 0, sizeof(mat));}; void init() { mat[0][0] = mat[1][1] = 1; } void init(ll a, ll b) { mat[0][0] = 0; mat[0][1] = b; mat[1][0] = 1; mat[1][1] = a; } void operator = (Matrix x) { for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) mat[i][j] = x.mat[i][j]; } }; Matrix operator * (Matrix x, Matrix y) { Matrix t; for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) for (int k = 0; k &lt;= 1; k ++) t.mat[i][j] = (t.mat[i][j] + x.mat[i][k] * y.mat[k][j]) % mod; return t; } Matrix pre[4][2*maxn+10]; ll Ksm(ll b) { Matrix t; t.init(); int cnt = 0; while(b &amp;&amp; cnt &lt; 3) { ++ cnt; ll pt = b % maxn; if(cnt == 3) pt = b; t = t * pre[cnt][pt]; b /= maxn; } Matrix ans; ans.mat[0][0] = 0; ans.mat[0][1] = 1; ans = ans * t; return ans.mat[0][0]; } void init() { Matrix t; t.init(3, 2); pre[1][1] = t; pre[1][0].init(); for (int i = 2; i &lt;= maxn; i ++) pre[1][i] = pre[1][i-1] * pre[1][1]; pre[2][1] = pre[1][maxn]; pre[2][0].init(); for (int i = 2; i &lt;= maxn; i ++) pre[2][i] = pre[2][i-1] * pre[2][1]; pre[3][1] = pre[2][maxn]; pre[3][0].init(); for (int i = 3; i &lt;= 2* maxn; i ++) pre[3][i] = pre[3][i-1] * pre[3][1]; } int main() { init(); ll n, q; scanf(\"%lld %lld\", &amp;n, &amp;q); ll ans = 0; for (int i = 1; i &lt;= n; i ++) { ll a = Ksm(q); q = q ^ (a * a); ans ^= a; } printf(\"%lld\\n\", ans); return 0; } 思路还有一种解法，通过打表得知询问$q$是由循环节的，最后在进行大约$1e6$次后，会有一个长度为$2$的循环节，我们就直接暴力找循环节，时间上好像比上面快一点 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll mod = 998244353; struct Matrix{ ll mat[2][2]; Matrix() {memset(mat, 0, sizeof(mat));}; void init() { mat[0][0] = mat[1][1] = 1; } void init(ll a, ll b) { mat[0][0] = 0; mat[0][1] = b; mat[1][0] = 1; mat[1][1] = a; } void operator = (Matrix x) { for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) mat[i][j] = x.mat[i][j]; } }; Matrix operator * (Matrix x, Matrix y) { Matrix t; for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) for (int k = 0; k &lt;= 1; k ++) t.mat[i][j] = (t.mat[i][j] + x.mat[i][k] * y.mat[k][j]) % mod; return t; } ll Ksm(ll b) { Matrix x; x.init(3, 2); Matrix t; t.init(); while(b) { if(b &amp; 1) t = t * x; x = x * x; b &gt;&gt;= 1; } Matrix ans; ans.mat[0][0] = 0; ans.mat[0][1] = 1; ans = ans * t; return ans.mat[0][0]; } map&lt;ll, int&gt; mp; int main() { ll n, q; scanf(\"%lld %lld\", &amp;n, &amp;q); ll ans = 0, l, r, loop=-1; for (int i = 1; i &lt;= n; i ++) { if(mp[q]) { loop = i-1; l = q; ll a = Ksm(q); r = q ^ (a * a); break; } mp[q] = 1; ll a= Ksm(q); q = q ^ (a * a); ans = ans ^ a; } if(loop!=-1) { ll dis = n - loop; if(dis % 4 == 3) ans = ans ^ Ksm(r); if(dis % 4 == 2) ans = ans ^ Ksm(l) ^ Ksm(r); if(dis % 4 == 1) ans = ans ^ Ksm(l); } printf(\"%lld\\n\", ans); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"南昌","slug":"南昌","permalink":"http://orzff.cn/tags/%E5%8D%97%E6%98%8C/"},{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"网络赛","slug":"网络赛","permalink":"http://orzff.cn/tags/%E7%BD%91%E7%BB%9C%E8%B5%9B/"}]},{"title":"特征方程","slug":"特征方程","date":"2019-09-10T05:08:23.000Z","updated":"2021-05-31T11:58:01.215Z","comments":true,"path":"/ea13e7c5/","link":"","permalink":"http://orzff.cn/ea13e7c5/","excerpt":"特征方程","text":"问题求二阶常系数线性齐次递推数列$f_n=a\\times f_{n-1} + b \\times f_{n-2}$的通项公式 结论先解出特征方程$x^2-a\\times x - b = 0$，两根分别是$x_1,x_2$ 如果$x_1 != x_2$ 则$f_n=A\\times x_1^n+B\\times x_2^n$ 如果$x_1=x_2$ 则$f_n=(A+B\\times n)\\times x_1^n$ （$A,B$可以通过$f_0,f_1$求出） 应用斐波那契数列$f_n=f_{n-1}+f_{n-2}$ 求解$x^2-x-1=0$ $x_1=\\frac{1+\\sqrt{5}}{2},x_2=\\frac{1-\\sqrt{5}}{2}$ $f_0=A\\times x_1^0+B\\times x_2^0=0$ $f_1=A\\times x_1^1+B\\times x_2^1=1$ $A=\\frac{\\sqrt{5}}{5}, B=\\frac{-\\sqrt{5}}{5}$ 所以$f_n=\\frac{\\sqrt{5}}{5} \\times (\\frac{1+\\sqrt{5}}{2})^n+\\frac{-\\sqrt{5}}{5}\\times (\\frac{1+\\sqrt{5}}{2})^n$","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"特征方程","slug":"特征方程","permalink":"http://orzff.cn/tags/%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"}]},{"title":"Min_25筛","slug":"Min-25筛","date":"2019-09-02T12:39:13.000Z","updated":"2021-05-31T11:58:01.149Z","comments":true,"path":"/ecec6bcc/","link":"","permalink":"http://orzff.cn/ecec6bcc/","excerpt":"Min_25筛","text":"使用条件在$O(\\frac{n^{\\frac{3}{4}}}{\\log n})$时间复杂度内，来求一类完全积性函数的前缀和 $\\sum\\limits_{i=1}^{n}f(i)$ 要求是$f(p)[p\\in prime]$是一个关于p的简单多项式并且$f(p^e)$可以快速算出 如何求分类我们可以先对$i$按照质数非质数分类 $\\sum\\limits_{i=1}^{n}f(i)=\\sum\\limits_{1\\le p\\le n} f(p) + \\sum\\limits_{i=1 ||i \\notin prime}^nf(i)$ 因为$f(i)$是完全积性函数，所以我们进一步把后面拆分，枚举每一个合数的最小质因子和最小质因子的次幂 $\\sum\\limits_{i=1}^{n}f(i)=\\sum\\limits_{1\\le p\\le n}f(p)+\\sum\\limits_{1\\le p^e\\le n \\&amp; 1\\le p \\le \\sqrt n}f(p^e)(\\sum\\limits_{1\\le i \\le \\lfloor\\frac{n}{p^e}\\rfloor \\&amp; min(i)&gt; p} f(i))$ $min(i)$代表$i$的最小质因子, 上式代表我们把合数的最小质因子以及次幂数提出来,计算那些最小质因子大于$p$的合数的值 $G$函数上式中我们要枚举$[1,n]$的每一个质数，但是n的范围可以很大， 这样就没法用线性筛筛出所有质数 但是我们可以考虑一个$DP$，我们令$g(n,j) = \\sum\\limits_{i=1}^{n}h(i)[i\\in prime || min(i)&gt;p_j]$ 其中$h(i)$是一个在质数处于$f(i)$取值相同的一个完全积性函数 也可以理解成原$f(i)$的所以值都参照$[i\\in prime]$时的取值，把所有自然数都当成质数 $g(n,j)$代表$i$为质数或者$min(i)&gt;p_j$时的$h(i)$的前缀和 然后我们来考虑转移，怎么由$g(n,j-1)$转移到$g(n,j)$ ，因为$j$的增大，那么可满足条件的$h(i)$数量减小， 所以我们通过减掉一些不满足条件的$h(i)$来转移，通过观察可以发现，那些不满足条件的恰好就是最小质因子为 $p_j$的合数,也就是减掉$g(\\frac{n}{p_j},j-1)-g(p_j-1,p_j)$，后面是减掉质数的部分，因为减掉的都是小于$p_j$的质数，这些质数已经在前面的遍历中减过了一次，不必再减 那么$g(n,j)=g(n,j-1)-p_j^k(g(\\frac{n}{p_j},j-1)-g(p_j-1,j-1))$ 注意后面的$g(p_j-1,j-1)$ 其实就是$h(i)$在前$j-1$个质数处的前缀和，因为$p_j\\le \\sqrt n$，所以我们可以用线性筛 筛出来，但是$n$还是很大，我们无法$DP$到$n$ 但是因为$p_j$的范围是$\\sqrt n$，而$g(n)$由所有的$g(\\frac{n}{p_j})$转移而来，所以我们只要计算这$\\sqrt n$ 范围内的$h(i)$即可 我们对下表进行离散化用两个数组来存储 以洛谷P5325为例 $g(x)=x^2,h(x)=x$ void GetW(long long n) { for (long long i = 1, j; i &lt;= n; i = j + 1) { j = n / (n / i); w[++m] = n / i; long long t = w[m] % Mod; g[m] = t * (t + 1) % Mod * ((2LL * t + 1) % Mod) % Mod * inv_6 % Mod; g[m] --; h[m] = t * (t + 1) % Mod * inv_2 % Mod; h[m] --; if(w[m] &lt;= sqr) id1[w[m]] = m; else id2[n/w[m]] = m; } } void GetG(long long n) { for (long long i = 1; i &lt;= tot; i ++) { for (long long j = 1; j &lt;= m &amp;&amp; prim[i] * prim[i] &lt;= w[j]; j ++) { long long d = w[j] / prim[i]; long long id = d &lt;= sqr ? id1[d] : id2[n/d]; g[j] = Sup(g[j], prim[i] * prim[i] % Mod * ((g[id] - sumg[i-1] + Mod) % Mod) % Mod); h[j] = Sup(h[j], prim[i] * ((h[id] - sumh[i-1] + Mod) % Mod) % Mod); } } } 这样我们就求出来了$[1,n]$中所有$h(i)$在质数处的和，$g(n)$ 求和我们设$S(n,j)=\\sum\\limits_{i=1}^{n}f(i)[min(i) \\ge p_j]$ 那么$S(n,j)=g(n)-\\sum\\limits_{i=1}^{j-1}f(p_i)+\\sum\\limits_{p_k^e\\le n\\&amp; k&gt; x}f(p_k^e)(S(\\frac{n}{p_k^e}, k)+[e!=1])$ 这样跟求$g(n)$的$dp$类似,答案就是$S(n,1)+f(1)$ 例题洛谷P5325题意定义$f(x)$, 且$f(p^k)=p^k(p^k-1)$，$p$是一个质数,求$\\sum\\limits_{i=1}^{n}f(i)$,对$1e9+7$取模 思路当$p$为质数时 $f(p)=p(p-1)=p^2-p$ 设$g(x)=x^2,h(x)=x,f(x)=g(x)-h(x)$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1e6 + 5; const int inf = 0x3f3f3f3f; const int Mod = 1e9 + 7; const double eps = 1e-8; typedef pair&lt;int, int&gt; psi; #define inv_2 (Mod+1)/2 #define inv_6 (Mod+1)/6 long long sqr, m, w[maxn], g[maxn], h[maxn]; long long sumg[maxn], sumh[maxn], id1[maxn], id2[maxn]; long long prim[maxn], tot; bool mark[maxn]; long long Add(long long a, long long b) { return (a + b) % Mod; } long long Sup(long long a, long long b) { return (a - b + Mod) % Mod; } long long Pow(long long a, long long b) { long long res = 1; while(b) { if(b &amp; 1) res = res * a % Mod; a = a * a % Mod; b &gt;&gt;= 1; } return res; } void init(long long n) { mark[1] = 1; for (long long i = 2; i &lt;= n; i ++) { if(!mark[i]) { prim[++tot] = i; sumg[tot] = (sumg[tot-1] + i * i) % Mod; sumh[tot] = (sumh[tot-1] + i) % Mod; } for (long long j = 1; j &lt;= tot; j ++) { if(i * prim[j] &gt; n) break; mark[i * prim[j]] = 1; if(i % prim[j] == 0) break; } } } void GetW(long long n) { for (long long i = 1, j; i &lt;= n; i = j + 1) { j = n / (n / i); w[++m] = n / i; long long t = w[m] % Mod; g[m] = t * (t + 1) % Mod * ((2LL * t + 1) % Mod) % Mod * inv_6 % Mod; g[m] --; h[m] = t * (t + 1) % Mod * inv_2 % Mod; h[m] --; if(w[m] &lt;= sqr) id1[w[m]] = m; else id2[n/w[m]] = m; } } void GetG(long long n) { for (long long i = 1; i &lt;= tot; i ++) { for (long long j = 1; j &lt;= m &amp;&amp; prim[i] * prim[i] &lt;= w[j]; j ++) { long long d = w[j] / prim[i]; long long id = d &lt;= sqr ? id1[d] : id2[n/d]; g[j] = Sup(g[j], prim[i] * prim[i] % Mod * ((g[id] - sumg[i-1] + Mod) % Mod) % Mod); h[j] = Sup(h[j], prim[i] * ((h[id] - sumh[i-1] + Mod) % Mod) % Mod); } } } long long S(long long x, long long y, long long n) { if(x &lt;= prim[y-1] || x &lt;= 1) return 0; long long id = x &lt;= sqr ? id1[x] : id2[n/x]; long long res = (g[id] - h[id] + Mod - sumg[y-1] + sumh[y-1] + Mod) % Mod; for (long long i = y; i &lt;= tot &amp;&amp; prim[i] * prim[i] &lt;= x; i ++) { long long t = prim[i]; for (long long j = 1; t &lt;= x; j ++, t = t * prim[i]) { long long p1 = t % Mod; res = Add(res, p1 * (p1 - 1) % Mod * (S(x/t, i+1, n) + (j != 1)) % Mod); } } return res % Mod; } int main(int argc, char *args[]) { long long n; scanf(\"%lld\", &amp;n); sqr = sqrt(n); init(sqr); GetW(n); GetG(n); printf(\"%lld\\n\", (S(n, 1, n) + 1) % Mod); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Min_25筛","slug":"Min-25筛","permalink":"http://orzff.cn/tags/Min-25%E7%AD%9B/"}]},{"title":"牛客多校第四场","slug":"牛客多校第四场","date":"2019-08-26T08:52:42.000Z","updated":"2021-05-31T11:58:01.215Z","comments":true,"path":"/db92c5b8/","link":"","permalink":"http://orzff.cn/db92c5b8/","excerpt":"牛客多校第四场","text":"E.triples ll题意让你用$n$个3的倍数，把$a$或出来,问你有几种方案，对998244353取模 思路在二进制中$1,4,16,\\mod 3余1$, 而 $2,8,32 \\mod 3余2$ 首先如果$a$中为$1$的二进制位在$b$中也都为$1$，那么就称$a$是$b$的子集 我们用$dp[i][j]$来表示二进制位$mod$ $3$ 余$1$的个数为$i$,$mod$ $3$ 余$2$的个数为$j$并且所有是3的倍数的子集个数 我们可以先一个$(logn)^4$求出所有的$dp$值 void Fac() { for (int i = 0; i &lt; maxn; i ++) C[i][0] = 1; for (int i = 1; i &lt; maxn; i ++) for (int j = 1; j &lt;= i; j ++) C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; } void init() { Fac(); for (int x = 0; x &lt; maxn; x ++) for (int y = 0; y &lt; maxn; y ++) for (int i = 0; i &lt;= x; i ++) for (int j = 0; j &lt;= y; j ++) if((i+2*j)%3==0) dp[x][y] = (dp[x][y] + C[x][i] * C[y][j] % mod) % mod; dp[0][0] = 1; } 如果要求或出来的结果是$a$的子集，那么方案数就是$(a的子集的个数)^n$ 但是题目要求或出来的结果是$a$,那我们就要容斥一下了 打个比方，现在$a$的$\\mod2$的个数为$1$，$\\mod1$的个数为$2$ 那么$dp[2][1]$所代表的是$&lt;2,1&gt;$的子集的个数，但有些子集在相或$n$次以后得不到a，这时候就要减掉那些不能或到$a$的子集 $dp[2][1]$就像上图中由 A-E,​A-D,A-C,B-E,B-D,B-C 组成，而能或出来$a$的只有A-E,那么我们就要把其余不满足的减掉，也就是减掉$dp[1][1]+dp[2][0]$,发现减多了，我们要加上$dp[1][0]+dp[0][1]$，后面就跟容斥一样，多写几个样例就会发现当$(num1+num2-i-j)\\mod2$时是减,其他是加。 注意：减的时候减掉的是不符合个数的$n$次幂 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 70; const int inf = 0x3f3f3f3f; const int mod = 998244353; ll C[maxn][maxn], dp[maxn][maxn]; int cnt[2], o; ll Ksm(ll a, ll b) { ll ret = 1; while(b) { if(b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return ret; } void Fac() { for (int i = 0; i &lt; maxn; i ++) C[i][0] = 1; for (int i = 1; i &lt; maxn; i ++) for (int j = 1; j &lt;= i; j ++) C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; } void init() { Fac(); for (int x = 0; x &lt; maxn; x ++) for (int y = 0; y &lt; maxn; y ++) for (int i = 0; i &lt;= x; i ++) for (int j = 0; j &lt;= y; j ++) if((i+2*j)%3==0) dp[x][y] = (dp[x][y] + C[x][i] * C[y][j] % mod) % mod; dp[0][0] = 1; } int main() { init(); int t; scanf(\"%d\", &amp;t); while(t --) { ll n, a; scanf(\"%lld %lld\", &amp;n, &amp;a); cnt[0] = cnt[1] = o = 0; while(a) { if(a &amp; 1) cnt[o] ++; o ^= 1; a /= 2; } ll ans = 0; for (int i = 0; i &lt;= cnt[0]; i ++) for (int j = 0; j &lt;= cnt[1]; j ++) { ll f = C[cnt[0]][i] * C[cnt[1]][j] % mod * Ksm(dp[i][j], n) % mod; if((cnt[0] + cnt[1] - i - j) &amp; 1) f *= -1; ans = (ans + f + mod) % mod; } printf(\"%lld\\n\", ans); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"斜率优化dp","slug":"斜率优化dp","date":"2019-08-20T08:48:50.000Z","updated":"2021-05-31T11:58:01.180Z","comments":true,"path":"/f1b7e3b7/","link":"","permalink":"http://orzff.cn/f1b7e3b7/","excerpt":"斜率优化dp","text":"具体可以参考这篇博客https://www.cnblogs.com/Judge/p/9551035.html 简介斜率斜率优化$dp$，听名字就知道是用来优化$dp$的 当我们在推导$dp$公式的时候，如果我们推出来的$dp$转移方程类似为： $dp[i] = \\min\\limits_{x=1}^{x&lt;i}$ $or$ $\\max\\limits_{x=1}^{x&lt;i}$ $\\{dp[x] + f(x,i)\\}$ $f(x,i)是一个关于x与i的函数$ 拿去最小值来说 我们考虑两个决策点$k&lt;j&lt;i$并且$j$比$k$要优 我们我们可以列一个不等式 $dp[j]+f(j,i)\\leq dp[k]+f(k,i)$ 展开如果可以把式子化成类似$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$，那么我们如果如果把每个点$(x_i,y_i)$看成一个坐标，那么 就表示$(x_j,y_j)$与$(x_k,y_k)$的斜率$\\leq k_i$, 这样我们可以得到真正有用的点组成了一个凸包的形状 为什么是个凸包？当我们去最小值是，我们有一下这么几个点 我们维护一个下凸壳，那么我们找的最小值的直线一定是沿着下凸壳的边缘 所以说不处于凸壳上的点是没有意义的 另外：最小值维护下凸壳，最大值维护上凸壳 如何使用求斜率一般来说能推出斜率表达式的都可以用斜率优化$dp$ 我们已经把式子化成这么一个形式$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$ ,那么我们求斜率可以这么写 如果斜率单调就用移指针，不单调就二分答案 以HDU 3507为例： ll getUp(ll j) { return dp[j] + sum[j] * sum[j]; } ll getDown(ll j) { return 2 * sum[j]; } double Calc(ll x, ll y) { if(getDown(x) == getDown(y)) return -1e9; //加一下防止除零的情况 return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } 单调队列当我们化成的这个式子的$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$ 的$k_i$是单调的，那么我们可以用单调队列来维护这个凸壳，并且队首是最优解 因为我们维护一个单调的队列，所以当我们在队列里面加点时，根据凸壳的单调性我们可以这么写 while(head &lt; tail &amp;&amp; Calc(i, q[tail]) &lt;= Calc(q[tail], q[tail-1])) tail --; q[++tail] = i; 而如果存在$k&lt;j&lt;i$并且$j$比$k$优，的情况，也就是$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$ 我们在队首把$k$踢出去,因为$k$已经不是最优的 while(head &lt; tail &amp;&amp; Calc(q[head+1], q[head]) &lt;= sum[i]) head ++; 这样我们就可以用单调队列去维护一个单调的凸壳，并且单调队列里面的队首就是最优情况 二分单调栈当我们化成的这个式子的$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$ 的$k_i$不是单调的，那么我们可以用单调栈来维护这个凸壳 因为凸壳是单调的，所以我们要找的这个$k_i$可以用二分来查找 例题HDU 3507 Print Article题意有一个$C_i$序列，你可以把序列分为几段，每段的权值为$(\\sum\\limits_{i=1}^{k}C_i)^2+M$， 求出最小的权值和 思路很容易想到转移方程$dp[i] = \\min\\limits_{x=1}^{x&lt;i}\\{dp[x] + m + (sum[i] - sum[x])^2\\}$ 我们假设存在一个$k&lt;j&lt;i$并且$j$比$k$要优 那么$dp[j]+m+(sum[i]-sum[j]^2)\\leq dp[k]+m+(sum[i]-sum[k])^2$ 移项并合并同类项后： $\\frac{dp[j]+sum[j] \\times sum[j] - (dp[k]+sum[k]\\times sum[k])}{2(sum[j]-sum[k])}\\le sum[i]]$ 我们设$Y=dp[x]-sum[x],X=2\\times sum[x]$ 那么式子可以化成:$\\frac{Y(j)-Y(k)}{X(j)-X(k)}\\le sum[i]$ 因为是$sum[i]$是递增的，所以我们可以用单调队列维护一个下凸壳 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll maxn = 5e5 + 7; const ll inf = 0x3f3f3f3f; const ll mod = 1e9 + 7; const double eps = 0.0000000001; typedef pair&lt;ll, ll&gt; pis; ll dp[maxn], q[maxn]; ll sum[maxn]; ll head, tail, n, m; ll getDp(ll i, ll j) { return dp[j] + m + (sum[i] - sum[j]) * (sum[i] - sum[j]); } ll getUp(ll j) { return dp[j] + sum[j] * sum[j]; } ll getDown(ll j) { return 2 * sum[j]; } double Calc(ll x, ll y) { if(getDown(x) == getDown(y)) return -1e9; return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } int main() { while(~scanf(\"%lld %lld\", &amp;n, &amp;m)) { for (ll i = 1; i &lt;= n; i ++) scanf(\"%lld\", &amp;sum[i]); sum[0] = dp[0] = 0; for (ll i = 1; i &lt;= n; i ++) sum[i] += sum[i-1]; head = tail = 1; for (ll i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Calc(q[head+1], q[head]) &lt;= 1.0 * sum[i]) head ++; dp[i] = getDp(i, q[head]); while(head &lt; tail &amp;&amp; Calc(i, q[tail]) &lt;= Calc(q[tail], q[tail-1])) tail --; q[++tail] = i; } printf(\"%lld\\n\", dp[n]); } return 0; } 洛谷 P4072 征途题意序列分割，给你n个数字，你把序列分割成m个段，每一段的的方差为$v$ 输出最小的每一段的之和$\\times m^2$ 思路提前声明一下， 下面的$c_i$都是一段路的距离之和，而不是单条路的距离，所以是$m$段而不是$n$段 $s^2=\\frac{(\\frac{\\sum\\limits_{i=1}^{m}c_i}{n}-c_1)^2+(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m}-c_2)^2+…+(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m}-c_n)^2}{m}$ $s^2=\\frac{(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m})^2-2\\times \\frac{\\sum\\limits_{i=1}^{m}c_i}{m}\\times c_1+c_1^2+(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m})^2-2\\times \\frac{\\sum\\limits_{i=1}^{m}c_i}{m}\\times c_2+c_2^2+…+(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m})^2-2\\times \\frac{\\sum\\limits_{i=1}^{m}c_i}{m}\\times c_n+c_n^2}{m}$ $s^2=\\frac{m\\times (\\frac{\\sum\\limits_{i=1}^{m}c_i}{m})^2-2\\times \\frac{(\\sum\\limits_{i=1}^{m}c_i)^2}{m}+(\\sum\\limits_{i=1}^{m}c_i^2)}{m}$ $s^2=\\frac{\\frac{(\\sum\\limits_{i=1}^{m}c_i)^2}{m}-2\\times \\frac{(\\sum\\limits_{i=1}^{m}c_i)^2}{m}+(\\sum\\limits_{i=1}^{m}c_i^2)}{m}$ $s^2=\\frac{-\\frac{(\\sum\\limits_{i=1}^{m}c_i)^2}{m}+(\\sum\\limits_{i=1}^{m}c_i^2)}{m}$ $s^2\\times m^2=-(\\sum\\limits_{i=1}^{n}c_i)^2+m\\times (\\sum\\limits_{i=1}^{n}c_i^2)$ 我们发现前面一项是一个常数，而$s^2\\times m^2$最小是在$\\sum\\limits_{i=1}^{m}c_i^2$最小时 这样我们在进行$dp$转移的时候,我们用$sum[x] = \\sum\\limits_{i=1}^{x}val[i]$ $val[x]$时每一条路的长度 $dp[i] = \\min\\{dp[x] + (sum[i]-sum[x])^2\\}$ 按照以往的套路，存在$k&lt;j&lt;i$并且$j$比$k$要优 $dp[j]+(sum[i]-sum[j])^2\\le dp[k]+(sum[i]+sum[k])^2$ $dp[j]+sum[j]^2-(dp[k]+sum[k]^2)\\le2\\times sum[i]sum[j]-2\\times sum[i]sum[k]$ $\\frac{dp[j]+sum[j]^2-(dp[k]+sum[k]^2)}{2\\times(sum[j]]-sum[k])}\\le sum[i]$ 这样斜率就推出来了，因为$sum[i]$是个递增的值，所以我们可以用单调队列来维护凸壳 然后用一个滚动数组来记录最优值 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; const int inf = 0x3f3f3f3f; const int mod = 1e9+7; ll sum[maxn], g[maxn], val[maxn]; ll q[maxn], dp[maxn]; ll getDp(ll i, int j) { return g[j] + (val[i] - val[j]) * (val[i] - val[j]); } ll getUp(int j) { return g[j] + val[j] * val[j]; } ll getDown(int j) { return 2 * val[j]; } double Calc(int x, int y) { if(getDown(x) == getDown(y)) return -1e9; return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } int main() { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;val[i]); val[i] += val[i-1]; g[i] = val[i] * val[i]; } for (int t = 1; t &lt; m; t ++) { int head, tail; head = tail = 1; for (int i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Calc(q[head+1], q[head]) &lt;= val[i]) head ++; dp[i] = getDp(i, q[head]); while(head &lt; tail &amp;&amp; Calc(i, q[tail]) &lt;= Calc(q[tail], q[tail-1])) tail --; q[++tail] = i; } for (int i = 1; i &lt;= n; i ++) g[i] = dp[i]; } printf(\"%lld\\n\", m * dp[n] - val[n] * val[n]); return 0; } 这道题貌似可以用WQS加斜率dp来写，下次来补一下 洛谷P2365 任务安排题意N个任务排成一个序列，你把任务分组完成，每个任务的费用是完成时间乘一个费用系数 思路我们先设计dp转移方程,因为我们在转移的时候还要考虑前面用了几组,所以我们在转移的时候直接把后面的 费时S加上, dp转移的时候时间和花费用前缀和维护 $dp[i] = min\\{dp[x] + time[i] \\times (cost[i] - cost[x])+S\\times (cost[n] - cost[x])\\}$ 按照以往套路, $dp[j]+time[i]\\times(cost[i]-cost[j])+S\\times(cost[n] - cost[j])\\le dp[k]+time[i]\\times(cost[i]-cost[k])+S\\times(cost[n] - cost[k])$ $dp[j]-dp[k]-S\\times cost[j]+S\\times cost[k]\\le time[i]\\times (cost[j]-cost[k])$ $\\frac{dp[j]-S\\times cost[j]-(dp[k]-S\\times cost[k])}{cost[j]-cost[k]}\\le time[i]$ 然后用斜率$dp$就直接写了 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll maxn = 1e5 + 5; const ll inf = 0x3f3f3f3f; const ll mod = 1e9+7; ll t[maxn], c[maxn]; ll dp[maxn], q[maxn]; ll n, S; ll getDp(ll i, ll j) { return dp[j] + t[i] * (c[i] - c[j]) + S * (c[n] - c[j]); } ll getUp(ll i) { return dp[i]-S*c[i]; } ll getDown(ll i) { return c[i]; } double Clac(int x, int y) { return 1.0 * (getUp(x) - getUp(y))/(getDown(x) - getDown(y)); } int main() { scanf(\"%lld %lld\", &amp;n, &amp;S); for (ll i = 1; i &lt;= n; i ++) { scanf(\"%lld %lld\", &amp;t[i], &amp;c[i]); t[i] += t[i-1]; c[i] += c[i-1]; } ll head, tail; head = tail = 1; for (int i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Clac(q[head+1], q[head]) &lt;= t[i]) head ++; dp[i] = getDp(i, q[head]); while(head &lt; tail &amp;&amp; Clac(i, q[tail]) &lt;= Clac(q[tail], q[tail-1])) tail --; q[++tail] = i; } printf(\"%lld\\n\", dp[n]); return 0; } 洛谷 P4360 锯木厂选址题意从山顶到山底运n棵老树，运一颗树的费用是树的重量乘上距离，为了不浪费决定在山腰上见两个锯木厂，问最小的运输费用 思路我们把树的重量求一个前缀和 $sum[]$，到山底的距离求一个后缀和$dis[]$,所有树运到山底的花费$totsum$ 因为只有两个锯木厂，所以我们可以直接写一下$dp$转移 $dp[i] = min\\{totsum-dis[x]\\times sum[x]-(sum[i]-sum[x])\\times dis[i])\\}$ 套路： $totsum-dis[j]\\times sum[j]-(sum[i]-sum[j])\\times dis[i])\\leq totsum-dis[k]\\times sum[k]-(sum[i]-sum[k])\\times dis[i])$ $-dis[j]\\times sum[j]+dis[k]\\times sum[k]\\le dis[i]\\times (-sum[j]+sum[k])$ $\\frac{dis[j]\\times sum[j]-dis[k]\\times sum[k]}{sum[j]-sum[k]}\\ge dis[i]$ $(因为sum[j]大于sum[k]所以要变号)$ 直接套 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; const ll inf = 0x7ffffffffffll; const int mod = 1e9+7; ll dis[maxn], sum[maxn]; ll dp[maxn], g[maxn]; ll q[maxn], totsum=0; ll getDp(int i, int j) { return totsum - dis[j] * sum[j] - dis[i] * (sum[i] - sum[j]); } ll getUp(int i) { return dis[i] * sum[i]; } ll getDown(int i) { return sum[i]; } double Clac(int x, int y) { return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } int main() { int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld %lld\", &amp;sum[i], &amp;dis[i]); sum[i] += sum[i-1]; totsum += sum[i] * dis[i]; } for (int i = n; i &gt;= 1; i --) dis[i] += dis[i+1]; int head, tail; ll ans = inf; head = tail = 1; for (int i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Clac(q[head+1], q[head]) &gt; dis[i]) head ++; dp[i] = getDp(i, q[head]); while(head &lt; tail &amp;&amp; Clac(i, q[tail]) &gt;= Clac(q[tail], q[tail-1])) tail --; q[++tail] = i; } for (int i = 1; i &lt;= n; i ++) ans = min(ans, dp[i]); printf(\"%lld\\n\", ans); return 0; } 洛谷 P5504 柠檬题意一串贝壳，每个贝壳都有一个值$s_0$你可以选择连续的一段把他变成柠檬，柠檬的个数是$s_0t^2$,$t$是区间柠檬值为$s_0$的个数 思路首先，我们要变的贝壳区间肯定是首尾值相同，然后我们可以对每个相同值得柠檬求一个前缀和 $dp[i] = max\\{dp[x-1] + vali^2\\}$ 套： $dp[j-1]+vali^2\\le dp[k-1]+vali^2$ $\\frac{dp[j-1]-dp[k-1] + val[j]sum[j]^2-val[k]sum[k]^2-2val[i]sum[j]+2val[i]sum[k]}{sum[j]-sum[k]}\\le 2val[i]sum[i]$ 我们发现$2val[i]sum[i]$对于每一类柠檬都是单调的，所以可以直接移指针如果斜率不单调就要在凸壳上二分了 AC代码（移指针）#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll maxn = 1e5 + 5; const ll inf = 0x3f3f3f3f; const ll mod = 1e9+7; ll last[maxn]; ll c[maxn], s[maxn]; vector&lt;ll&gt; q[maxn]; ll top[maxn]; ll dp[maxn]; ll getUp(ll i) { return dp[i-1] - 2 * s[i] * c[i] + c[i] * s[i] * s[i]; } ll getDown(ll i) { return s[i]; } double Calc(ll x, ll y) { return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } int main() { ll n; scanf(\"%lld\", &amp;n); for (ll i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;c[i]); s[i] = s[last[c[i]]] + 1; last[c[i]] = i; } for (ll i = 1; i &lt;= n; i ++) { if(last[c[i]]) q[c[i]].push_back(i); last[c[i]] = 0; } for (ll i = 1; i &lt;= n; i ++) { ll p = c[i]; while(top[p] &gt; 1 &amp;&amp; Calc(q[p][top[p]-1], q[p][top[p]]) &lt;= Calc(q[p][top[p]], i)) { --top[p]; q[p].pop_back(); } ++top[p]; q[p].push_back(i); while(top[p] &gt; 1 &amp;&amp; Calc(q[p][top[p]-1], q[p][top[p]]) &lt;= 2*p*s[i]) { --top[p]; q[p].pop_back(); } dp[i] = dp[q[p][top[p]]-1] + (s[i] - s[q[p][top[p]]]+1) * (s[i]-s[q[p][top[p]]]+1) * p; } printf(\"%lld\\n\", dp[n]); return 0; } AC代码（二分）#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll maxn = 1e5 + 5; const ll inf = 0x3f3f3f3f; const ll mod = 1e9+7; ll last[maxn]; ll c[maxn], s[maxn]; vector&lt;ll&gt; q[maxn]; ll top[maxn]; ll dp[maxn]; ll getUp(ll i) { return dp[i-1] - 2 * s[i] * c[i] + c[i] * s[i] * s[i]; } ll getDown(ll i) { return s[i]; } double Calc(ll x, ll y) { if(getDown(x) == getDown(y)) return -1e9; return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } ll find(ll x) { ll p = c[x]; ll l = 2, r = top[p]; ll ans = 1; while(l &lt;= r) { ll m = (l + r) &gt;&gt; 1; if(Calc(q[p][m], q[p][m-1]) &gt; 2*p*s[x]) { ans = m; l = m + 1; }else r = m - 1; } return ans; } int main() { ll n; scanf(\"%lld\", &amp;n); for (ll i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;c[i]); s[i] = s[last[c[i]]] + 1; last[c[i]] = i; } for (ll i = 1; i &lt;= n; i ++) { if(last[c[i]]) q[c[i]].push_back(i); last[c[i]] = 0; } for (ll i = 1; i &lt;= n; i ++) { ll p = c[i]; while(top[p] &gt; 1 &amp;&amp; Calc(q[p][top[p]-1], q[p][top[p]]) &lt;= Calc(q[p][top[p]], i)) { --top[p]; q[p].pop_back(); } ++top[p]; q[p].push_back(i); int ans = find(i); dp[i] = dp[q[p][ans]-1] + (s[i] - s[q[p][ans]] + 1) * (s[i]-s[q[p][ans]] + 1) * p; } printf(\"%lld\\n\", dp[n]); return 0; } 2019牛客多校第十场 J.Wood Processing题意把n块木板求成高度相同的k块，求浪费的最小 思路可以说是斜率dp的模板题 我们把高度从高到低排序，那么$dp$转移式就是 $dp[i]=max\\{dp[x]+(sum[i]-sum[x])\\times h[i]\\}$ $sum$是宽的前缀和 我们假设$j&gt;k$并且$j$比$k$优 $dp[j]+(sum[i]-sum[j])\\times h[i] &gt;= dp[k]+(sum[i]-sum[k])\\times h[i]$ $\\frac{dp[j]-dp[k]}{sum[j]-sum[k]}\\ge h[i]$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 5005; const int inf = 0x3f3f3f3f; const int mod = 1e9+7; typedef pair&lt;int, int&gt; pis; struct Node{ ll p, h, w; }node[maxn][2]; struct Plan{ ll h, w; }plan[maxn]; int n, k; ll ans = 0; ll dp[maxn], q[maxn], g[maxn]; bool cmp(Plan a, Plan b) { return a.h &gt; b.h; } ll getUp(int j) { return g[j]; } ll getDown(int i) { return plan[i].w; } double Cal(int x, int y) { return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } ll getDp(int x, int i) { return g[x] + (plan[i].w - plan[x].w) * plan[i].h; } void solve() { int head, tail; head = tail = 1; for (int i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Cal(q[head+1], q[head]) &gt;= plan[i].h) head ++; dp[i] = getDp(q[head], i); while(head &lt; tail &amp;&amp; Cal(i, q[tail]) &gt;= Cal(q[tail], q[tail-1])) tail --; q[++tail] = i; } for (int i = 1; i &lt;= n; i ++) g[i] = dp[i]; } int main() { scanf(\"%d %d\", &amp;n, &amp;k); ll sum = 0; for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld %lld\", &amp;plan[i].w, &amp;plan[i].h); sum += plan[i].w * plan[i].h; } sort(plan + 1, plan + 1 + n, cmp); for (int i = 1; i &lt;= n; i ++) plan[i].w += plan[i-1].w; for (int i = 1; i &lt;= k; i ++) solve(); printf(\"%lld\\n\", sum-dp[n]); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斜率优化dp","slug":"斜率优化dp","permalink":"http://orzff.cn/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/"}]},{"title":"全排列与逆序对","slug":"全排列与逆序对","date":"2019-08-17T01:30:43.000Z","updated":"2021-05-31T11:58:01.178Z","comments":true,"path":"/ea46ca8a/","link":"","permalink":"http://orzff.cn/ea46ca8a/","excerpt":"全排列与逆序对","text":"全排列从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m＝n时所有的排列情况叫n的全排列。 逆序列逆序在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。 逆序数一个排列中逆序的总数就称为这个排列的逆序数。 奇偶排列逆序数为偶数的排列称为偶排列；逆序数为奇数的排列称为奇排列 相关问题给排列，求逆序数这个问题比较简单，直接对每个数字求一下逆序数，相加就可以了。 可以用线段树，树状数组等优化 根据逆序数推排列数问题1给定一个n元排列，它的逆序数存在且唯一,那么我们求一下已知一个n元排列的逆序数为m，这样的n元排列有多少？ 我们用$f(n,m)$表示逆序数为m的n元排列的个数 前提知识1对任意n&gt;=2且0&lt;=m&lt;=$C_n^2$时$f(n,m)$&gt;=1；当m&gt;$C_n^2$时,$f(n,m)$=0$f(2,0)=1,f(2,1)=1,f(2,2)=0$ 易证 前提知识2$f(n,m)=f(n,C_n^2-m)$对于一个逆序数为m的n元排列，$a_1,a_2,a_3,…a_n$，那么$a_n,a_{n-1},a_{n-2}…a_1$的逆序数为$C_n^2-m$ 反过来同理 前提知识3$f(n+1,m)=f(n,m)+f(n,m-1)+…+f(n,m-n)$考虑由$a_1,a_2,…a_n$组成的排列，那么我们在其中加上$a_{n+1}（a_{n+1}&gt;\\{a_1,a_2,…a_n\\}）$的话，$a_{n+1}$ 可以放在排列中的任意一个位置 放在末尾对逆序列没有影响，那么$f(n+1,m)+=f(n,m)$，放在首位的话逆序对增加$n$那么$f(n+1,m)+=f(n,m-n)$,以此类推，放在排列中的其他位置就是$f(n+1,m)=f(n,m-i)$ 那么$f(n+1,m)=f(n,m)+f(n,m-1)+f(n,m-2)+…+f(n,m-n)$ 前提知识4$f(n,0)=f(n,C_n^2)=1$前提知识5$f(n,1)=f(n,C_n^2-1)=n-1$$f(n,1)=f(n-1,1)+f(n-1,0)=f(n-1,1)+1$ 前提知识6$f(n,2)=f(n,C_n^2-2)=C_n^2-1(n&gt;2)$由3，4，5可知 $f(n,2)=f(n-1,2)+f(n-1,1)+f(n-1,0)=f(n-1,2)+n-1$ 根据$f(2,2)=0$可证 同理： $f(n,3)=C_n^3-C_n^2-C_n^1(n&gt;3)$ $f(n,4)=C_n^4+2C_n^3-C_n^1(n&gt;4)$ $f(n,5)=C_n^4+3C_n^4+2C_n^3-C_n^2+1(n&gt;5)$ $….$ 问题2给定逆序数，求满足此逆序数的最小排序 前提知识1对于n的全排列，在它完全倒序的时候逆序数最多 前提知识2对于一个形如$1,2,3,…,i-1,i,n,…,i+1$的排列$q$，在数$n$前保证首项为1，且严格以公差为1递增而数n以后排列任意的数列 当数$n$之后是递减的时候$q$的逆序数最多，$t=C_{n-i}^{2}$ 排列$q$是出现逆序对为$t$的最小排列 前提知识3我们把数$n$之后的第$k$小数与数$n$的前一个数(即$i$)交换，然后是数$n$后面保持逆序，这样得到的新排列的逆序对数为 $t=C_{n-i}^2+k$,且这个排列是逆序数$t$的最小排列","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"逆序对","slug":"逆序对","permalink":"http://orzff.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"全排列","slug":"全排列","permalink":"http://orzff.cn/tags/%E5%85%A8%E6%8E%92%E5%88%97/"}]},{"title":"牛客多校第九场","slug":"牛客多校第九场","date":"2019-08-16T09:21:39.000Z","updated":"2021-05-31T11:58:01.212Z","comments":true,"path":"/8ea435a5/","link":"","permalink":"http://orzff.cn/8ea435a5/","excerpt":"牛客多校第九场","text":"A: The Power of Fibonacci题意给你n,m,求$\\sum\\limits_{i=1}^{n}F_i^m \\mod 1e9，F$是斐波那契数列 思路首先斐波那契数列在模意义下是有循环节的，而在$1e9$下的循环节有太大， 所以我们把$1e9$分为两个互质数字的乘积$512*1953125$,而在这两个模下的循环节是可以接受的 然后我们分别算出一个结果用中国剩余定理求出答案就行了 注意快速幂模的时候有模$1e9$不然会T，可能是别的模数取模次数太多造成的超时 做完我傻了 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int Mod = 1000000000; int Ksm(int a, int b, int p) { int res = 1; while(b) { if(b &amp; 1) res = 1ll * res * a % p; a = 1ll * a * a % p; b &gt;&gt;= 1; } return res; } const int maxn = 1e7+5; int mod[2] = {512, 1953125}; int f[maxn], ans[2] = {0, 0}; int ex_gcd(int a, int b, int &amp;x, int &amp;y) { if(!b) { x = 1; y = 0; return a; } int d = ex_gcd(b, a%b, x, y); int t = x; x = y; y = t - a/b*y; return d; } int inv(int a, int p) { int x, y; ex_gcd(a, p, x, y); return (x % p + p) % p; } int main() { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int k = 0; k &lt;= 1; k ++) { int j = 2; f[0] = 0; f[1] = 1; for (; ; j ++) { f[j] = (f[j-1] + f[j-2]) % mod[k]; if(f[j] == 0 &amp;&amp; f[j-1] == 1) break; } for (int i = 0; i &lt; j; i ++) { int nr = n/j; if(n % j &gt;= i) nr ++; ans[k] = (ans[k] + 1ll * Ksm(f[i], m, Mod) * nr) % mod[k]; } } int Inv = inv(mod[0], mod[1]); ll res = 1ll * (ans[1] - ans[0] + Mod) % Mod * mod[0] * Inv + ans[0]; printf(\"%d\\n\", res%Mod); return 0; } B: Quadratic equation题意$x+y\\equiv b\\mod p, x\\cdot y\\equiv c \\mod p$ 求$x,y$ 思路二次剩余基础题，可惜我不会 根据初中知识我们可以化成这样$(x-\\frac{b}{2})^2\\equiv \\frac{b^2-4c}{4} \\mod p$ 下面就是验证$\\frac{b^2-4c}{4}$是否是模$p$下的二次剩余,模板题 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; struct T{ ll p, d; }; ll Ksm(ll a, ll b, ll p) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res; } ll w; //二次域乘法 T Mul_er(T a, T b, ll p) { T ans; ans.p = (a.p * b.p + a.d * b.d % p * w % p) % p; ans.d = (a.p * b.d % p + a.d * b.p % p) % p; return ans; } //二次域快速幂 T Ksm_er(T a, ll b, ll p) { T ans; ans.p = 1; ans.d = 0; while(b) { if(b &amp; 1) ans = Mul_er(ans, a, p); a = Mul_er(a, a, p); b &gt;&gt;= 1; } return ans; } //求勒让德符号 ll Legendre(ll a, ll p) { return Ksm(a, (p-1)&gt;&gt;1, p); } ll Recever(ll a, ll p) { a %= p; if(a &lt; 0) a += p; return a; } ll solve(ll n, ll p) { if(n % p == 0) return 0; if(p == 2) return 1; if(Legendre(n, p) + 1 == p) return -1; ll a = -1, t; while(1) { a = rand() % p; t = a * a - n; w = Recever(t, p); if(Legendre(w, p) + 1 == p) break; } T tmp; tmp.p = a; tmp.d = 1; T ans = Ksm_er(tmp, (p+1)&gt;&gt;1, p); return ans.p; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { ll b, c; scanf(\"%lld %lld\", &amp;b, &amp;c); ll t = ((b * b - 4 * c) % mod + mod) % mod; ll x = solve(t, mod); if(x == -1) { puts(\"-1 -1\"); continue; } x = (x + b) % mod * Ksm(2, mod-2, mod) % mod; ll y = (b - x + mod) % mod; if(x &gt; y) swap(x, y); printf(\"%lld %lld\\n\", x, y); } return 0; } C: Inversions of all permutations题意$\\sum\\limits_{r_i is a permutation of \\{a_i\\}}b^{t(r_i)}\\mod 1e9+7$ 求$b$的序列$a$的全排列的逆序对次幂之和 思路对于一个没有重复数字的序列，其逆序数为 1: 1 2: 1 1 3: 1 2 2 1 4: 1 3 5 6 5 3 1 3:1 2 2 1 代表长度为$3$的序列的逆序数为$0$的有$1$个，逆序数为$1$的有$2$个，逆序数为$3$的有$2$个，逆序数为$3$的有$3$个 我们用$dp$来代表答案，那么长度为$3$的答案就是$dp[3]=b^0+2b^1+2b^2+b^3$ 而$dp$转移是有规律的$dp[i] = dp[i-1]\\times \\sum\\limits_{j=0}^{i-1}b^j$ 而对于有重复数字的序列，其结果就是$\\frac{dp[n]}{\\prod dp[重复次数]}$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; ll dp[maxn], cnt[maxn], pre[maxn]; ll Ksm(ll a, ll b) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } int main() { int n, b; scanf(\"%d %d\", &amp;n, &amp;b); dp[0] = 1; for (int i = 1; i &lt; maxn; i ++) dp[i] = 1ll * dp[i-1] * b % mod; for (int i = 1; i &lt; maxn; i ++) dp[i] = dp[i] + dp[i-1] % mod; pre[1] = 1; for (int i = 2; i &lt; maxn; i ++) pre[i] = 1ll * pre[i-1] * dp[i-1] % mod; ll sum = pre[n]; for (int i = 1; i &lt;= n; i ++) { int x; scanf(\"%d\", &amp;x); cnt[x] ++; } for (int i = 0; i &lt; maxn; i ++) { if(cnt[i] &gt; 1) sum = 1ll * sum * Ksm(pre[cnt[i]], mod-2) % mod; } printf(\"%lld\\n\", sum); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"二次剩余","slug":"二次剩余","date":"2019-08-16T00:35:12.000Z","updated":"2021-05-31T11:58:01.178Z","comments":true,"path":"/98066e3c/","link":"","permalink":"http://orzff.cn/98066e3c/","excerpt":"二次剩余","text":"二次剩余定义对于$P, n$ 如果存在$x$使得 $x^2 \\equiv n \\mod P$ 则称$n$是模$P$意义下的二次剩余 定理对于$x^2\\equiv n(mod p)$ 总共有$\\frac{p-1}{2}$ 个n能使得方程有解 证明考虑所有的$x^2$ ,如果存在两个不同的数字$1&lt; u,v &lt; p$,$u^2\\equiv v^2(\\mod p)$ ,那么显然$(u^2-v^2)\\mod p==0$ 即$(u+v)(u-v)\\mod p == 0$ ，那么就只能是$u+v\\equiv 0(\\mod p)$，两个数字相互对应，所有共有$\\frac{p-1}{2}$个不同的平方 勒让德符号定义 $(\\frac{a}{p})= \\begin{cases} 1, &amp; a在模p意义下是二次剩余\\\\ -1，&amp; a在模p意义下是非二次剩余 \\\\ 0, &amp; a\\equiv 0 (mod p) \\end{cases}$ 定理$(\\frac{a}{p})\\equiv a^{\\frac{p-1}{2}}(\\mod p)$ 证明1.若$a$是模p下的二次剩余，那么存在$x^2\\equiv a (\\mod p)$ ,那么$x^{p-1}\\equiv a^{\\frac{p-1}{2}}\\equiv (\\frac{a}{p})\\equiv 1(\\mod p)$ 根据费马小定理 在$a$是模$p$意义下的二次剩余时$x^{p-1} \\equiv 1(\\mod p)$显然成立 2.若$a$是模$p$意义下的非二次剩余,那么跟上面同理，显然不存在$x^{p-1}\\equiv -1(\\mod p)$ 3.当$a\\equiv 0(\\mod p)$显然满足 开根复数域我们先定义一个数域$\\mathsf{F_p}$定义为$0$到$p-1$这$p$个数在模$p$意义下加减乘除构成的集合 数域$\\mathsf{F_{p^2}}$定义为一个开根的复数域，即如果一个$a^2-n$不能开根$(勒让德符号(\\frac{a}{p})=-1)$ ，那么我们加上一个复数域 就可以开根,(类似$\\sqrt{-1}$我们加上一个复数域就可以开根)，我们另这个不能开根的数字$\\sqrt{a^2-n}$为复数域的”虚数单位元”$(类似\\sqrt{-1})$ 并设它为$w$ ,那么则任意一个复数域的数字都可以表示为$a+bw$($a$是实部，$b$是虚部，$w$是虚数单位元) $\\mathsf{F_{p^2}}$数域满足不同复数域的所有四则运算 定理$w^p\\equiv -w(\\mod p)$ 证明$w^p\\equiv w\\cdot w^{p-1} \\equiv w\\cdot (w^2)^{\\frac{p-1}{2}}\\equiv w\\cdot (a^2-n)^{\\frac{p-1}{2}} \\equiv -w (\\mod p)$ 定理$(a+b)^n\\equiv a^n+b^n(\\mod n)(n \\in P)$ 证明有二项式定理可知: $(a+b)^n\\equiv \\sum\\limits_{i=0}^{n}C_n^ia^ib^{n-i}(\\mod n)$ 因为n是一个质数，所以除了$i=0,i=n$时，其他的$C_n^i$是无法别消除这能模$p$模成$0$ 二次剩余证明我们首先随机出来一个$a$,使得$(\\frac{a^2-n}{p})$为-1，也就是不能开根，然后我们把他定义为复数域的单位根 $w=\\sqrt{a^2-n}$ 那么我们求$x^2\\equiv n(\\mod p)$ $x^2\\equiv n\\equiv a^2-(a^2-n)\\equiv a^2-w^2$ $\\equiv (a-w)(a+w)\\equiv (a^p+w^p)(a+w)(a满足费马小定理 a^{p-1}\\equiv 1(\\mod p))$ $\\equiv (a+w)^p(a+w)\\equiv (a+w)^{p+1}$ $所以x\\equiv (a+w)^{\\frac{p+1}{2}}$ 代码struct T{ long long p, d; }; long long Ksm(long long a, long long b, long long p) { long long res = 1; while(b) { if(b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res; } long long w; //二次域乘法 T Mul_er(T a, T b, long long p) { T ans; ans.p = (a.p * b.p + a.d * b.d % p * w % p) % p; ans.d = (a.p * b.d % p + a.d * b.p % p) % p; return ans; } //二次域快速幂 T Ksm_er(T a, long long b, long long p) { T ans; ans.p = 1; ans.d = 0; while(b) { if(b &amp; 1) ans = Mul_er(ans, a, p); a = Mul_er(a, a, p); b &gt;&gt;= 1; } return ans; } //求勒让德符号 long long Legendre(long long a, long long p) { return Ksm(a, (p-1)&gt;&gt;1, p); } long long Recever(long long a, long long p) { a %= p; if(a &lt; 0) a += p; return a; } long long solve(long long n, long long p) { if(n % p == 0) return 0; if(p == 2) return 1; if(Legendre(n, p) + 1 == p) return -1; long long a = -1, t; while(1) { a = rand() % p; t = a * a - n; w = Recever(t, p); if(Legendre(w, p) + 1 == p) break; } T tmp; tmp.p = a; tmp.d = 1; T ans = Ksm_er(tmp, (p+1)&gt;&gt;1, p); return ans.p; } ll x = solve(n, p); x==-1无解，否则 x和p-x都是合法解","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二次剩余","slug":"二次剩余","permalink":"http://orzff.cn/tags/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"}]},{"title":"牛客多校第八场","slug":"牛客多校第八场","date":"2019-08-15T02:46:22.000Z","updated":"2021-05-31T11:58:01.214Z","comments":true,"path":"/f46914fa/","link":"","permalink":"http://orzff.cn/f46914fa/","excerpt":"牛客多校第八场","text":"J:Just Jump题意给你一个长度为L的路径，你起始点在0号点，每次最少移动d步，而且在$t_i$时刻$p_i$点会遭遇攻击 问你到达L点有多少种方法 思路首先不考虑攻击，到达L点的方法就是一个简单dp $dp[n]=dp[0]+dp[1]+dp[2]+..+dp[n-d]$ 可以用前缀和维护一下，这样dp的复杂度就是O(L) 那么考虑攻击的时候呢，一个明显的思路就是我们已经用dp算出了总的方法数， 那么我们把受到攻击是的路线减去就是不受攻击到达L的方法数 那么当我们在$(t_i,p_i)$受到攻击的方法数是多少呢，我们先把攻击按照位置从小到大排序，时间从小到大排序 首先我们肯定是从$[0,p_i-d]$这些点数转移来的，并且前面的$t_i-1$步每次最少走d步 那么我们在减去$(t_i-1)(d-1)$就变成从最少有1步，那么就是从$[1,p_i-d-(t_i-1)(d-1)]$找$t_i-1$个点，也就是组合数$C_{p_i-t_id+t_i-1}^{t_i-1}$ 但是现在又有了一个问题，就是用$C_{p_i-t_id+t_i-1}^{t_i-1}$ 来计算 我们计算了0—&gt;D的所有路径，但是其中包括了从C到D的路径，而这部分路径因为C的被攻击所以是无效的（C被攻击的时间小于D，C在D之前被攻击），所以我们要减去（C—&gt;D）这部分路径 这样我们就把从0开始$t_i$时刻到达攻击点$p_i$ 的路径数$f[i]$全部算了出来，那么结果就是$dp[L]-=\\sum\\limits_{i=1}^{m}f[i]*dp[L-node[i].p]$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e7; const int mod = 998244353; ll Fac[maxn+5], inv[maxn+5], f[3005]; ll pref[maxn+5], sum[maxn+5]; ll L, d, m; struct Node{ ll t, p; bool friend operator &lt; (Node a, Node b) { if(a.p == b.p) return a.t &lt; b.t; return a.p &lt; b.p; } }node[3005]; ll Ksm(ll a, ll b) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } void init() { Fac[0] = 1; for (int i = 1; i &lt;= maxn; i ++) Fac[i] = (Fac[i-1]*i) % mod; inv[maxn] = Ksm(Fac[maxn], mod-2); for (int i = maxn-1; i &gt;= 0; i --) inv[i] = inv[i+1] * (i+1) % mod; } ll Calc(ll t, ll p) { if(p-t*d+t-1 &lt; t-1) return 0; return Fac[p-t*d+t-1]*inv[t-1]%mod*inv[p-t*d]%mod; } int main() { init(); scanf(\"%lld %lld %lld\", &amp;L, &amp;d, &amp;m); for (int i = 1; i &lt;= m; i ++) scanf(\"%lld %lld\", &amp;node[i].t, &amp;node[i].p); sort(node+1, node+1+m); for (int i = 1; i &lt;= m; i ++) { f[i] = Calc(node[i].t, node[i].p); for (int j = 1; j &lt; i; j ++) if(node[i].t &gt; node[j].t) f[i] = (f[i] - f[j]*Calc(node[i].t-node[j].t, node[i].p-node[j].p)%mod + mod) % mod; } sum[0] = 1; pref[0] = 1; for (int i = 1; i &lt;= L; i ++) { if(i &lt; d) sum[i] = 0; else sum[i] = pref[i-d]; pref[i] = (pref[i-1]+sum[i]) % mod; } ll ans = sum[L]; for (int i = 1; i &lt;= m; i ++) ans = (ans - f[i] * sum[L-node[i].p] % mod + mod) % mod; printf(\"%lld\\n\", ans); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"牛客多校第七场","slug":"牛客多校第七场","date":"2019-08-15T01:12:19.000Z","updated":"2021-05-31T11:58:01.212Z","comments":true,"path":"/68238393/","link":"","permalink":"http://orzff.cn/68238393/","excerpt":"牛客多校第二场","text":"H:Pair题意给你3个数字$A,B,C$,让你计算$1\\leq x\\leq A,1\\leq y\\leq B$,并且$(x$ $and$ $y)&gt;C$或者$(x$ $xor$ $y)&lt;C$ 这样的 $$有多少对 思路很像数位dp，枚举二进制的每一位，4种状态分别是（A临界，B临界，A$and$B临界，A$xor$B临界） 这样直接数位dp可以算出有多少对不满足条件，然后用总数减去 因为$x,y&gt;1$,所有要在数位dp算出的结果中减去x为0时和y为0时的数量 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long ll dp[35][2][2][2][2]; int num_a[35], num_b[35], num_c[35]; void GetNum(ll a, ll b, ll c) { memset(num_a, 0, sizeof(num_a)); memset(num_b, 0, sizeof(num_b)); memset(num_c, 0, sizeof(num_c)); num_a[0] = 0; while(a) { num_a[++num_a[0]] = a % 2; a /= 2; } num_b[0] = 0; while(b) { num_b[++num_b[0]] = b % 2; b /= 2; } num_c[0] = 0; while(c) { num_c[++num_c[0]] = c % 2; c /= 2; } } ll dfs(int pos, int a, int b, int an, int xo) { if(!pos) return 1; if(dp[pos][a][b][an][xo] != -1) return dp[pos][a][b][an][xo]; int ua = a ? num_a[pos] : 1; int ub = b ? num_b[pos] : 1; int uan = an ? num_c[pos] : 1; int uxo = xo ? num_c[pos] : 0; ll ret = 0; for (int i = 0; i &lt;= ua; i ++) for (int j = 0; j &lt;= ub; j ++) if((i&amp;j) &lt;= uan &amp;&amp; (i^j) &gt;= uxo) ret += dfs(pos-1, a&amp;&amp;(i==ua), b&amp;&amp;(j==ub), an&amp;&amp;((i&amp;j)==uan), xo&amp;&amp;((i^j)==uxo)); return dp[pos][a][b][an][xo] = ret; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { ll a, b, c; scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c); GetNum(a, b, c); memset(dp, -1, sizeof(dp)); ll ans = dfs(32, 1, 1, 1, 1) - max(0ll, a-c+1) - max(0ll, b-c+1); cout &lt;&lt; a*b-ans &lt;&lt; endl; } return 0; } I:Chessboard题意给你一个N，M，然后你可以任意构造一个 k * k的矩阵，使得矩阵内每个元素最少是M，且任意不同行不同列的 k 个元素总和不超过N且都相同，问有多少种构造方法。 思路 我们枚举$k$，我们可以把每个元素减去$M$，那么就相当于$N$减去$ k \\times M$,简化问题并且不影响答案 构造两个矩阵$Ai,Bi $对于这两个矩阵，我们可知他们前面的系数和为$T$则满足结果 等价于将$T$ 分成$2\\times k$份($a$，$b$各有$k$个)采用隔板法 （将$T$ 转换成$1$排，每两个$1$之间有一个隔间，那么$k \\times 2 + T$有$k \\times 2 - 1 +T$个​隔间，我们选择$k \\times 2 - 1$个隔间就可以把这些$1$分成$k \\times 2$份 为什么会算重，我们拿$T=3,k=2$来举个例子，比如$a_1=1,a_2=2,b_1=0,b_2=0$ 那这个矩阵就是长这个样子 $\\begin{bmatrix} a_1+b_1 &amp;a_1+b_2 \\\\\\ a_2+b_1 &amp;a_2+b_2 \\end{bmatrix}$ $==&gt;$ $\\begin{bmatrix} 1 &amp; 1\\\\ 2 &amp;2 \\end{bmatrix}$ 跟$\\begin{bmatrix} a_1-1+b_1+1 &amp;a_1-1+b_2+1\\\\ a_2-1+b_1+1 &amp;a_2-1+b_2+1 \\end{bmatrix}$ $==&gt;$ $\\begin{bmatrix} 1 &amp; 1\\\\ 2 &amp;2 \\end{bmatrix}$ 是相同的，也就是当$a_i$全部减1，而$b_i$全部加1时，跟原来的矩阵相同，所以这就重复了,那去重也就是这样去 PS:这篇博客其实是我扒CM大佬的=^= AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; const int inf = 0x3f3f3f3f; const int mod = 998244353; ll fac[maxn], inv[maxn]; ll Ksm(ll a, ll b, ll p) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res; } void Fac() { fac[0] = 1; for (int i = 1; i &lt; maxn; i ++) fac[i] = (fac[i-1] * i) % mod; inv[maxn-1] = Ksm(fac[maxn-1], mod-2, mod); for (int i = maxn-2; i &gt;= 0; i --) inv[i] = inv[i+1] * (i+1) % mod; } ll C(int n, int m) { if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0; return fac[n] * inv[m] % mod * inv[n-m] % mod; } int main() { Fac(); int T; scanf(\"%d\", &amp;T); while(T --) { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); ll ans = 0; for (int k = 1; k * m &lt;= n; k ++) { int tt = n - k*m; for (int t = 0; t &lt;= tt; t ++) { ans += C(t+k+k-1, k+k-1); if(t &gt;= k) ans -= C(t+k-1, k+k-1); ans = (ans % mod + mod) % mod; } } printf(\"%lld\\n\", ans); } return 0; } K:Function题意$csl(p,x)= \\begin{cases} 3e+1 &amp; x=p^e\\&amp; p\\in prime \\&amp; p = a^2+b^2\\\\1 &amp; x=p^e \\&amp; p!= a^2+b^2\\\\0 &amp; others\\end{cases}$ $tl(p,x)=\\max\\limits_{d|x}csl(p,d)$ 求$S=\\sum\\limits_{i=1}^{n}\\prod\\limits_{p} tl(p,i)$ 思路可得知 $tl(p,x)=\\begin{cases}3e+1&amp; x=p^e\\&amp; p\\in prime \\&amp;p=a^2+b^2 \\\\1 &amp; others\\end{cases}$ $f(x)=\\prod\\limits_{d|n}\\begin{cases}3e+1&amp; x=p^e\\&amp; p\\in prime \\&amp;p=a^2+b^2 \\\\1 &amp; others\\end{cases}$ 答案就是$f(i)$的前缀和,即$S=\\sum\\limits_{i=1}^{n}f(i)$ 我们先不考虑$p=a^2+b^2$，考虑$i$为质数时的情况$f(i)=3+1$ $i$为质数次幂的情况$f(p^e)=3e+1$ 这样可以快速算出i为质数和i的质数次幂的情况 可以用$min_25$筛来求这个前缀和 那么现在我们来考虑$p=a^2+b^2$这个限制，因为$min_25$筛由构造一个函数，把所有数字看成质数， 我们可以设$h[i][4]$，来代表i以前由多少数字余数为$0，1，2，3$，通过dp可以得到有多少质数余数为$0，1，2，3$ 因为费马二次定理，我们知道模$4$与$1$的可以分解成$a^2+b^2$，而模$4$余$3$的一定不行，那么质数部分我们就都算出来了，下面的合数部分就用$min_25$筛就好了 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; ll sum[maxn][4], prime[maxn], tot, h[maxn][4]; ll w[maxn], m, id1[maxn], id2[maxn]; ll sqr; bool vis[maxn]; ll f(ll p, ll e) { if(p % 4 == 1) return 3 * e + 1; return 1; } ll init(ll n) { for (int i = 0; i &lt; 4; i ++) sum[0][i] = 0; for (int i = 1; i &lt;= n; i ++) vis[i] = 0; vis[1] = 1; tot = 0; for (int i = 2; i &lt;= n; i ++) { if(!vis[i]) { prime[++tot] = i; for (int j = 0; j &lt; 4; j ++) sum[tot][j] = sum[tot-1][j] + (i % 4 == j); } for (int j = 1; j &lt;= tot; j ++) { if(i * prime[j] &gt; n) break; vis[i*prime[j]] = 1; if(i % prime[j] == 0) break; } } } void getW(ll n) { m = 0;//离散下标 for (ll l = 1, r; l &lt;= n; l = r + 1) { r = n/(n/l); w[++m] = n/l;//把所有数字当成质数 h[m][1] = w[m] / 4 + (w[m] % 4 &gt;= 1) - 1; h[m][2] = w[m] / 4 + (w[m] % 4 &gt;= 2); h[m][3] = w[m] / 4 + (w[m] % 4 &gt;= 3); h[m][4] = w[m] / 4; if(w[m] &lt;= sqr) id1[w[m]] = m; else id2[n/w[m]] = m; } } void getG(ll n) {//dp都质数模4的个数 for (ll i = 1; i &lt;= tot; i ++) { for (ll j = 1; j &lt;= m &amp;&amp; prime[i] * prime[i] &lt;= w[j]; j ++) { ll d = w[j] / prime[i]; ll id = d &lt;= sqr ? id1[d] : id2[n/d]; for (int r = 0; r &lt; 4; r ++) h[j][r*prime[i]%4] = h[j][r*prime[i]%4] - h[id][r] + sum[i-1][r]; } } } ll S(ll x, ll y, ll n) { if(x &lt;= prime[y-1] || x &lt;= 1) return 0; ll id = x &lt;= sqr ? id1[x] : id2[n/x]; ll ans = h[id][3] - sum[y-1][3] + 4 * (h[id][1] - sum[y-1][1]);//模4余1的值为4，余3的值为1 if(y == 1) ans ++; for (ll i = y; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= x; i ++) { ll t = prime[i]; for (int j = 1; t &lt;= x; j ++, t = t * prime[i]) ans = ans + f(prime[i], j) * (S(x/t, i+1, n) + (j != 1)); } return ans; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { ll n; scanf(\"%lld\", &amp;n); sqr = sqrt(n); init(sqr); getW(n); getG(n); printf(\"%lld\\n\", S(n, 1, n) + 1);//S(n,1,n)+f(1) } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"牛客多校第五场","slug":"牛客多校第五场","date":"2019-08-14T02:35:51.000Z","updated":"2021-05-31T11:58:01.214Z","comments":true,"path":"/b40c00ff/","link":"","permalink":"http://orzff.cn/b40c00ff/","excerpt":"牛客多校第五场","text":"B:generator 1题意给你$x_0,x_1,a,b, x_i=ax_{i-1}+bx_{i-2}$让你求出$x_n$ 思路典型的矩阵快速幂，但是n的范围太大，所以得快速幂得用十进制快速幂 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e6 + 5; ll mod; struct Matrix{ ll mat[2][2]; Matrix() {memset(mat, 0, sizeof(mat));}; void init() { mat[0][0] = mat[1][1] = 1; } void init(ll a, ll b) { mat[0][0] = 0; mat[0][1] = b; mat[1][0] = 1; mat[1][1] = a; } void operator = (Matrix x) { for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) mat[i][j] = x.mat[i][j]; } }; void Print(Matrix x) { for (int i = 0; i &lt;= 1; i ++) { for (int j = 0; j &lt;= 1; j ++) cout &lt;&lt; x.mat[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl; } } Matrix operator * (Matrix x, Matrix y) { Matrix t; for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) for (int k = 0; k &lt;= 1; k ++) t.mat[i][j] = (t.mat[i][j] + x.mat[i][k] * y.mat[k][j]) % mod; return t; } Matrix Ksm(Matrix x, ll b) { //cout &lt;&lt; b &lt;&lt; endl; Matrix t; t.init(); while(b) { if(b &amp; 1) t = t * x; x = x * x; b &gt;&gt;= 1; } //Print(t); return t; } int main() { ll x0, x1, a, b; scanf(\"%lld %lld %lld %lld\", &amp;x0, &amp;x1, &amp;a, &amp;b); char s[maxn]; scanf(\"%s%lld\", s, &amp;mod); int len = strlen(s); reverse(s, s+len); Matrix t, ans; t.init(a, b); ans.mat[0][0] = x0; ans.mat[0][1] = x1; Matrix res; res.init(); for (int i = 0; i &lt; len; i ++) { res = res * Ksm(t, s[i]-'0'); t = Ksm(t, 10); // Print(res); // Print(t); } ans = ans * res; printf(\"%lld\\n\", ans.mat[0][0]); return 0; } C:generator 2题意有这么一个递推式$x_i=(a\\cdot x_{i-1}+b)\\mod p$，让你求$v$在$[1,n-1]$中第一次出现的位置 思路因为递推式模$p$，所以$x$的循环节一定小于$p$， 而$x$又是这种形式$x_n=a(a(a(ax+b)+b)+b)+b$ 所以我们的任务就变成$A^{m} \\equiv v\\mod p$求最小的$m$ ${A^1=x,A^2=(ax+b),A^3=a(ax+b)+b,A^4=a(a(ax+b)+b)+b)+b}$ 而$A^m\\equiv v\\mod p$明显可以用BSGS 但是BSGS的一个使用条件能不能求出$A^{-i*S}$ 但是我们怎么求出$A^{-i*S}$呢 正常的加是乘a加b，那么除就是除a减$\\frac{b}{a}$ 举个例子: $x_0=x,x_1=ax+b,x_2=a(ax+b)+b,x_3=a(a(ax+b)+b)+b$ 我们从$x_3$降到$x_1$,$x_3$先除$a$再减去$\\frac{b}{a}$变成$x_2$，然后再除$a$减去$\\frac{b}{a}$变成$x_1$ 那我们从$A^{2S+j}$降到$A^{S+j}$只需要进行$S$次操作即可 这样我们就可以用BSGS了 跟BSGS的步骤差不多，我们可以把式子化成 $A^{i*S+j}\\equiv v\\mod p$ 我们可以预处理出来$A^S$ ，然后遍历找到一个$A^j\\equiv vA^{-iS}\\mod p$ 也就是说在这个式子中$A^{-i*S}$不是一个值，而是一种操作，把$v$所代表的次数降下$S$ $x_0=1,x_1=2*1+1,x_2=,x_4=15,x_5=31$ 因为我们已经预处理了一个$A^S$,那么在我们遍历$i$的过程中每次降下一个$S$，知道找到或者找不到 用Hash存一下$A^j$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long typedef pair&lt;int, int&gt;pis; const int limit = 1e6; pis d[limit+6]; int vals[limit+6], pos[limit+6]; int Ksm(ll a, int b, int p) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res; } int inv(int a, int p) { return Ksm(a, p-2, p); } void solve() { ll n, x0, a, b, p; int Q; scanf(\"%lld %lld %lld %lld %lld %d\", &amp;n, &amp;x0, &amp;a, &amp;b, &amp;p, &amp;Q); if(!a) { while(Q --) { int v; scanf(\"%d\", &amp;v); if(v == x0) printf(\"0\\n\"); else if(v == b) printf(\"1\\n\"); else printf(\"-1\\n\"); } return ; } d[0] = {x0, 0}; for (int i = 1; i &lt;= limit; i ++) { int val = (a*d[i-1].first+b) % p; d[i] = {val, i}; } sort(d, d+limit+1); int cnt = 0; for (int i = 0; i &lt;= limit; i ++) { vals[cnt] = d[i].first; pos[cnt++] = d[i].second; while(d[i].first == d[i+1].first &amp;&amp; i+1 &lt;= limit) i++; } int inv_a = inv(a, p); int inv_b = (p-b) % p * inv_a % p; ll aa = 1, bb = 0; for (int i = 0; i &lt;= limit; i ++) { aa = aa * inv_a % p; bb = (bb * inv_a + inv_b) % p; } while(Q --) { int v; scanf(\"%d\", &amp;v); int it = lower_bound(vals, vals+cnt, v) - vals; if(it &lt; cnt &amp;&amp; vals[it] == v) { if(pos[it] &lt; n) printf(\"%d\\n\", pos[it]); else printf(\"-1\\n\"); continue; } int m = p/(limit+1) + 3, flag = 0; for (int i = 1; i &lt;= m; i ++) { v = (aa * v + bb) % p; it = lower_bound(vals, vals+cnt, v) - vals; if(it&lt;cnt &amp;&amp; vals[it] == v) { flag = 1; int res = i*(limit+1)+pos[it]; if(res&gt;=n) res = -1; printf(\"%d\\n\", res); break; } } if(!flag) printf(\"-1\\n\"); } } int main() { int T; scanf(\"%d\", &amp;T); while(T --) solve(); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"牛客多校第二场","slug":"牛客多校第二场","date":"2019-08-11T12:51:17.000Z","updated":"2021-05-31T11:58:01.213Z","comments":true,"path":"/3bd8/","link":"","permalink":"http://orzff.cn/3bd8/","excerpt":"牛客多校第二场","text":"A:Eddy Walker题意给你一个n的点的环，一开始从0号点开始，每次可以前进1或者后退1，问第一次站在m号点的时候已经遍历完所有点的概率，求出前缀概率积 思路一： 暴力打表找规律 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; double p[10]; bool vis[10]; int n; bool Check() { for (int i = 0; i &lt; n; i ++) if(!vis[i]) return false; return true; } void dfs(int idx, double px) { if(px &lt; 1e-10) return ; vis[idx] = 1; if(!Check()) { int nxt = (idx+1)%n; int tmp = vis[nxt]; vis[nxt] = 1; dfs(nxt, px*0.5); vis[nxt] = tmp; nxt = (idx-1+n)%n; tmp = vis[nxt]; vis[nxt] = 1; dfs(nxt, px*0.5); vis[nxt] = tmp; }else p[idx] += px; } int main() { for (n = 1; n &lt;= 7; n ++) { printf(\"n: %d\\n\", n); memset(p, 0, sizeof(p)); memset(vis, 0, sizeof(vis)); dfs(0, 1); for (int i = 0; i &lt; n; i ++) { printf(\"i: %d, p: %lf\\n\", i, p[i]); } } return 0; } 这是打表的结果，可以发现结果与m无关(当m&gt;0时)而且近似为$\\frac{1}{n-1}$ 二：数学分析:因为是最后站在一个非0的位置上，而每个非零的点的最后一次到达的概率是相同的，所以是$\\frac{1}{n-1}$ B:Eddy Walker2题意现在是给你一条链，从0点出发，一个最多走k步，每一步的概率都是$\\frac{1}{k}$ ,问最后走到n的概率 思路根据题意可以写出一个递推式子： $dp[i] = \\frac{1}{k}\\sum\\limits_{i=1}^{k}dp[n-i]$ 如果n很小的话，可以直接用dp来写，但是n的大小是$1e^{9}$，所以我们就得用BM直接套板子线性递推 但是有一个问题，就是n可能为无穷，我们可以这样来写， 我们每次行动的移动记录期望是$\\frac{1}{k}\\sum\\limits_{i=1}^{k}i=\\frac{(k+1)k}{2k}=\\frac{k+1}{2}$ ,也就是每行动一次大概移动$\\frac{k+1}{2}$ ，而我们移动到n的次数可能为m次，那么移动的距离期望就是$\\frac{(k+1)m}{2}$ 而n在其中，在这$\\frac{(k+1)m}{2}$个点中，我们一共会走m个点，那么就是n在这m个点之间的概率$\\frac{1}{m}$ , 期望就是$m$ ,而在整体的概率就是$\\frac{m}{\\frac{(k+1)m}{2}}=\\frac{2}{k+1}$ $dp[i]=\\begin{cases} \\frac{1}{k}\\cdot (dp[i-1]+dp[i-2]+…+dp[i-k]),i&gt;=k\\\\ \\frac{2}{k+1},i=\\infty \\\\\\end{cases}$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll mod = 1e9 + 7; #define sz(x) ((int)(x).size()) typedef vector&lt;ll&gt; VI; ll Ksm(ll a, ll b) { ll res = 1; a %= mod; assert(b &gt;= 0); while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } int _, n; namespace Linear_Seq{ const int N = 10010; ll res[N], base[N], _c[N], _md[N]; vector&lt;int&gt; Md; void Mul(ll *a, ll *b, int k) { for (int i = 0; i &lt; k+k; i ++) _c[i] = 0; for (int i = 0; i &lt; k; i ++) if(a[i]) for (int j = 0; j &lt; k; j ++) _c[i+j] = (_c[i+j] + a[i]*b[j]) % mod; for (int i = k + k - 1; i &gt;= k; i --) if(_c[i]) for (int j = 0; j &lt; sz(Md); j ++) _c[i-k+Md[j]] = (_c[i-k+Md[j]] - _c[i] * _md[Md[j]]) % mod; for (int i = 0; i &lt; k; i ++) a[i] = _c[i]; } int solve(ll n, VI a, VI b) { ll ans = 0, pnt = 0; int k = sz(a); assert(sz(a) == sz(b)); for (int i = 0; i &lt; k; i ++) _md[k-1-i] = -a[i]; _md[k] = 1; Md.clear(); for (int i = 0; i &lt; k; i ++) if(_md[i]) Md.push_back(i); for (int i = 0; i &lt; k; i ++) res[i] = base[i] = 0; res[0] = 1; while((1ll&lt;&lt;pnt) &lt;= n) pnt ++; for (int p = pnt; p &gt;= 0; p --) { Mul(res, res, k); if((n&gt;&gt;p) &amp; 1) { for (int i = k-1; i &gt;= 0; i --) res[i+1] = res[i]; res[0] = 0; for (int j = 0; j &lt; sz(Md); j ++) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; } } for (int i = 0; i &lt; k; i ++) ans = (ans + res[i] * b[i]) % mod; if(ans &lt; 0) ans += mod; return ans; } VI BM(VI s) { VI C(1, 1), B(1, 1); int L = 0, m = 1, b = 1; for (int n = 0; n &lt; sz(s); n ++) { ll d = 0; for (int i = 0; i &lt; L + 1; i ++) d = (d + (ll)C[i] * s[n-i]) % mod; if (d == 0) ++m; else if(2 * L &lt;= n) { VI T = C; ll c = mod - d * Ksm(b, mod-2) % mod; while(sz(C) &lt; sz(B) + m) C.push_back(0); for (int i = 0; i &lt; sz(B); i ++) C[i+m] = (C[i+m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m = 1; }else { ll c = mod - d * Ksm(b, mod-2) % mod; while(sz(C) &lt; sz(B) + m) C.push_back(0); for (int i = 0; i &lt; sz(B); i ++) C[i+m] = (C[i+m] + c * B[i]) % mod; ++ m; } } return C; } int Gao(VI a, ll n) { VI c = BM(a); c.erase(c.begin()); for (int i = 0; i &lt; sz(c); i ++) c[i] = (mod-c[i]) % mod; return solve(n, c, VI(a.begin(), a.begin()+sz(c))); } }; using namespace Linear_Seq; void solve() { ll n, k; scanf(\"%lld %lld\", &amp;k, &amp;n); if(n == 0) { printf(\"1\\n\"); return ; }else if(n == -1) { printf(\"%lld\\n\", 2 * Ksm(k+1, mod-2) % mod); return ; } VI dp(3*k, 0), v; dp[0] = 1; v.push_back(1); for (int i = 1; i &lt;= k; i ++) { for (int j = 0; j &lt; i; j ++) dp[i] = (dp[i] + dp[j]) % mod; dp[i] = dp[i] * Ksm(k, mod-2) % mod; v.push_back(dp[i]); } for (int i = k+1; i &lt;= 2 * k; i ++) { for (int j = 1; j &lt;= k; j ++) dp[i] = (dp[i] + dp[i-j]) % mod; dp[i] = dp[i] * Ksm(k, mod-2) % mod; v.push_back(dp[i]); } printf(\"%lld\\n\", Gao(v, n)); } int main() { int T; scanf(\"%d\", &amp;T); while(T --) solve(); return 0; } E:MAZE题意给你一个NxM的地图，0表示可走，1表示不可走， 有$Q$次询问，可能会对某一位置取反，可能问你从$(1,a)$到$(n,b)$有多少走法 思路因为题目 要求不能往回走，所以如果我们从下面开始走，那么我们在横向移动是就不能改变方向，然后向上走 我们先用$dp$来考虑一下做法：设$dp[i][j]$是经由下面$dp[i-1][j]$走过来的走法数，那么从左边或右边走过来的方法数呢，我们可以在最后在加一层，那么$dp[0][j]$就加上了第1层左右到达$dp[1][j]$的方法数 那么$dp[i][j] = sum(dp[i-1][j]+dp[i-1][j-1] + … dp[i-1][j-k])+sum(dp[i-1][j+1]+dp[i-1][j+2]+…+dp[i-1][j+k])$ $dp[i][j]$由$i-1$层，$i$的左边第一个1和$i$的右边第一个1，这么一段区间里的$dp$值转移过来 比如这样一个2X6的地图, $dp[1][3]=dp[2][2]+dp[2][3]+dp[2][4]+d[2][5]$ $dp[1][4]=dp[2][2]+dp[2][3]+dp[2][4]+d[2][5]$ 由于上一层的每个值都是有下面的值组成，那么我们就可以构造出一个矩阵 这样我们就能从第$i$层转移到第$i-1$层了 现在来考虑地图修改的情况 这n个矩阵我们可以用一个线段树来维护，地图修改时用线段树来修改矩阵就行了 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 5e4 + 5; const int mod = 1e9+7; char c[maxn][15]; int dp[maxn][15]; int N, M, Q; struct Maze { int maze[15][15]; Maze() {memset(maze, 0, sizeof(maze));} void init() {for (int i = 0; i &lt; 15; i ++) maze[i][i] = 1;} Maze friend operator * (Maze a, Maze b) { Maze c; for (int i = 0; i &lt; M; i ++) for (int j = 0; j &lt; M; j ++) for (int k = 0; k &lt; M; k ++) c.maze[i][j] = (c.maze[i][j] + 1ll * a.maze[i][k] * b.maze[k][j]) % mod; return c; } }; struct Seg{ Maze w[maxn&lt;&lt;2]; void Build(int rt, int l, int r) { if(l == r) { for (int i = 0; i &lt; M; i ++) { if(c[l][i] == '0') { for (int j = i; j &gt;= 0; j --) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; for (int j = i; j &lt; M; j ++) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; } } return ; } int m = (l + r) &gt;&gt; 1; Build(rt*2, l, m); Build(rt*2+1, m+1, r); w[rt] = w[rt*2] * w[rt*2+1]; } void Updata(int rt, int l, int r, int pos) { if(l == r) { for (int i = 0; i &lt; M; i ++) for (int j = 0; j &lt; M; j ++) w[rt].maze[i][j] = 0; for (int i = 0; i &lt; M; i ++) { if(c[l][i] == '0') { for (int j = i; j &gt;= 0; j --) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; for (int j = i; j &lt; M; j ++) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; } } return ; } int m = (l + r) &gt;&gt; 1; if(pos &lt;= m) Updata(rt*2, l, m, pos); else Updata(rt*2+1, m+1, r, pos); w[rt] = w[rt*2] * w[rt*2+1]; } void Updata(int pos) { Updata(1, 1, N, pos); } }seg; int main() { scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;Q); for (int i = 0; i &lt; N; i ++) scanf(\"%s\", c[i]); for (int i = 0; i &lt; M; i ++) c[N][i] = '0'; seg.Build(1, 1, N); //seg.Print(1, 1, N); while(Q --) { int op, a, b; scanf(\"%d %d %d\", &amp;op, &amp;a, &amp;b); if(op == 1) { if(c[a-1][b-1] == '0') c[a-1][b-1] = '1'; else c[a-1][b-1] = '0'; if(a &gt; 1) seg.Updata(a-1); seg.Updata(a); } else { Maze ans = seg.w[1]; Maze t1; t1.maze[0][a-1] = 1; t1 = t1 * ans; printf(\"%d\\n\", t1.maze[0][b-1]); } } return 0; } F:Partition problen题意给你2N个人，每对人如果不在同一队的话，有一个竞争值，你要把这些人分为人数相等的两个队，使得竞争值最大 思路直接暴力 AC代码//队友代码： #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; vector&lt;int&gt; a, b; int c[30][30]; int n; ll ans = 0; void dfs(int idx, ll cur) { if(idx == 2 * n + 1) { ans = max(ans, cur); return ; } ll sum = 0; if(a.size() &lt; n) { a.push_back(idx); sum = 0; for (int &amp;v: b) sum += c[idx][v]; dfs(idx+1, cur+sum); a.pop_back(); } if(b.size() &lt; n) { b.push_back(idx); sum = 0; for (int &amp;v: a) sum += c[idx][v]; dfs(idx + 1, cur + sum); b.pop_back(); } } int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= 2*n; i ++) for (int j = 1; j &lt;= 2*n; j ++) scanf(\"%d\", &amp;c[i][j]); dfs(1, 0); printf(\"%lld\\n\", ans); return 0; } H:Second Large Rectangle题意给你一个NXM的矩阵，只有01组成，求第二大的全为1的子矩阵 思路单调栈求最大子矩阵，在过程中就也求出了第二大的子矩阵，然后第一大的宽减一，高减一，和第二大的比较输出最大的 单调栈求最大子矩阵的方法： 逐层遍历，对于每一层求出一个h[]，h表示以此层为底1的高度 比如： 这样一个矩阵,h为： 这样对于每一层就变成一个求最大矩阵的形式， 对于每一层用单调栈求出最大矩阵，注意要记得去重，像上图中的第二层，第二列，第三列，第四列求出的是同一个矩阵，不去重的话无法跟第二大的比较，去重很简单，就记录一下，左边界和上边界即可， AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e3+5; const int inf = 0x3f3f3f3f; typedef pair&lt;int, int&gt; pis; struct Pis{ int res, x, h; bool friend operator &lt; (Pis a, Pis b) { return a.res &gt; b.res; } }; char c[maxn][maxn]; int maz[maxn][maxn], h[maxn]; int pre[maxn], suf[maxn]; stack&lt;pis&gt; sta; int n, m; map&lt;pis, int&gt; mp; vector&lt;Pis&gt; ans; void getPS() { while(!sta.empty()) sta.pop(); sta.push(pis{-inf, 0}); for (int j = 1; j &lt;= m; j ++) { while(h[j] &lt;= sta.top().first) sta.pop(); pre[j] = sta.top().second+1; sta.push(pis{h[j], j}); } while(!sta.empty()) sta.pop(); sta.push(pis{-inf, m+1}); for (int j = m; j &gt;= 1; j --) { while(h[j] &lt;= sta.top().first) sta.pop(); suf[j] = sta.top().second-1; sta.push(pis{h[j], j}); } } void getH(int i) { for (int j = 1; j &lt;= m; j ++) if(maz[i][j]) h[j] += 1; else h[j] = 0; } int main() { scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) scanf(\"%s\", c[i]+1); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) maz[i][j] = c[i][j] - '0'; for (int i = 1; i &lt;= n; i ++) { getH(i); getPS(); mp.clear(); for (int i = 1; i &lt;= m; i ++) { if(!mp[pis{pre[i], h[i]}]) { mp[pis{pre[i], h[i]}] = 1; int sum = (suf[i]-pre[i]+1) * h[i]; ans.push_back(Pis{sum, pre[i], h[i]}); } } } sort(ans.begin(), ans.end()); if(ans.size() &lt;= 1) printf(\"0\\n\"); else { int tx = ans[0].res/ans[0].h, ty = ans[0].h; printf(\"%d\\n\", max(ans[1].res, max(tx*(ty-1), (tx-1)*ty))); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"牛客多校第一场","slug":"牛客多校第一场","date":"2019-08-11T12:50:58.000Z","updated":"2021-05-31T11:58:01.203Z","comments":true,"path":"/aba2/","link":"","permalink":"http://orzff.cn/aba2/","excerpt":"牛客多校第一场","text":"A. Equivalent Prefixes题意两个序列相等的条件是RMQ(u,l,r) = RMQ(u,l,r)，($1\\leq l \\leq r\\leq m$) ,RMQ(u,l,r)代表序列u，的任意区间(l,r）的最小值的序号，求一个最大的P，使得$\\lbrace a_1, a_2,…a_p \\rbrace$和$\\lbrace b_1,b_2,…b_p \\rbrace$相等 思路我们假设$last_a[i]= max\\lbrace j|j&lt;i \\&amp;\\&amp; a_j&lt;a_i\\rbrace$ ,也就是$a_i$左边序号最大的小于$a_i$的数字的位置， 我们用单调栈去求这个last，求得以后 那么我们求序列[1,r]的RMQ，就是找到last[r],last[last[r]],last[last[last[r]],的值 如果两个序列的last数组相同，那么就证明$RMQ(a,l,r)=RMQ(b,l,r)$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; int a[maxn], b[maxn]; int lasta[maxn], lastb[maxn]; stack&lt;pis&gt; sta; int main() { int n; while(~scanf(\"%d\", &amp;n)) { for (int i = 1; i &lt;= n; i ++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n; i ++) scanf(\"%d\", &amp;b[i]); while(!sta.empty()) sta.pop(); sta.push(pis{0, 0}); for (int i = 1; i &lt;= n; i ++) { while(sta.top().first &gt; a[i]) sta.pop(); lasta[i] = sta.top().second; sta.push((pis{a[i], i})); } while(!sta.empty()) sta.pop(); sta.push(pis{0, 0}); for (int i = 1; i &lt;= n; i ++) { while(sta.top().first &gt; b[i]) sta.pop(); lastb[i] = sta.top().second; sta.push((pis{b[i], i})); } int cnt = 0; for (int i = 1; i &lt;= n; i ++) { if(lasta[i] == lastb[i]) cnt ++; else break; } cout &lt;&lt; cnt &lt;&lt; endl; } return 0; } B.Integration题意已知$\\int_0^{\\infty}\\frac{1}{1+x^2}dx=\\frac{\\pi}{2}$ 求：$\\frac{1}{\\pi}\\int_0^{\\infty}\\frac{1}{\\prod\\limits_{i=1}^{n}(a_i^2+x^2)}dx$ 思路我们先算$\\frac{1}{\\prod\\limits_{i=1}^{n}(a_i^2+x^2)}$$=\\frac{1}{a_1^2+x^2} \\frac{1}{a_2^2+x^2}\\frac{1}{\\prod\\limits_{i=3}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{a_1^2+x^2}-\\frac{1}{a_2^2+x^2})\\frac{1}{\\prod\\limits_{i=3}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{a_1^2+x^2}-\\frac{1}{a_2^2+x^2})\\frac{1}{a_3^2+x^2}\\frac{1}{\\prod\\limits_{i=4}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{a_1^2+x^2}\\frac{1}{a_3^2+x^2}-\\frac{1}{a_2^2+x^2}\\frac{1}{a_3^2+x^2})\\frac{1}{\\prod\\limits_{i=4}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{(a_1^2-a_3^2)}(\\frac{1}{a_3^2+x^2}-\\frac{1}{a_1^2+x^2})-\\frac{1}{(a_3^2-a_2^2)}(\\frac{1}{a_2^2+x^2}-\\frac{1}{a_3^2+x^2}))\\frac{1}{\\prod\\limits_{i=4}^{n}a_i^2+x^2}\\\\=(\\frac{1}{a_2^2-a_1^2}\\frac{1}{a_3^2-a_1^2})\\frac{1}{a_1^2+x^2}+(\\frac{1}{a_1^2-a_2^2}\\frac{1}{a_3^2-a_2^2})\\frac{1}{a_2^2+x^2}+(\\frac{1}{a_1^2-a_3^2}\\frac{1}{a_2^2-a_3^2})\\frac{1}{a_3^2+x^2}\\\\=…\\\\=\\sum\\limits_{i=1}^{n}\\frac{1}{\\prod\\limits_{j=1,j!=i}^{n}(a_j^2-a_i^2)}\\frac{1}{a_i^2+x^2}$我们设$c_i=\\prod\\limits_{j=1,j!=i}^{n}(a_j^2-a_i^2)$$原式=\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\frac{1}{a_i^2+x^2}$那么$\\frac{1}{\\pi}\\int_0^{\\infty}\\frac{1}{\\prod\\limits_{i=1}^{n}(a_i^2+x^2)}dx\\\\=\\frac{1}{\\pi}\\int_0^{\\infty}\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\frac{1}{a_i^2+x^2}\\\\=\\frac{1}{\\pi}\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\int_0^{\\infty}\\frac{1}{a_i^2+x^2}\\\\=\\frac{1}{\\pi}\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\frac{\\pi}{2a_i}\\\\=\\sum\\limits_{i=1}^{n}\\frac{1}{2c_ia_i}$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; ll a[maxn], b[maxn]; int n; ll ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) { if(!b) { x = 1; y = 0; return a; } ll d = ex_gcd(b, a % b, x, y); ll t = x; x = y; y = t - a / b * y; return d; } ll getInv(ll a, ll p) { ll x, y; ex_gcd(a, p, x, y); x = ((x % p) + p) % p; return x; } ll solve(ll x, int idx) { ll res = x; for (int i = 1; i &lt;= n; i ++) { if(i == idx) continue; res *= (b[i] - b[idx] + mod) % mod; res %= mod; } return getInv(res, mod); } int main() { while(~scanf(\"%d\", &amp;n)) { for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;a[i]); b[i] = a[i] * a[i] % mod; } ll ans = 0; for (int i = 1; i &lt;= n; i ++) ans = (ans + solve(a[i], i)) % mod; printf(\"%lld\\n\", ans * getInv(2, mod) % mod); } return 0; } C:Euclidean Distance题意给你一些点$(\\frac{a_1}{m},\\frac{a_2}{m},…,\\frac{a_n}{m})$,让你找一些$p_i$,使得$\\sum\\limits_{i=1}^{n}(p_i-a_i)^2$最小,$p_i$满足$\\sum\\limits_{i=1}^{n}p_i=1,p_i&gt;=0$ 思路听说题解是用拉格朗日乘子法，但我也不会，我看到有别人用的是贪心因为所有的$a_i$都是除以m的，所以我们把$a_i$和$p_i$都乘以m，那么我们就变成了用m步使得面积最小（负数的面积不能变小只能变大） 那么贪心的做法就是把大的尽量的变小，因为是排过序的，所以前面的要比后面的大。每次都试着把前i-1块变得跟第i块平齐，如果不能就把前(i-1)块全部减小$\\frac{k}{i-1}$,保持前面的平齐 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 5e5 + 5; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; ll a[maxn]; bool cmp(ll a, ll b) { return a &gt; b; } ll gcd(ll a, ll b) { return !b ? a : gcd(b, a % b); } int main() { ll n, m; while(~scanf(\"%lld %lld\", &amp;n, &amp;m)) { for (int i = 1; i &lt;= n; i ++) scanf(\"%lld\", &amp;a[i]); sort(a + 1, a + n + 1, cmp); ll k = m; for (int i = 2; i &lt;= n; i ++) { if(k &gt; (a[i-1] - a[i]) * (i-1)) { k -= 1ll * (a[i-1] - a[i]) * (i-1); }else { for (int j = 1; j &lt;= i-1; j ++) a[j] = 1ll* (i-1) * a[i-1] - k; for (int j = i; j &lt;= n; j ++) a[j] = 1ll * a[j] * (i-1); m = 1ll * m * (i-1); k = 0; break; } } if(k) { for (int i = 1; i &lt;= n; i ++) a[i] = 1ll * (a[n] * n) - k; m = 1ll * m * n; } ll ans = 0; for (int i = 1; i &lt;= n; i ++) ans = (ans + 1ll * a[i] * a[i]); m = 1ll * m * m; ll k1 = gcd(ans, m); ans /= k1; m /= k1; if(m == 1) printf(\"%lld\\n\", ans); else printf(\"%lld/%lld\\n\", ans, m); } return 0; } E:ABBA题意给你n个AB和m个BA，问你能构造出多少个长度为(n+m)*2并且能组成n个AB和B个BA的串 思路如果我们把A看做-1，B看成1，那么构成串的前缀和应该在[-n,m]，如果不在就是不合法的串然后我们在用dp[i][j]来表示构成串的前i+j位中有i个A,j个B，那么我们考虑dp[i][j]—&gt;(dp[i+1][j],dp[i][j+1])转移是只需要判断(dp[i+1][j],dp[i][j+1])是否合法即可 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 2e3 + 5; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; ll dp[maxn][maxn]; int main() { int n, m; while(scanf(\"%d %d\", &amp;n, &amp;m) != EOF) { for (int i = 0; i &lt;= n + m; i ++) for (int j = 0; j &lt;= n + m; j ++) dp[i][j] = 0; dp[0][0] = 1; for (int i = 0; i &lt;= n+m; i ++) { for (int j = max(0, i-n); j &lt;= min(n+m, i+m); j ++) { if(i) dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod; if(j) dp[i][j] = (dp[i][j] + dp[i][j-1]) % mod; } } printf(\"%lld\\n\", dp[n+m][n+m]); } return 0; } H:XOR题意给你一堆数，让你找他们子集xor和位0的的子集的大小之和 思路明显的线性集问题,首先我们要知道一堆数字组成线性集， 可以范围线性集外的数字和线性集内的数字，线性集内的数字可以xor出线性集外的所有子集 因为是问子集大小的和，所以我们可以转化成求每个数字的贡献 分为两种：我们设数字总数为$n$,线性集大小为$r$ 1.线性集外数字的贡献： 因为线性集内的数字能把线性集外的所有子集xor出来。 我们枚举线性集外的每一个数字$x$，那么如果线性集内的数字能把$x$xor出来那么，$x$对应的 线性集外的子集大小就为$2^{n-r-1}$,即这个数字的贡献就为$2^{n-r-1}$ 2.线性集内的数字的贡献： 对剩下的n-1个数字做一次线性集，看是否能把$x$xor出来，能xor出来贡献就为$2^{n-r-1}$，不能就为0 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; ll a[maxn]; bool vis[maxn]; vector&lt;int&gt; vec; struct LB{ ll b[65], cnt = 0; bool flag; void init() { memset(b, 0, sizeof(b)); flag = false; cnt = 0; } void ins(ll x) { for (int i = 62; i &gt;= 0; i --) if(x &gt;&gt; i) { if(!b[i]) { b[i] = x; cnt ++; return ; } x ^= b[i]; } flag = true; } bool Fin(ll x) { if(x == 0 &amp;&amp; flag) return true; for (int i = 62; i &gt;= 0; i --) { if(x &gt;&gt; i) { x ^= b[i]; } } return x == 0; } }A, B, C; ll Ksm(ll a, ll b) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } int main() { int n; while(~scanf(\"%d\", &amp;n)) { A.init(); B.init(); vec.clear(); for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;a[i]); if(!A.Fin(a[i])) { A.ins(a[i]); vec.push_back(i); }else B.ins(a[i]); } ll r = A.cnt; if(n == r) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } ll base = Ksm(2, n-r-1); ll sum = base * (n-r) % mod; for (auto &amp;it: vec) { ll x = a[it]; for (int i = 0; i &lt;= 62; i ++) C.b[i] = B.b[i]; C.flag = B.flag; for (auto &amp;it2: vec) if(it != it2) C.ins(a[it2]); if(C.Fin(x)) sum = (sum + base) % mod; } printf(\"%lld\\n\", sum); } return 0; } I:Points Division题意给你n个点，把点划分成A,B两部分，规定$i\\in A$ and $j\\in B$ and $x_j \\leq x_i$ and $y_i\\leq y_j$ 求最后$\\sum\\limits_{i\\in A}a_i+\\sum\\limits_{j\\in B}b_j$ 的最大值 思路我们发现$A$位于左上角，$B$位于右上角，$AB$边界时一条不下降的折线,所以我们可以沿着这条折线进行$dp$， 我们规定折线上的点全是$B$上的点。 首先我们先把纵坐标离散化，然后用$dp[i]$来表示当高度为i时最大值为多少 然后我们来求每一个点对结果的贡献， 对于一个点$i$,有两种情况: ​ 一：这个点不在折线上，那么大于$y_i$并且在折线上面的点$j$，$i$相当于位于$B$，那么$i$对于$j$的贡献就是$b_i$,对于那些小于$y_i$并且在折线上面的点$k$，$i$相当于位于$A$，那么$i$对$k$的贡献就是$a_i$, ​ 二：这个点在折线上，$dp[i]$就由从$1到i-1$的点的最大值+$b_i$ 也就是$dp[i] = \\max\\limits_{1\\leq j &lt; i} dp[j] + b_i$ 大体思路就是这样，因为我们要对区间操作，所以要用一个线段树来维护一下 注意因为我们默认折线上的点全是属于$B$的点，这就导致不会有$A=P$ and $B=\\emptyset$的情况，但是我们在点中加入一个$(0,0)$的点，因为$1\\leq x_i, y_i\\leq 10^9$那么所有的点都位于$(0,0)$上面，对$(0,0)$的贡献就是$B=\\emptyset$的值 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; struct Node{ ll x, y, a, b; bool friend operator &lt; (Node a, Node b) { if(a.x == b.x) return a.y &gt; b.y; return a.x &lt; b.x; } }node[maxn]; ll ty[maxn]; struct Seg{ ll dp[maxn&lt;&lt;2], lazy[maxn&lt;&lt;2]; void Build(int rt, int l, int r) { if (l == r) { dp[rt] = 0; lazy[rt] = 0; return ; } lazy[rt] = 0; dp[rt] = 0; int m = (l + r) &gt;&gt; 1; Build(rt&lt;&lt;1, l, m); Build(rt&lt;&lt;1|1, m+1, r); } void down(int rt) { lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; dp[rt&lt;&lt;1] += lazy[rt]; dp[rt&lt;&lt;1|1] += lazy[rt]; lazy[rt] = 0; } void Updata(int rt, int l, int r, int L, int R, ll v) { //区间更新 if(l &gt;= L &amp;&amp; r &lt;= R) { dp[rt] += v; lazy[rt] += v; return ; } if(lazy[rt]) down(rt); int m = (l + r) &gt;&gt; 1; if(L &lt;= m) Updata(rt&lt;&lt;1, l, m, L, R, v); if(R &gt; m) Updata(rt&lt;&lt;1|1, m+1, r, L, R, v); dp[rt] = max(dp[rt&lt;&lt;1], dp[rt&lt;&lt;1|1]); } void Updata(int rt, int l, int r, int w, ll v) { //单点更新 if(l == r) { dp[rt] = max(dp[rt], v); return ; } if(lazy[rt]) down(rt); int m = (l + r) &gt;&gt; 1; if(w &lt;= m) Updata(rt&lt;&lt;1, l, m, w, v); else Updata(rt&lt;&lt;1|1, m+1, r, w, v); dp[rt] = max(dp[rt&lt;&lt;1], dp[rt&lt;&lt;1|1]); } ll Query(int rt, int l, int r, int L, int R) { if(l &gt;= L &amp;&amp; r &lt;= R) return dp[rt]; ll Max = 0; int m = (l + r) &gt;&gt; 1; if(L &lt;= m) Max = max(Max, Query(rt&lt;&lt;1, l, m, L, R)); if(R &gt; m) Max = max(Max, Query(rt&lt;&lt;1|1, m+1, r, L, R)); return Max; } }seg; int main() { int n; while(~scanf(\"%d\", &amp;n)) { int cnt = 0; ty[cnt++] = 0; node[0] = Node{0, 0, 0, 0}; for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld %lld %lld %lld\", &amp;node[i].x, &amp;node[i].y, &amp;node[i].a, &amp;node[i].b); ty[cnt++] = node[i].y; } sort(ty, ty + cnt); cnt = unique(ty, ty+cnt) - ty; for (int i = 0; i &lt;= n; i ++) node[i].y = lower_bound(ty, ty + cnt, node[i].y) - ty + 1; sort(node, node + 1 + n); seg.Build(1, 1, cnt); for (int i = 0; i &lt;= n; i ++) { if(node[i].y &lt; cnt) seg.Updata(1, 1, cnt, node[i].y+1, cnt, node[i].b); //[node.y+1~cnt]+a seg.Updata(1, 1, cnt, node[i].y, seg.Query(1, 1, cnt, 1, node[i].y)+node[i].b);//dp[i] = max if(node[i].y &gt; 1) seg.Updata(1, 1, cnt, 1, node[i].y-1, node[i].a);//[1~node.y] + b } printf(\"%lld\\n\", seg.dp[1]); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"My First Blog","slug":"2019-08-11-My-First-Blog","date":"2019-08-11T06:57:09.000Z","updated":"2021-05-31T11:58:00.939Z","comments":true,"path":"/81cc/","link":"","permalink":"http://orzff.cn/81cc/","excerpt":"My First Blog","text":"这是我的第一篇博客，主要写一些Hexo的配置 Hexo + Github 搭建博客：跟着这篇博客走即可 Hexo 主题配置Hexo目录下的_config.yml称为站点配置文件 Hexo/themes/next/目录下的_config.yml称为主题配置文件 next主题下载next主题 git clone https://github.com/theme-next/hexo-theme-next themes/next 在站点配置文件 _config.yml # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 在主题配置文件_config.yml中可以选择四种scheme，我选择的是Gemini # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 基本信息配置配置站点配置文件_config.yml title: 标题 subtitle: 副标题 description: 描述 author: 作者 language: 语言（简体中文是zh-Hans） timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 菜单信息配置：配置主题配置文件_config.yml menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat # Enable/Disable menu icons. menu_icons: enable: true 设置标签，分类页面在Git-Bash中输入： hexo new page \"tags\" hexo new page \"categories\" hexo new page \"about\" 这时在Hexo/source/下出现一个tags/index.md和categories/index.md 这时你修改index.md的属性，新加type属性 tags的index --- title: 标签 data: 2019-08-10 00:11:16 type: \"tags\" comments: false --- categories的index --- title: 分类 date: 2019-08-10 00:08:44 type: \"categories\" comments: false --- about的index --- title: 这是我的自我介绍 layout: about comments: false --- comments: false是关闭评论功能 搜索功能在Hexo的根目录下执行 npm install hexo-generator-searchdb --save 站点配置文件_config.yml search: # 本地搜索插件 path: search.xml field: post format: html limit: 10000 在主题配置文件_config.yml中 local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 头像设置把你要作为头像的图片放到：Hexo/themes/next/source/images 然后更改主题配置文件_config.yml中的 Sidebar Avaatar avatar: /images/header.jpg 网站缩略图图标把你要作为缩略图的图片放到：Hexo/themes/next/source/images 然后打开主题配置文件_config.yml,找到 favicon，修改成这样 favicon: small: /images/header.jpg medium: /images/header.jpg apple_touch_icon: /images/header.jpg safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 修改链接文本样式打开Hexo/themes/next/source/css/_common/components/post.styl，添加 .post-body p a { color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; } } 添加评论系统注册登录来必力, 安装City，获得安装代码中的data-uid=\"xxx\" 配置主题配置文件_config.yml,添加LiveRe Uid: livere_uid: #你的LiveRe UID 添加访问计数next已经集成了busuanzi计数，编辑Hexo/themes/next/layout/_third-party/analytics/busuanzi-counter.swig 将 &lt;script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 改为 &lt;script async src=\"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 主题配置文件_config.yml # Show PV/UV of the website/page with busuanzi. # Get more information on http://ibruce.info/2015/04/04/busuanzi/ busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true total_visitors: true total_visitors_icon: user total_view: true total_views_icon: eye post_views: false post_view_icon: eye site_uv_header: &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; 访客数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=\"fa fa-file-o\"&gt;&lt;/i&gt; 阅读数 page_pv_footer: 次 文章版权信息编辑主题配置文件_config.yml，修改 post_copyright: enable: true 打赏编辑主题配置文件_config.yml,修改 # Reward reward_comment: 求打赏文本 wechatpay: /images/wechatpay.png # 微信收款二维码 图片路径 alipay: /images/alipay.png # 支付宝收款二维码 图片路径 #bitcoin: /images/bitcoin.png # 比特币 添加更新时间编辑主题配置文件_config.yml,修改 post_meta: item_text: true created_at: true # 创建时间 updated_at: true # 更新时间 # Only show 'updated' if different from 'created'. updated_diff: false # 只使用更新时间 # If true, post's time format will be hexo config's date_format + ' ' + time_format. date_time_merge: false categories: true 修改文章底部的标签编辑Hexo/themes/next/layout/_macro/post.swig 找到rel=\"tag\"&gt;# 将#改为&lt;i class=\"fa fa-tag\"&gt;&lt;/i&gt; 文章底部添加”本文结束”编辑Hexo/themes/next/laayout/_macro/post.swig，在文章结束的地方加上 {% if not is_index %} &lt;div style=\"text-align:center;color: #ccc;font-size:14px;\"&gt; ---------Thanks for your attention--------- &lt;/div&gt; {% endif %} 在页脚添加运行时间编辑themes/next/layout/_partials/footer.swig 在所示位置加上代码： {### 运行时间 ####} &lt;span id=\"sitetime\"&gt;&lt;/span&gt; &lt;script language=javascript&gt; function siteTime(){ window.setTimeout(\"siteTime()\", 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) year - 作为date对象的年份，为4位年份值 month - 0-11之间的整数，做为date对象的月份 day - 1-31之间的整数，做为date对象的天数 hours - 0(午夜24点)-23之间的整数，做为date对象的小时数 minutes - 0-59之间的整数，做为date对象的分钟数 seconds - 0-59之间的整数，做为date对象的秒数 microseconds - 0-999之间的整数，做为date对象的毫秒数 */ var t1 = Date.UTC(2018,02,13,15,00,00); //北京时间2018-2-13 00:00:00 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(\"sitetime\").innerHTML=\" 已运行\"+diffYears+\" 年 \"+diffDays+\" 天 \"+diffHours+\" 小时 \"+diffMinutes+\" 分钟 \"+diffSeconds+\" 秒\"; }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/ siteTime(); &lt;/script&gt; Latex公式更换Hexo的Markdown渲染引擎 npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save 然后打开node_modules/kramed/lib/rules/inline.js 替换11行的escape变量 // escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/ 改变20行的em变量 // em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/ next集成了Mathjax，编辑主题配置文件_config.yml # MathJax Support mathjax: enable: true per_page: true engine: mathjax cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML # Han Support docs: https://hanzi.pro/ han: false 在写文章时要在文章的配置中加上mathjax: true 短链接在根目录执行 npm install hexo-abbrlink --save 配置站点配置文件_config.yml,修改 # abbrlink config abbrlink: alg: crc16 #support crc16(default) and crc32 rep: hex #support dec(default) and hex # 更改 permalink 值 permalink: /:abbrlink/ 文章封面图片在根目录执行 npm install --save hexo-less 在写文章时手动设置文章摘要&lt;!-- less --&gt;为分界线 social修改主题配置文件_config.yml social: #GitHub: https://github.com/yourname || github #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #E-Mail: mailto:yourname@gmail.com || envelope #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype social_icons: enable: true GitHub: github Twitter: twitter 微博: weibo 友链修改主题配置文件_config.yml # Blog rolls links_icon: link links_title: Friend Links links_layout: block #links_layout: inline links: github: http://github.com/ 字数统计和阅读时长在根目录执行 npm install hexo-symbols-count-time --save 修改站点配置文件_config.yml symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 修改主题配置文件_config.yml # Post wordcount display settings # Dependencies: https://github.com/theme-next/hexo-symbols-count-time symbols_count_time: separated_meta: true #文章中的显示是否显示文字（本文字数|阅读时长） item_text_post: true #网页底部的显示是否显示文字（站点总字数|站点阅读时长） item_text_total: false # Average Word Length (chars count in word) awl: 4 # Words Per Minute wpm: 275 隐藏网页底部信息修改主题配置文件_config.yml footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: user counter: true # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target=\"_blank\" href=\"https://pages.github.com\"&gt;GitHub Pages&lt;/a&gt; # --------------------------------------------------------------- # SEO Settings # --------------------------------------------------------------- # Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog. # See: https://support.google.com/webmasters/answer/139066 # Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com ) canonical: true # Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization. seo: false # If true, will add site-subtitle to index page, added in main hexo config. # subtitle: Subtitle index_with_subtitle: false 设置RSS在根目录执行 npm install hexo-generator-feed --save 修改站点配置文件_config.yml,在Extensions下添加 # RSS订阅 feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' 修改主题配置文件 _config.yml修改rss为 rss: /atom.xml 修改字体在GItHub上下载后，解压后将所有Web文件夹下的所有内容放入Hexo/theme/next/source/fonts 然后修改Hexo/themes/next/source/css/_custom/custom.styl //字体 @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Light.eot'); src: url('/fonts/ComicNeue-Light.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Light.woff2') format('woff2'), url('/fonts/ComicNeue-Light.woff') format('woff'), url('/fonts/ComicNeue-Light.ttf') format('truetype'); font-weight: 300; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Light-Oblique.eot'); src: url('/fonts/ComicNeue-Light-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Light-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Light-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Light-Oblique.ttf') format('truetype'); font-weight: 300; font-style: oblique; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Regular.eot'); src: url('/fonts/ComicNeue-Regular.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Regular.woff2') format('woff2'), url('/fonts/ComicNeue-Regular.woff') format('woff'), url('/fonts/ComicNeue-Regular.ttf') format('truetype'); font-weight: 400; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Regular-Oblique.eot'); src: url('/fonts/ComicNeue-Regular-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Regular-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Regular-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Regular-Oblique.ttf') format('truetype'); font-weight: 400; font-style: oblique; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Bold.eot'); src: url('/fonts/ComicNeue-Bold.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Bold.woff2') format('woff2'), url('/fonts/ComicNeue-Bold.woff') format('woff'), url('/fonts/ComicNeue-Bold.ttf') format('truetype'); font-weight: 700; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Bold-Oblique.eot'); src: url('/fonts/ComicNeue-Bold-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Bold-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Bold-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Bold-Oblique.ttf') format('truetype'); font-weight: 700; font-style: oblique; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Light.eot'); src: url('/fonts/ComicNeue-Angular-Light.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Light.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Light.woff') format('woff'), url('/fonts/ComicNeue-Angular-Light.ttf') format('truetype'); font-weight: 300; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Light-Oblique.eot'); src: url('/fonts/ComicNeue-Angular-Light-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Light-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Light-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Angular-Light-Oblique.ttf') format('truetype'); font-weight: 300; font-style: oblique; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Regular.eot'); src: url('/fonts/ComicNeue-Angular-Regular.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Regular.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Regular.woff') format('woff'), url('/fonts/ComicNeue-Angular-Regular.ttf') format('truetype'); font-weight: 400; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Regular-Oblique.eot'); src: url('/fonts/ComicNeue-Angular-Regular-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Regular-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Regular-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Angular-Regular-Oblique.ttf') format('truetype'); font-weight: 400; font-style: oblique; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Bold.eot'); src: url('/fonts/ComicNeue-Angular-Bold.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Bold.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Bold.woff') format('woff'), url('/fonts/ComicNeue-Angular-Bold.ttf') format('truetype'); font-weight: 700; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Bold-Oblique.eot'); src: url('/fonts/ComicNeue-Angular-Bold-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Bold-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Bold-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Angular-Bold-Oblique.ttf') format('truetype'); font-weight: 700; font-style: oblique; } 修改主题配置文件 _config.yml修改font为 font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: 'Comic Neue' size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: 'Comic Neue' size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: 'Comic Neue' # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: 'Comic Neue' size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: 'Comic Neue' size: 刚开始的字体是默认14px，在代码部分会很小，所以可以在themes/next/source/css/_variables/base.styl 修改 font size和code font 为18px就很好 设置新建文件配置进入Hexo/scaffolds修改post.md --- title: {{ title }} date: {{ date }} mathjax: true categories: tags: --- 新建带日期的博文修改站点配置文件-config.yml # Writing new_post_name: :year-:month-:day-:title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: true # 同时生成一个文件夹 relative_link: false future: true highlight: # Hexo自带代码高亮插件 enable: true line_number: true auto_detect: false tab_replace: 背景图片把背景图片存放到Hexo/themes/next/source/images 再在Hexo/themes/next/source/css/_custom/custom/styl修改一下 body { background:url(/images/music.png);} 参考博客： https://www.jianshu.com/p/3a05351a37dc https://www.cnblogs.com/liziczh/p/9318656.html https://xian6ge.netlify.com/posts/82ce1911/ https://www.jianshu.com/p/805bd0b65d98https://www.jianshu.com/p/805bd0b65d98 https://www.jianshu.com/p/3a01cc514ce7?utm_source=oschina-app https://leflacon.github.io/7167e0bc/","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://orzff.cn/tags/Hexo/"}]}]}