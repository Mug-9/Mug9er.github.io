{"meta":{"title":"Mug-9's blog","subtitle":"Hello World","description":null,"author":"Mug-9","url":"http://orzff.cn","root":"/"},"pages":[{"title":"404","date":"2019-08-09T13:11:29.000Z","updated":"2021-05-31T11:58:00.938Z","comments":true,"path":"404/index.html","permalink":"http://orzff.cn/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-08-09T16:08:44.000Z","updated":"2021-05-31T11:58:01.224Z","comments":false,"path":"about/index.html","permalink":"http://orzff.cn/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2021-06-02T12:27:17.000Z","updated":"2021-06-15T13:42:58.534Z","comments":true,"path":"archives/index.html","permalink":"http://orzff.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-09T16:08:44.000Z","updated":"2021-05-31T11:58:01.242Z","comments":false,"path":"categories/index.html","permalink":"http://orzff.cn/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-05-30T09:42:17.000Z","updated":"2021-05-31T11:58:01.242Z","comments":true,"path":"contact/index.html","permalink":"http://orzff.cn/contact/index.html","excerpt":"","text":""},{"title":"画廊","date":"2021-05-30T15:07:43.000Z","updated":"2021-05-31T11:58:01.243Z","comments":true,"path":"galleries/index.html","permalink":"http://orzff.cn/galleries/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-05-30T09:46:53.000Z","updated":"2021-05-31T13:47:32.212Z","comments":false,"path":"friends/index.html","permalink":"http://orzff.cn/friends/index.html","excerpt":"","text":""},{"title":"LeetCode","date":"2019-08-09T16:08:44.000Z","updated":"2021-06-15T13:42:58.534Z","comments":true,"path":"leetcode/index.html","permalink":"http://orzff.cn/leetcode/index.html","excerpt":"","text":""},{"title":"tag","date":"2019-08-09T16:11:16.000Z","updated":"2021-05-31T11:58:01.244Z","comments":false,"path":"tags/index.html","permalink":"http://orzff.cn/tags/index.html","excerpt":"","text":""},{"title":"瞎BB","date":"2021-05-31T03:04:09.000Z","updated":"2021-05-31T12:10:29.080Z","comments":false,"path":"artitalk/index.html","permalink":"http://orzff.cn/artitalk/index.html","excerpt":"","text":"new Artitalk({ appId: 'pVqE7D3TEJU4uGHFgVDQYHbj-MdYXbMMI', // Your LeanCloud appId appKey: 'uf5JWphxgdEGy1JaJTPbvdu8' // Your LeanCloud appKey })"},{"title":"封面图","date":"2021-05-30T15:18:45.000Z","updated":"2021-05-31T11:58:01.243Z","comments":true,"path":"galleries/封面图/index.html","permalink":"http://orzff.cn/galleries/%E5%B0%81%E9%9D%A2%E5%9B%BE/index.html","excerpt":"","text":""},{"title":"个人训练","date":"2019-11-10T14:56:13.000Z","updated":"2020-12-04T13:38:22.365Z","comments":false,"path":"practice/index.html","permalink":"http://orzff.cn/practice/index.html","excerpt":"","text":"格式：$\\bullet$ ✓ : 赛时通过 $\\bullet$ ✗ ：赛时未通过 $\\bullet$ ★ : 赛后通过 $\\bullet$ ✧ : 未提交 比赛记录： a{text-decoration:none} a:hover{text-decoration:none} ​ 比赛通过日期 ABC DEF GHI JKL MN Educational Codeforces Round 67 (Div. 2)2/609/12/2019 ✓✓★ ✧✧✧ Codeforces Round #574 (Div. 2)5/607/12/2019 ✓✓✓ ✓✧✧ Codeforces Round #604 (Div. 2)5/606/12/2019 ✓✓✓ ✓✓✧ Codeforces Round #573 (Div. 2)3/605/12/2019 ✓✓✓ ★✧✧ Educational Codeforces Round 68 (Div. 2)3/604/12/2019 ✓✓✓ ★✧✧ Codeforces Round #574 (Div. 2)3/603/12/2019 ✓✓✓ ★✧✧ Codeforces Round #576 (Div. 2)3/602/12/2019 ✓✓✓ ★✧✧ Codeforces Round #603 (Div. 2)4/628/11/2019 ✓✓✓ ✓ ✧✧ Codeforces Round #577 (Div. 2)3/628/11/2019 ✓✓✓ ✧ ✧✧ Educational Codeforces Round 77 (Div. 2)3/627/11/2019 ✓✓✓ ★ ✧✧ Educational Codeforces Round 70 (Div.2)2/626/11/2019 ✓✓✧ ★ ✧✧ Codeforces Round #578 (Div. 2)3/625/11/2019 ✓✓✓ ★ ✧✧ Codeforces Round #602 (Div. 2)3/824/11/2019 ✓✓✧ ✓✗✧ ✧✧ 2013-2014 ACM-ICPC, Asia Aizu Regional Contest2/1023/11/2019 ✓✓✧ ✧✧✧ ✧✧✧ ✧ Codeforces Round #580 (Div. 2)3/622/11/2019 ✓✓✓ ★✧✧ Codeforces Round #581 (Div. 2)4/521/11/2019 ✓✓✓ ✓✧ Educational Codeforces Round 72 (Div. 2)3/620/11/2019 ✓✓✓ ✧✧✧ Codeforces Round 599(Div 2)4/610/11/2019 ✓✓✓ ✓✧✧ Educational Codeforces Round 75(Div 2)2/711/11/2019 ✓✓★ ★✧✧ ✧ Codeforces Round #595(Div 3)3/612/11/2019 ✓✓✓ ★✧✧ Educational Codeforces Round 73 (Div 2)3/713/11/2019 ✓✓✓ ★✧✧ ✧ Educational Codeforces Round 76 (Div. 2)3/714/11/2019 ✓✓✓ ★✧✧ ✧ Codeforces Round #586 (Div. 1 + Div. 2)3/715/11/2019 ✓✓✓ ✗✧✧ ✧ Codeforces Round #600 (Div. 2)3/716/11/2019 ✓★✓ ✧✧✧ ✧ 2019-2020 ICPC, NERC, Southern and Volga Russian Regional Contest (Online Mirror, ICPC Rules, Teams Preferred)6/1417/11/2019 ✓✓✧ ✧✧✓ ✧✓✧ ✓✧✓ ✧✧ Codeforces Round #584 - Dasha Code Championship - Elimination Round (rated, open for everyone, Div. 1 + Div. 2)3/718/11/2019 ✓✓✓ ★✧✧ ✧✧ Codeforces Round #601 (Div. 2)1/619/11/2019 ✓★✧ ✧✧✧"}],"posts":[{"title":"三维重建基础","slug":"三维重建基础","date":"2021-09-16T03:10:00.000Z","updated":"2021-09-16T03:12:13.341Z","comments":true,"path":"/2048abda/","link":"","permalink":"http://orzff.cn/2048abda/","excerpt":"三维重建基础","text":"","categories":[{"name":"三维重建","slug":"三维重建","permalink":"http://orzff.cn/categories/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"}],"tags":[{"name":"机器视觉","slug":"机器视觉","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"}]},{"title":"数学基础-概率","slug":"数学基础-概率","date":"2021-07-28T14:00:03.000Z","updated":"2021-07-28T16:47:28.106Z","comments":true,"path":"/b4b45aa/","link":"","permalink":"http://orzff.cn/b4b45aa/","excerpt":"智能计算数学基础-概率","text":"描述随机方法 $\\mathrm{E}(x)$ ,期望，均值， $\\mathrm{var}(x)$ 方差 $\\mathrm{E}(x-\\bar{x})^2$ $\\rho(x,y) $ 相关系数 $\\mathrm{PDF}$：概率密度函数$\\mathrm{p}(x)$ 高斯密度：$p(x)=\\frac{1}{(2\\pi \\sigma^2 ) ^{\\frac{1}{2}}} \\mathrm{exp}\\{-\\frac{1}{2} \\frac{(x-m)^2}{\\sigma^2}\\}$ 大数定理$\\lim\\limits_{n\\to \\infty}\\mathrm{P}(|\\frac{S_n}{n}-p|&lt; \\varepsilon ) = 1$ 伯努利实验，重复$n$次，每次成功概率为$p$,总成功次数为$S_n$ ，$\\forall \\varepsilon &gt; 0$ 重要的$\\mathrm{PDF}$$\\mathrm{Reyleigh}$分布$x_1 \\sim N(0,\\sigma^2), x_2\\sim N(0, \\sigma^2)$，其中$x_1,x_2$是独立的 定义一个概率密度函数$x=\\sqrt{x_1^2+x_2^2}$ 这个$x$的$\\mathrm{PDF}$： $p(x)=\\begin{equation} \\left\\{ \\begin{array}{lr} \\frac{x}{\\sigma^2}exp(-\\frac{1}{2\\sigma^2}x) &amp; x &gt; 0 \\\\ 0 &amp; x &lt; 0 \\end{array} \\right\\} \\end{equation}$ $\\mathrm{Rician}$分布$x_1\\sim N(\\mu_1, \\sigma^2), x_2 \\sim N(\\mu_2, \\sigma^2)$, 其中$x_1,x_2$独立 定义一个概率密度函数$x=\\sqrt{x_1^2+x_2^2}$ $\\mathrm{PSF}$为： $p(x)=\\begin{equation} \\left\\{ \\begin{array}{lr} \\frac{x}{\\sigma^2}exp[-\\frac{1}{2\\sigma^2}(x^2+\\alpha^2)]I_0(\\frac{\\alpha x}{\\sigma^2}) &amp; x &gt; 0 \\\\ 0 &amp; x &lt; 0 \\end{array} \\right\\} \\end{equation}$ $\\alpha^2=\\mu_1^2+\\mu_2^2, I_0(u)= \\frac{1}{\\pi}\\int_{0}^{\\pi}\\mathrm{exp}(u\\mathrm{cost}\\theta)d\\theta=\\int_{0}^{2\\pi}\\mathrm{exp}(u\\mathrm{cos}\\theta)\\frac{d\\theta}{2\\pi}$ $\\alpha^2$等于0是就是$\\mathrm{Reyleigh}$的$\\mathrm{PDF}$ $I_0(u)$是贝塞尔函数，是数学上一类特殊函数的总称，通常单说的贝塞尔函数值第一类贝塞尔函数 第一类$r$阶贝塞尔函数，简称$J$函数，记作$J_r$: $J_r(u)=\\Sigma_{k=0}^{\\infty}\\frac{(-1)^k}{k!\\Gamma(k+r+1)}(\\frac{u}{2})^{2k+r}$ $J_r(u)=\\frac{(\\frac{1}{2}u)^r}{\\sqrt{\\pi}\\Gamma(r+\\frac{1}{2})}\\int_0^{\\pi}\\mathrm{cos}(u\\mathrm{cos}\\theta)\\mathrm{sin}^{2r}\\theta d\\theta$ 第一类修正贝塞尔函数 $I_r(u)=i^{-r}J_r(iu)=\\Sigma_{k=0}^{\\infty}\\frac{(\\frac{1}{2}u)^r}{k!\\Gamma(k+r+1)}$ $I_r(u)=\\frac{(\\frac{1}{2}u)^r}{\\sqrt{\\pi}\\Gamma(r+\\frac{1}{2})}\\int_0^{\\pi}\\mathrm{exp}(u\\mathrm{cos}\\theta)\\mathrm{sin}^{2r}\\theta d\\theta$ 伽马函数，也叫第二类欧拉积分，是阶乘函数在实数与复数上扩展的一类函数 定义 $\\Gamma(u)=\\int_0^{\\infty}t^{u-1}\\mathrm{exp}(-t)dt$ 性质： $\\Gamma(u)=(u-1)\\Gamma(u-1)(\\mathrm{for \\ any \\ u})$ $\\Gamma(\\frac{1}{2})=\\sqrt{\\pi}$ $\\Gamma(1)=1$ $\\Gamma(n)=(n-1)! $ $n$是一个整数 贝塔函数，也叫第一类欧拉积分，又称为$\\mathrm{B}$函数 定义：对任意实数$u,v&gt;0, \\mathrm{B}(u,v)=\\int_0^1x^{u-1}(1-x)^{v-1}dx$ 性质： $\\mathrm{B}(u,v)=\\mathrm{B}(v,u)$ $\\mathrm{B}(u,v)= \\frac{v-1}{u+v-1}\\mathrm{B}(u.v-1)\\ \\ (u&gt;0, v&gt;1)$ $\\mathrm{B}(u,v)= \\frac{v-1}{u+v-1}\\mathrm{B}(u-1.v)\\ \\ (u&gt;1, v&gt;0)$ $\\mathrm{B}(u,v)= \\frac{(u-1)(v-1)}{(u+v-1)(u+v-2)}\\mathrm{B}(u-1.v-1)\\ \\ (u&gt;1, v&gt;1)$ 对于任意的正实数$u,v,\\mathrm{B}(u,v)=\\frac{\\Gamma(u)\\Gamma(v)}{\\Gamma(u+v)}$ 对于任意的正整数$u,v, \\mathrm{B}(u,v)=\\frac{u+v}{uvC_{u+v}^u}=\\frac{1}{vC_{u+v-1}^{u-1}}$ $\\mathrm{Chi-Squared(Central)}$$x_1\\sim N(0, 1), x_2 \\sim N(0, 1),\\cdots, x_1\\sim N(0,1)$ 定义$x=\\Sigma_{i=1}^vx_i^2$ $x$的$\\mathrm{PDF}$为： $p(x)=\\begin{equation} \\left\\{ \\begin{array}{lr} \\frac{1}{2^{v/2}\\Gamma(\\frac{v}{2})}x^{v/2-1}exp(-\\frac{1}{2}x) &amp; x &gt; 0 \\\\ 0 &amp; x &lt; 0 \\end{array} \\right\\} \\end{equation}$ $v$是个数 当$v=2$时，$x$的$\\mathrm{PDF}$就是$\\mathrm{Reyleigh}$分布的平方 $p(x)=\\begin{equation} \\left\\{ \\begin{array}{lr} \\frac{1}{2}exp(-\\frac{1}{2}x) &amp; x &gt; 0 \\\\ 0 &amp; x &lt; 0 \\end{array} \\right\\} \\end{equation}$ $\\mathrm{Chi-Squared(Noncentral)}$$x_1\\sim N(\\mu_1, 1), x_2 \\sim N(\\mu_2, 1),\\cdots, x_1\\sim N(\\mu_i,1)$ 定义$x=\\Sigma_{i=1}^vx_i^2$ $x$的$\\mathrm{PDF}$为： $p(x)=\\begin{equation} \\left\\{ \\begin{array}{lr} \\frac{1}{2}(\\frac{x}{\\lambda})^{\\frac{v-2}{4}}exp[-\\frac{1}{2}(x+\\lambda)]I_{\\frac{v}{2}-1}(\\sqrt{\\lambda x}) &amp; x &gt; 0 \\\\ 0 &amp; x &lt; 0 \\end{array} \\right\\} \\end{equation}$ 表达式：$p(x)=\\begin{equation} \\left\\{ \\begin{array}{lr} \\frac{x^{\\frac{v}{2}-1}exp[-\\frac{1}{2}(x+\\lambda)]}{2^{\\frac{v}{2}}} \\sum\\limits_{k=0}^{\\infty}\\frac{(\\frac{\\lambda x}{4})^k}{k! \\Gamma(\\frac{v}{2})+k} &amp; x&gt; 0\\\\ 0 &amp; x &lt; 0 \\end{array} \\right\\} \\end{equation}$ $v$表示相加的个数， $\\lambda=\\sum_{i=1}^v\\mu_i^2$,$\\lambda$表示均值的平方和 $\\mathrm{T}$分布$x_1\\sim N(0,1), x_2 \\sim \\mathcal{X}_v^2$， 其中$x_1,x_2$独立 定义$x=\\frac{x_1}{\\sqrt{x_2/v}}$ $x$的$\\mathrm{PDF}$为： $p(x)=\\frac{\\Gamma(\\frac{v+1}{2})}{\\sqrt{v\\pi}\\Gamma(\\frac{v}{2})}(1+\\frac{x^2}{v})^{-\\frac{v+1}{2}}$ $v$趋于$\\infty$时，就是标准的正态分布 $\\mathrm{F(Central)}$分布 $x_1\\sim \\mathcal{X}_{v_1}^2, x_2\\sim \\mathcal{X}_{v_2}^2, x_1,x_2$独立 定义$x=\\frac{x_1/v_1}{x_2/v_2}$ $x$的$\\mathrm{PDF}$为：$p(x)=\\begin{equation} \\left\\{ \\begin{array}{lr}\\frac{(\\frac{v_1}{v_2})^{\\frac{v_1}{2}}}{B(\\frac{v_1}{2},\\frac{v_2}{2})} \\frac{x^{\\frac{v_1}{2}-1}}{(1+\\frac{v_1}{v_2}x)^{\\frac{v_1+v_2}{2}}} &amp; x&gt; 0\\\\ 0 &amp; x &lt; 0 \\end{array} \\right\\} \\end{equation}$ 表达式：$p(x)=exp(-\\frac{\\lambda}{2})\\sum\\limits_{k=0}^{\\infty}\\frac{(\\frac{\\lambda}{2})^k}{k!}\\frac{(\\frac{v_1}{v_2})^{\\frac{v_1}{2}+k}}{B(\\frac{x_1+2k}{2}, \\frac{v_2}{2})}x^{\\frac{v_1}{2}+k-1}(1+\\frac{v_1}{v_2}x)^{-\\frac{1}{2}(v_1+v_2)-k}$ 中心极限定理独立同分布之和是高斯分布，高斯分布的线性组合也是高斯分布 白噪声每个时刻的噪声之间正交 $E[w(n+k)w(n)]=\\sigma^2 \\delta(k)$ 独立和不相关独立对于连续性随机变量, $f(x,y)=f_X(x)f_Y(y)$ 对于离散型的随机变量, $P(XY)=P(X)P(Y)$ 独立的性质：$E(XY)=E(X)E(Y)$ 相关协方差： $cov(X,Y)=E\\{(X-E(X))(Y-E(Y))\\}=E(XY)-E(X)E(Y)$ 相关性质： $\\rho_{X,Y}=\\frac{cov(X,Y)}{\\sqrt{D(X)}\\sqrt{D(Y)}}\\in [-1,1]$ $\\rho_{X,Y}\\in [-1,0)$为负相关 $\\rho_{X,Y}\\in (0, 1]$为正相关 $\\rho_{X,Y}=0$为不相关 $E(XY)=E(X)E(Y)$ 独立和相关的联系和区别$X,Y$独立 $\\Longrightarrow E(XY)=E(X)E(Y)\\Longrightarrow cov(X,Y)=0 \\Longrightarrow X,Y$不想管 $X,Y$不相关不能得到独立 独立性是指两个变量的发生概率一点关系没有，而相关性通常是指线性关系。如果两个变量不相关，指的是线性关系里的不相关，但是不能说它们没有关系，可能是线性以外的其他关系。","categories":[{"name":"智能计算数学基础","slug":"智能计算数学基础","permalink":"http://orzff.cn/categories/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://orzff.cn/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"概率","slug":"概率","permalink":"http://orzff.cn/tags/%E6%A6%82%E7%8E%87/"}]},{"title":"数学基础-代数","slug":"数学基础-代数","date":"2021-07-14T10:11:24.000Z","updated":"2021-08-05T11:55:43.718Z","comments":true,"path":"/d6347b6b/","link":"","permalink":"http://orzff.cn/d6347b6b/","excerpt":"智能计算数学基础-代数","text":"线性空间非空集合 $V$ 称为数域 $F $上的线性空间或向量空间,满足 加法：$\\alpha,\\beta\\in V \\Longrightarrow \\alpha+\\beta\\in V$，有零元素，负（逆）元素，满足交换律，分配律 数乘：$\\lambda \\in F, \\alpha\\in V \\Longrightarrow \\lambda\\alpha \\in V$ 线性无关 $a_1\\alpha_1+a_2\\alpha_2+\\cdots+a_n\\alpha_n \\Longleftrightarrow a_1 =a_2 = \\cdots = a_n = 0$ 维数： 极大线性无关组中元素个数 基： $\\{\\alpha_1,\\cdots,\\alpha_n\\}$，线性空间中的每个元素有都能用基来唯一的表示$\\beta=b_1\\alpha_1+\\cdots+b_n\\alpha_n$ 基就是极大线性无关组 每个元素可以使用坐标形式$(b_1,b_2,\\cdots,b_n)$，运算变为对应分量的运算 此时$F$上$n$维线性空间相当于(同构)$F^n$ 子空间$W$ 作为集合$\\emptyset \\not= W \\subseteq V$ 运算封闭$\\forall a_1,a_2 \\in F , w_1,w_2 \\in W \\Longrightarrow a_1w_1+a_2w_2 \\in W$ 平凡子空间$\\{0\\}$ 有0向量，不是空集 约定零空间的基是$\\emptyset$ 约定$\\emptyset$线性无关，约定$\\emptyset$的线性组合是0向量 子空间的交$W_1 \\bigcap W_2$ 两个子空间的交是子空间，并通常不是子空间 $W_1 \\bigcap W_2,W_1,W_2 \\subset V$ 子空间 $W_1 \\bigcup W_2$通常不是子空间 子空间的和$W_1+W_2$ 两个子空间中的值相加 $W_1+W_2:=\\{w_1+w_2|w_1\\in W_1, w_2\\in W_2\\}, W_1,W_2 \\subset V$ 直和$W_1\\bigoplus W_2$ $W = W_1 \\bigoplus W_2$,如果$w \\in W$能唯一地表示成$w_1+w_2$,其中$w_1\\in W_1,w_2\\in W_2$ 直和当且仅当$W_1 \\bigcap W_2 = \\{0\\}$ $\\dim W = \\dim W_1 + \\dim W_2$ 映射和同态线性映射：$\\mathcal{A:}U\\to V$是线性映射，亦称之为同态 $\\mathcal{A(\\alpha+\\beta)=A(\\alpha)+A(\\beta)}$ $\\forall \\lambda \\in F, \\alpha \\in U, \\mathcal{A}(\\lambda\\alpha)=\\lambda A(\\alpha)$ 线性变换(自同态)： $U=V$ (线性变换是$ U$ 到自身 的线性映射，只是个称呼) 映射的核： $Ker\\mathcal{A} = \\{u \\in U | \\mathcal{A}(u) = 0\\}$ 构成$U$的子空间 单射$\\Longleftrightarrow Ker\\mathcal{A}=0$ 亦称为零空间，记作$\\mathcal{N(A)}$ 映射的像： $Im\\ \\mathcal{A}=\\{\\mathcal{A(u)}| u \\in U\\}$也称为值域，也记作$\\mathcal{A}(U)$ 构成$V$的子空间 $Im\\ \\mathcal{A}$的维数也成为$\\mathcal{A}$的秩 满射$\\Longleftrightarrow Im\\ \\mathcal{A} = V$ $\\dim U = rank \\mathcal{A} + \\dim \\mathcal{N(A)}$ 逆映射：若存在 $\\mathcal{B} : V → U $使得$ \\mathcal{BA} = 1_U , \\mathcal{AB} = 1_V$ , 称 $\\mathcal{B}$ 为 $\\mathcal{A}$ 的逆映射. 其中$ 1_U$ 指 $U$ 上的恒等映射 同构：若逆映射存在，则$\\mathcal{A}$是$U$到$V$的同构映射 线性映射 $\\mathcal{A}:U\\to V$，其中$\\dim (U)=n,\\dim (V)= m$ 那么由于线性关系，在映射中存在一个矩阵$A = [a_{ij}]_{m\\times n}$，称为$\\mathcal{A}$在基$u_1,…u_n$和${v_1,…v_m}$下的矩阵 对任意 $x ∈ U$, 若其坐标表示为 $X = (x_1, . . . , x_n)^T$ , 则 $\\mathcal{A}(x)$在$V$ 中的 坐标为 $AX$ $\\mathcal{A} : F^n → F^m \\ X → AX$ 反之任给一个矩阵$ A ∈ F ^{m×n}$，可以诱导一个 $U$ 到 $V$ 的线性映射 线性映射 $\\mathcal{A} : F^n → F^m X→ AX$ 映射的核：$Ker(A) := {X ∈ F n | AX = 0}$ 亦称为零空间，也记作$ \\mathcal{N} (A)$ $F^n$ 的子空间 单射 $⇔ \\mathcal{N} (A) = 0$ 映射的像：$Im(A) := {AX | X ∈ F^n}$ $F^m$ 的子空间 $ \\dim Im(A) = rank(A)$, 后者是矩阵的秩 $(rank)$ 满射$ ⇔ Im(A) = F^m$ $n = \\dim \\mathcal{N} (A) + rank(A)$ 有限维线性空间，同构只需看维数 $F$ 上线性空间$ U, V, W, \\dim(U) = n, \\dim(V ) = m, \\dim(W) = p$ $\\mathcal{A}, \\mathcal{A}′ : U → V , \\mathcal{B} : V → W$ 固定 $U, V, W$ 的一组基，$\\mathcal{A}, \\mathcal{A}′ , \\mathcal{B} $在这组基下的矩阵 $A, A′ , B$ 线性映射相加 $\\mathcal{A} + \\mathcal{A}′ : U → V$ $ (\\mathcal{A} + \\mathcal{A}′ )(u) := \\mathcal{A}(u) + \\mathcal{A}′ (u)$ $\\mathcal{A} + \\mathcal{A}′ $对应的矩阵为 $S$ 可以验证$ S = A + A′$，与矩阵加法相容 (矩阵加法的一种定义) 线性映射复合$ (\\mathcal{B} ◦ \\mathcal{A}(u)) : U → W$ $\\mathcal{B} ◦ \\mathcal{A}(u) := \\mathcal{B}(\\mathcal{A}(u))$ $\\mathcal{B} ◦ \\mathcal{A} $对应的矩阵为 $M$ 可以验证 $M = BA$，与矩阵乘法相容 (矩阵乘法的一种定义) 内积$V$是实数域$\\mathbb{R}$上的线性空间，若$\\emptyset:V \\times V \\to \\mathbb{R}$满足 (双线性) $\\emptyset(\\alpha_1+\\alpha_2\\beta)=\\emptyset(\\alpha_1,\\beta)+\\emptyset(\\alpha_2,\\beta),\\emptyset(\\lambda\\alpha_1,\\beta)=\\lambda\\emptyset(\\alpha_1,\\beta)\\\\\\emptyset(\\alpha_1,\\beta_1+\\beta_2)=\\emptyset(\\alpha,\\beta_1)+\\emptyset(\\alpha,\\beta_2),\\emptyset(\\alpha,\\lambda\\beta)=\\lambda\\emptyset(\\alpha,\\beta)$ 函数取$V$中的两个分量进行运算，对加法和数乘运算保持线性 (对称性) $\\emptyset(\\alpha,\\beta)=\\emptyset(\\beta, \\alpha)$ (正定性)$\\emptyset(\\alpha,\\alpha)&gt;0$对所有$0\\not= \\alpha \\in V$ 那么$\\emptyset(\\cdot,\\cdot)$称为内积，记作$&lt;\\cdot,\\cdot&gt;$,$V$为$\\mathrm{Euclid}$空间 内积在标准正交基下$\\begin{equation} \\left[ \\begin{array}{lr} 1 &amp; &amp; &amp; &amp; \\\\ &amp; 1 &amp; &amp; &amp; \\\\ &amp; &amp; \\ddots &amp; &amp; \\\\ &amp; &amp; &amp; 1 &amp; \\\\ &amp; &amp; &amp; &amp; 1 \\end{array} \\right] \\end{equation}$，表现形式为对应分量相乘 内积的表示设$\\{v_1,\\cdots,v_n\\}$是$V$的一组基，由于内积的双线性，只需要知道所有的$$，即可知道任意两个元素的内积。$S$称为内积在这组基下的度量矩阵，其是对称的. $S=\\begin{equation} \\left[ \\begin{array}{lr} &amp; &amp; \\cdots &amp; \\\\ \\vdots &amp; \\vdots &amp; \\cdots &amp; \\vdots \\\\ &amp; &amp; \\cdots &amp; \\end{array} \\right] \\end{equation}$ 对于任意两个元素，$x^T=(x_1,x_2,\\cdots,x_n),y^T=(y_1,y_2,\\cdots,y_n)$ 坐标表示为$(x_1,x_2,\\cdots,x_n),(y_1,y_2,\\cdots,y_n)$，其值为$x=x_1v_1+\\cdots+x_nv_n, y= y_1v_1+\\cdots+y_nv_n$,对$x,y$做内积时，根据双线性规则，展开以后可以写成$=x^TSy$ 当$=1,=0$对所有的$i\\not=j$时，$S$为单位阵，内积变为$x^Ty=x_1y_1+x_2y_2+\\cdots+x_ny_n$ 此时$v_i$是一组标准正交基 正交 元素与元素$\\alpha \\bot \\beta: &lt;\\alpha,\\beta&gt;=0$ 元素与集合$\\alpha \\bot T: &lt;\\alpha, \\beta&gt;=0$对任意$\\beta \\in T$ 集合与集合$S \\bot T: &lt;\\alpha, \\beta&gt;=0$对任意$\\alpha \\in S, \\beta \\in T$ 集合$S \\subseteq U$，正交补 $S^{\\bot}:= \\{\\alpha \\in U|S \\bot \\alpha\\}$，$U$的子空间 $S$不一定是一个子空间，但是$S$的正交补一定是$U$的子空间 范数或模长$||\\alpha|| := \\sqrt{&lt;\\alpha,\\alpha&gt;}$ $\\mathrm{Cauchy-Schwarz}$不等式$|&lt;\\alpha,\\beta&gt;|\\le ||\\alpha||\\cdot||\\beta||$,$\\alpha,\\beta$同方向时取等号 夹角$cost\\theta = \\frac{&lt;\\alpha,\\beta&gt;}{||\\alpha||\\cdot ||\\beta||}$ 距离$d(\\alpha, \\beta) := ||\\alpha-\\beta||$ 矩阵$A_{m\\times n}=\\begin{equation} \\left[ \\begin{array}{lr} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\ \\vdots &amp; \\vdots &amp; \\cdots &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\end{array} \\right] \\end{equation}$ 行向量构成$\\mathbb{R}^n$的子空间 列向量构成$\\mathbb{R}^m$的子空间 行秩=列秩=秩 当$m=n$时 迹：$tr(A)=a_{11}+a_{22}+\\cdots+a_{nn}$ 行列式： $det(A),|A|$ 加法：$A_{m\\times n} + A’_{m\\times n} = A’’_{m\\times n}$ 乘法： $A_{m\\times n} \\cdot B_{n \\times l} = C_{ m \\times l} $ 当$m=n$时 乘法非交换：通常$AB \\not= BA$ 乘法单位元： $I_{n\\times n}$ 逆元：若$BA=AB=I$,$B$称为$A$的逆，记作$A^{-1}$ 未必存在，但存在即唯一 若$A,B$为$n$阶可逆方阵，$(AB)^{-1}=B^{-1}A^{-1}$ 若$A,B$为$n$阶方阵，$\\mathrm{det}(AB)=\\mathrm{det}(A)\\mathrm{det}(B)$ 矩阵转置： $(AB)^T=B^TA^T$ 若$A$可逆，$(A^T)^{-1}=(A^{-1})^T$ 矩阵分块矩阵分块运算 $\\begin{equation} \\left[ \\begin{array}{lr}A_{k\\times m} &amp; A_{k\\times n} \\\\ A_{l\\times m} &amp; A_{l\\times n} \\end{array} \\right] \\end{equation}_{(k+l)\\times (m+n)} \\cdot $ $\\begin{equation} \\left[ \\begin{array}{lr}B_{m\\times p} &amp; B_{m\\times q} \\\\ B_{m\\times p} &amp; B_{n\\times q} \\end{array} \\right] \\end{equation}_{(m+n)\\times (p+q)}$ $= \\begin{equation} \\left[ \\begin{array}{lr}A_{k\\times m}B_{m\\times p}+A_{k\\times n}B_{n\\times p} &amp; A_{k\\times n}B_{m\\times q}+A_{k\\times n}B_{n\\times q} \\\\ A_{l\\times m}B_{m\\times p}+A_{l\\times n}B_{n\\times p} &amp; A_{l\\times n}B_{m\\times q}+A_{\\times n}B_{n\\times q} \\end{array} \\right] \\end{equation}_{(k+l)\\times (p+q)} $ 矩阵按行（列）分块 $A_{m\\times n} = \\begin{equation} \\left[ \\begin{array}{lr} \\alpha_1^T \\\\ \\alpha_2^T \\\\ \\vdots \\\\ \\alpha_m^T \\end{array} \\right] \\end{equation} = $ $[\\beta_1,\\beta_2,\\cdots,\\beta_n]$ 左乘矩阵$B$，每一行都是$A$的行向量$a_i^T$的线性组合，左乘$B$相当于对$A$做行变换，右乘$B$相当于对$A$做列变换 初等矩阵与初等变换对$1\\le i &lt; j\\le n$，将$n$阶单位阵$I_n$的第$i,j$行互换得到的方阵 $P_{ij}=\\begin{equation} \\left[ \\begin{array}{lr} I_{i-1} &amp; &amp; &amp; &amp; \\\\ &amp; 0 &amp; &amp; 1 &amp; \\\\ &amp; &amp; I_{j-i-1} &amp; &amp; \\\\ &amp; 1 &amp; &amp; 0 &amp; \\\\ &amp; &amp; &amp; &amp; I_{n-j} \\end{array} \\right] \\end{equation}$ 左乘$P_{ij},A\\to P_{ij}A$,行变换，相当于将$A$的第$i,j$行互换 右乘$P_{ij},B\\to BP_{ij}$,列变换，相当于将$B$的第$i,h$列互换 $P_{ij}$的逆时$P_{ij}$ 对$1\\le i,j \\le n, i\\not= j, \\lambda \\not= 0$,将$n$阶单位阵$I_n$的第$j$行的$\\lambda$倍加到第$i$行得到的方阵 $T_{ij}(\\lambda)=\\begin{equation} \\left[ \\begin{array}{lr} I_{i-1} &amp; &amp; &amp; &amp; \\\\ &amp; 1 &amp; &amp; \\lambda &amp; \\\\ &amp; &amp; \\ddots &amp; &amp; \\\\ &amp; &amp; &amp; 1 &amp; \\\\ &amp; &amp; &amp; &amp; I_{n-j} \\end{array} \\right] \\end{equation}$ 左乘$T_{ij}(\\lambda),A\\to T_{ij}(\\lambda)A$，行变换，相当于将$A$的第$i$行的$\\lambda$倍加到第$i$行 右乘$T_{ij}(\\lambda),B\\to BT_{ij}(\\lambda)$，列变换，相当于将$B$的第$i$行的$\\lambda$倍加到第$j$行 $T_{ij}(\\lambda)$的逆是$T_{ij}(-\\lambda)$ 任何可逆方阵可以写成上述三种初等方阵的乘积 任何$m\\times n$阶矩阵$A$可以通过有限次初等行变换和初等列变换得到 $PAQ=\\begin{equation} \\left[ \\begin{array}{lr} I_r &amp; 0 \\\\ 0 &amp; 0 \\end{array} \\right] \\end{equation}$ $r=\\mathrm{rank}(A),A$的秩 $\\mathrm{rank}$是可逆变换下的不变量 $A$可逆当且仅当$r=m=n$ $A$是一个$m\\times n$的矩阵$A\\in \\mathbb{R}^{m\\times n}$,将向量从$n$维映到$m$维$A: \\mathbb{R}^n \\to \\mathbb{R}^m$ $Ax=\\begin{equation} \\left[ \\begin{array}{lr} I_r &amp; 0 \\\\ 0 &amp; 0 \\end{array} \\right] \\end{equation}$ $\\begin{equation} \\left( \\begin{array}{lr} x_1 \\\\ \\vdots \\\\ x_n \\end{array} \\right) \\end{equation}=$ $\\begin{equation} \\left( \\begin{array}{lr} x_1 \\\\ \\vdots \\\\ x_r \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{array} \\right) \\end{equation}$ $\\dim \\mathrm{Im}(A) = rank(A) = r $ $A$的像的维度是$r$ $ \\dim \\mathcal{N}(A) = n - r$ $A$的零空间的维度是$n-r$ 矩阵的列空间$A_{m\\times n} $的列空间$C(A):= \\{Ax|x\\in \\mathbb{R}^n\\}$，所有的列向量的线性组合 $A=[\\beta_1 \\ \\beta_2 \\ \\cdots \\ \\beta_n],C(A)=\\{x_1\\beta_1+x_2\\beta_2+\\cdots+x_n\\beta_n | x_i \\in \\mathbb{R}^n\\}$ 也就等于$\\mathrm{Im}(A)$ 是$\\mathbb{R}^m$的子空间 $\\dim C(A)=rank(A) = r$ 列空间的维数等于矩阵$A$的秩，也可以是或最大线性无关组的数量 $A_{m\\times n}=C_{m \\times r}R_{r \\times n}$ $A = \\begin{equation} \\left[ \\begin{array}{lr} 1 &amp; 2 &amp; 3 \\\\ 3 &amp; 1 &amp; 4 \\\\ 2 &amp; 3 &amp; 5 \\end{array} \\right] \\end{equation}$其中$\\begin{equation} \\left[ \\begin{array}{lr} 1 \\\\ 3 \\\\ 2 \\end{array} \\right] \\end{equation}+$ $\\begin{equation} \\left[ \\begin{array}{lr} 2 \\\\ 1 \\\\ 3\\end{array} \\right] \\end{equation}=$ $\\begin{equation} \\left[ \\begin{array}{lr} 3 \\\\ 3 \\\\ 5 \\end{array} \\right] \\end{equation}$ 前两列构成列空间中的一组基 $A_{m\\times n}=C_{m \\times r}R_{r \\times n} = \\begin{equation} \\left[ \\begin{array}{lr} 1 &amp; 2 \\\\ 3 &amp; 1 \\\\ 2 &amp; 3 \\end{array} \\right] \\end{equation}$ $\\begin{equation} \\left[ \\begin{array}{lr} 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\end{array} \\right] \\end{equation}$ 矩阵$A$可以分解成列空间的一组基与行空间的一组基相乘 行秩=列秩 因为$A$的秩$r=2, n-r=3-2=1$所以$\\mathcal{N}(A)$非平凡，维数为1，这也就意味着$Ax=0$有非零解$(1,1,1-1)^T$是$\\mathcal{N}(A)$的一组基 矩阵的行空间$A = \\begin{equation} \\left[ \\begin{array}{lr} \\alpha_1^T \\\\ \\vdots \\\\ \\alpha_m^T \\end{array} \\right] \\end{equation}$ 定义行空间=$\\{y_1\\alpha_1+y_2\\alpha_2+\\cdots+y_m\\alpha_m|y_i \\in \\mathbb{R}\\}$ 事实上等于$A^T$的列空间，记作$C(A^T)$ 也等于$\\mathrm{Im}(A^T)$ 是$\\mathbb{R}^n$的子空间，$\\dim C(A^T)=rank A^T = r$ $\\mathcal{N}(A)\\bot C(A^T),\\mathcal{N}(A)\\bigoplus C(A^T)=\\mathbb{R}^n$ $\\mathcal{N}(A^T)\\bot C(A),\\mathcal{N}(A^T)\\bigoplus C(A)=\\mathbb{R}^m$ 列空间与行空间$Ax = 0$, 即$\\begin{equation} \\left[ \\begin{array}{lr} \\alpha_1^T \\\\ \\vdots \\\\ \\alpha_m^T \\end{array} \\right] \\end{equation}$ $\\begin{equation} \\left[ \\begin{array}{lr}x \\end{array} \\right] \\end{equation}=$ $ \\begin{equation} \\left[ \\begin{array}{lr} 0 \\\\ \\vdots \\\\ 0 \\end{array} \\right] \\end{equation}$ 零空间$\\mathcal{N}(A)$中的元素$x$与$A$的每一行正交 若$x$为行空间$C(A^T)$中非零元素(行向量线性组合)， $Ax \\not= 0$ 零空间$\\mathcal{N}(A)$中的元素$x$与$A$的行空间正交$x\\bot C(A^T)$ 零空间$\\mathcal{N}(A^T)$中的元素$y$与$A$的列空间正交$y\\bot C(A)$ $\\mathcal{N}(A)$维数 $n-r$, $\\mathcal{N}(A^T)$维数 $m-r$ $C(A^T)$维数$r$, $C(A)$维数$r$ $C(A^T)$通过$A$可以映射到$C(A)$,同样的$C(A)$可以通过$A^T$映射到$C(A^T)$ $\\mathcal{N}(A)$通过$A$映射到0，$\\mathcal{N}(A^T)$通过$A^T$映射到0 $A_{m\\times n}$虽然本身是$\\mathbb{R}^n\\to \\mathbb{R}^m$的线性映射，但未必是可逆的(未必是满秩)，因为有零空间映射到0，这样是映射不回来的，但将$A$看作$C(A^T)\\to C(A)$的映射时，它时可逆的(维数相同，满射)，反之$A^T$是$C(A)\\to C(A^T)$的可逆映射，进一步$A^TA$是$C(A^T)$到自身的可逆线性变换 $A^TA$的零空间$\\mathcal{N}(A^TA)$等于$A$的零空间$\\mathcal{N}(A)$ $x \\in \\mathcal{N}(A) \\Longleftrightarrow Ax = 0 \\Longrightarrow A^TAx = 0$ $A^TAx = 0 \\Longrightarrow Ax \\in \\mathcal{N}(A^T) \\Longrightarrow Ax \\in \\mathcal{N}(A^T) \\cap C(A) = \\{0\\}$ $A$的列向量线性无关，则$A^TA$可逆 $A$的列向量线性无关$\\Longrightarrow \\mathcal{N}(A)=0 \\Longrightarrow \\mathcal{N}(A^TA) = 0$ 方程组消元和$LU$分解考虑方程组 $Ax =b$ $2x+3y=7 \\\\ 4x+7y=15$ $2x+3y=7\\\\ y=1$ $x=2\\\\y=1$ 左乘$T_{ij}(\\lambda)$（下三角， $i&gt; j$）对方程进行消元，变为上三角 $TA = \\begin{equation} \\left[ \\begin{array}{lr} 1 &amp; 0 \\\\ -2 &amp; 1 \\end{array} \\right] \\end{equation}$ $ \\begin{equation} \\left[ \\begin{array}{lr} 2 &amp; 3 \\\\ 4 &amp; 7 \\end{array} \\right] \\end{equation}$ = $ \\begin{equation} \\left[ \\begin{array}{lr} 2 &amp; 3 \\\\ 0 &amp; 1 \\end{array} \\right] \\end{equation}$ $=U$ $A = \\begin{equation} \\left[ \\begin{array}{lr} 1 &amp; 0 \\\\ -2 &amp; 1 \\end{array} \\right] \\end{equation}^{-1}$ $ \\begin{equation} \\left[ \\begin{array}{lr} 2 &amp; 3 \\\\ 0 &amp; 1 \\end{array} \\right] \\end{equation}= $ $ \\begin{equation} \\left[ \\begin{array}{lr} 1 &amp; 0 \\\\ 2 &amp; 1 \\end{array} \\right] \\end{equation}$ $ \\begin{equation} \\left[ \\begin{array}{lr} 2 &amp; 3 \\\\ 0 &amp; 1 \\end{array} \\right] \\end{equation}= LU$ 对矩阵$A$进行初等变换，左乘一个$T$变成上三角，因为$T$是可逆矩阵，再做成一个$T^{-1}$，就可以将$A$分解成一个上三角和一个下三角矩阵相乘的形式，这就是$LU$分解 更一般的情况，需要交换$A$的行， 那么$PA=LU$,其中$L$是下三角矩阵对角线为1，$P$为置换矩阵，是$P_{ij}$的乘积，进一步 $PA=LDU$ $D$是对角阵，使得$U$每行第一个非零元素为1 方程组求解方程组$Ax=b$ $Ax \\in C(A)$ 有解当且仅当$b\\in C(A)$ 有界当且仅当 $A$的列秩等于$[A|b]$的列秩 若$x_s$是一组特解，那么通解 $x_g = x_s + x_h$, 其中$x_h$是七次方程组$Ax=0$的解，即$x_h\\in \\mathcal{N}(A)$ 方程组消元相当于行变换$(P_{i,j},D_i(\\lambda), T_{i,j}(\\lambda))$ 消元得到的矩阵每一行第一个非零元素为1，其上元素为0 得到阶梯矩阵，极大线性无关组就是每行第一个为1的列组成的空间，剩下的列可以有线性无关组构成。 列空间的即就是极大线性无关组，零空间的基可以通过列空间之外的列并根据列空间中的基做运算得到 正交方阵$Q_{n\\times n}$的列向量$q_1,\\cdots,q_n$是标准正交的 $Q^TQ = \\begin{equation} \\left[ \\begin{array}{lr} q_1^T \\\\ q_2^T \\\\ \\vdots \\\\ q_m^T \\end{array} \\right] \\end{equation} $ $[q_1,q_2,\\cdots,q_n]$ $= I_n$ ,对角线上元素都为一，非对角线上元素都为0，所以相乘为$I$ $ I_n = QQ^T = [q_1,q_2,\\cdots,q_n]\\begin{equation} \\left[ \\begin{array}{lr} q_1^T \\\\ q_2^T \\\\ \\vdots \\\\ q_m^T \\end{array} \\right] \\end{equation} = q_1q_q^T+\\cdots+q_nq_n^T$ $Q^{-1} = Q^T$ $Q_1,Q_2$是正交方阵，则$Q_1Q_2,Q_2Q_1$亦然 等距： $||Qx||^2=x^TQ^TQx=x^Tx=||x||^2$ 特征值的模长为1: $Qx=\\lambda x, ||Qx||^2=||x||^2 \\Longrightarrow |\\lambda|^2 = 1$ 正交方阵举例 逆时针旋转$\\theta$角的矩阵 $\\begin{equation} \\left[ \\begin{array}{lr} \\cos\\theta &amp; -\\sin \\theta\\\\ \\sin \\theta &amp; \\cos \\theta \\end{array} \\right] \\end{equation} $ 使用代表坐标的向量与正交方阵相乘，就可以得到旋转$\\theta$角后的坐标 投影$y$在$x$上的投影 如果$x$是单位向量，那么$y$在$x$上的投影就是$x$与$y$做内积$x^Ty$，这得到的时投影的长度，求投影的话还要再乘上$x$方向，这里$x$时单位向量，所以直接乘上$x$即可，投影即是$xx^Ty$。 如果$x$不是单位向量，那么还是使用$x^Ty$来求投影的长度，不过这个长度是投影的长度乘上$x$的长度，这里要除掉$x$的长度$\\frac{x^Ty}{||x||}$，再乘上$x$的方向$\\frac{x}{||x||}$,经过展开就是： $\\frac{x^Ty}{||x||} \\cdot \\frac{x}{||x||} = \\frac{x^Ty}{x^Tx}x= x\\frac{x^Ty}{x^Tx} = \\frac{xx^T}{x^Tx}y$ 在一个线性转换矩阵的列空间上投影可以写成$A(A^TA)^{-1} A^T$ 经过化简得到的投影由一个矩阵和$y$组成，这就意味这对于任意的$y$，它再$x$上的投影都是$\\frac{xx^T}{x^tx}y$ $P=\\frac{xx^T}{x^Tx}$称为投影矩阵 对于任意的$\\alpha$,$P\\alpha$是$\\alpha$再$x$上的投影 $P$是对称的，$\\mathrm{rank}1, P^2=P$,满足$P$是对称和$P^2=P$也可以称为投影矩阵 $x\\bot z$ $\\mathrm{Gram-Schmidt}$正交化线性无关向量$a_1,\\cdots,a_n$通过$\\mathrm{Gram-Schmidt}$正交化生成标准正交向量$q_1,\\cdots,q_n:$ $q_1=\\frac{a_1}{||a_1||}\\\\ a’_2=a_2-q_1q_1^Ta_2,\\\\ a’_3= a_3-q_1q_1^Ta_3-q_2q_2^Ta_3,\\\\ \\vdots$ $\\\\ q_2 = \\frac{a’_2}{||a’_2||} \\\\ q_3 = \\frac{a’_3}{||a’_3||} \\\\ \\vdots$ 先将$a_1$单位化，这时$a_1$就变成$q_1$， $a_2$可能和$q_1$不正交，不正交就意味有投影，$a_2$将投影减掉得到的$q_2$就与$q_1$正交，以此类推，就得到了彼此正交长度为1的一组基 $\\begin{equation} \\left[ \\begin{array}{lr} a_1 , \\cdots, a_n \\end{array} \\right] \\end{equation} $ $\\begin{equation} \\left[ \\begin{array}{lr} b_{11} &amp; b_{12} &amp; \\cdots &amp; b_{1n} \\\\ &amp; b_{22} &amp; \\cdots &amp; b_{2n} \\\\ &amp; &amp; \\ddots &amp; \\vdots \\\\ &amp; &amp; &amp; b_{nn} \\end{array} \\right] \\end{equation} = $ \\begin{equation} \\left[ \\begin{array}{lr} q_1 , \\cdots, q_n \\end{array} \\right] \\end{equation} $q_1$只与$a_1$有关，$q_2$只与$a_1,a_2$有关，所以$q$向量可以写成矩阵相乘的形式 $\\mathrm{QR} $分解$A_{m\\times n}$的列向量线性无关，通过$\\mathrm{Gram-Schmidt}$正交化 $A_{m \\times n}T_{n\\times n} = Q_{m\\times n}$ $T$是可逆上三角矩阵，$Q$是列向量正交，且范数为1，特别地，当$m=n$时，$Q$是正交方阵 两边同时乘以$T$的逆矩阵 $A_{m\\times n} = Q_{m\\times n}R_{n \\times n} = [q_1, \\cdots, q_n] \\begin{equation} \\left[ \\begin{array}{lr} &amp; \\\\ 0 &amp; \\end{array} \\right] \\end{equation} $ 可以验证 $\\begin{equation} \\left[ \\begin{array}{lr} a_1 &amp; a_2 &amp; a_3 \\end{array} \\right] \\end{equation} =$ $\\begin{equation} \\left[ \\begin{array}{lr} q_1 &amp; q_2 &amp; q_3 \\end{array} \\right] \\end{equation}$ $\\begin{equation} \\left[ \\begin{array}{lr} q_1^Ta_1 &amp; q_1^Ta_2 &amp; q_1^Ta_3 \\\\ &amp; a_2^Ta_2 &amp; q_2^Ta_3 \\\\ &amp; &amp; q_3^Ta_3 \\end{array} \\right] \\end{equation}$ $a_1,a_2,a_3$向量在经过$\\mathrm{Gram-Schmidt}$正交化以后，形成新的坐标系$q_1,q_2,q_3$，上式就变成了原本的向量在新坐标系下的坐标 最小二乘法方程$Ax=b$,当$b\\not\\in C(A)$时，方程无解，希望计算$\\hat{x}$使得$||b-A\\hat{x}||$最小 几何上，计算$b$在空间$C(A)$中的投影$p$，此时误差向量$b-p$与$C(A)$正交，范数最小，则$p=A\\hat{x}$ $A$的列向量记作$a_i$,由于$b-A\\hat{x}$与$C(A)$正交 $\\begin{equation} \\left[ \\begin{array}{lr} q_1^T \\\\ \\vdots \\\\ a_n^T\\end{array} \\right] \\end{equation} [b-A\\hat{x}] = 0 \\Longrightarrow A^T(b-A\\hat{x}) = 0$ 最小二乘形式：$A^TX\\hat{x}=A^Tb$ 当$A^TA$可逆时，我们有最小二乘逼近$\\hat{x}=(A^TA)^{-1}A^Tb$ 如果$A$的列线性无关，则$A^TA$是可逆对称方阵 $A^TAx=0\\Longrightarrow x^TA^Tx = 0 \\Longrightarrow ||Ax|| = 0 \\Longrightarrow Ax = 0\\Longrightarrow x = 0$ 设$A=QR$,此时最小而成满足： $R^TQ^TQR\\hat{x}=R^TQ^Tb\\Longrightarrow R\\hat{x}=Q^Tb$ $b$的投影$p=A\\hat{x}=A(A^TA)^{-1}A^Tb=Pb$，其中$P=A(A^TA)^{-1}A^T$是投影矩阵 任何满足$P^2= P$的对称方阵均是某个投影矩阵 特征值和特征向量若$Ax=\\lambda x(x\\not= 0)$，称$x$是$A$的一个特征向量，$\\lambda$为特征值 $x$与$Ax$方向有一致，仅做了一个拉伸 $x$是特征向量，则$cx(x\\not=0)$亦然 移项可得$(\\lambda I-A)x=0$，因为$x\\not= 0$，所以$x$是属于$\\lambda I-A$这个矩阵的零空间中的一个元素，即$\\lambda I-A$b不是满秩。所以 $\\lambda$是$A$的特征值当且仅当 $\\mathrm{det}(\\lambda I- A)=0$ ,方阵等于零，即不满秩 以$\\lambda$为特征值的特征向量属于$\\mathcal{N}(\\lambda I-A)=\\mathrm{Ker}(\\lambda I-A)$ 以$\\lambda$为特征值的特征向量属于$\\lambda I -A$的零空间的非平凡元素 找特征向量就相当于解方程$(\\lambda-A)x=0$ 特征向量的存在性： 将$\\lambda$当未定元，记作$x$ $\\mathrm{det}(xI-A)$是关于$x$的$n$次多项式，$A$的特征多项式 代数闭域上，$\\det (xI-A)=0$存在$n$个解，如复数域$\\mathbb{C}$ 若$\\det (\\lambda I-A)=0$，则$\\mathcal{N}(\\lambda I-A)$包含非零向量，即有特征向量 特征向量的计算： 计算特征多项式$\\det (xI-A)$ 计算$\\det (xI-A)=0$的根，求出特征值 对每个特征值$\\lambda$,计算方程组$(\\lambda I - A) x = 0$的非零解 性质 特征值的数目(允许重复)为$n$， 每个特征值的重数称为代数重数 对每个不同的特征值$\\lambda_i$，至少存在一个特征向量 同一个特征值的特征向量构成特征子空间$\\mathcal{N}(\\lambda I-A)=\\mathrm{Ker}(\\lambda I -A)$，其维数称为几何重数，即齐次方程组$(\\lambda I-A)x=0$的解的维数 $1\\le $几何重数$\\le $代数重数 不同特征值的特征子空间相互正交 $A$的所有特征值(允许重复)的和等于$A$的迹 $\\lambda_1+\\lambda_2+\\cdots+\\lambda_n=\\mathrm{tr}(A)=a_{11}+a_{22}+\\cdots+a_{nn}$ $A$的左右特征值(允许重复)的积等于$A$的行列式 $\\lambda_1\\cdot \\lambda_2\\cdots \\lambda_n = \\det (A)$ $\\det(xI-A)=x^n-\\mathrm{tr}(A)x^{n-1}+\\cdots+(-1)^n \\mathrm{det}(A)$ 若$Ax=\\lambda x$ $A^mx=\\lambda ^mx, m \\in \\mathbb{N},$ $ A^{-1}x=\\frac{1}{\\lambda}x, \\lambda \\not= 0$ $A$的线性变换做$m$次以后就等于$\\lambda$的$m$次方 $e^{At}x=e^{\\lambda t}x, |\\lambda| &lt; 1$ 若$A_{n\\times n}$有$n$个线性无关的特征向量$x_1,\\cdots,x_n$，对应特征值分别为$\\lambda_1,\\cdots,\\lambda_n$，对于任意向量$v=c_1x_1+\\cdots+c_nx_n$ $v_k=A^kv=c_1\\lambda_1^kx_1+\\cdots+c_n\\lambda_n^kx_n$ $\\frac{\\mathrm{d}v}{\\mathrm{d}t}=Av$的解为$d_1e^{\\lambda_1t}x_1+\\cdots+d_ne^{\\lambda_nt}x_n$ 若方阵$B=M^{-1}AM$，称$B$与$A$相似 $A$和$B$有相同的特征方程 $|xI-A|=|M^{-1}||xI-A||M|=|M^{-1}(xI-A)M|=|xI-B|$ $A$和$B$有相同的特征值，且若$Bx=\\lambda x$，则$A(Mx)=\\lambda Mx$ 特征方程和特征值是相似不变量 若将方阵看成线性变换，线性变换在不同基下的矩阵相似 $A_{m\\times n}B_{n\\times m}$与$B_{n\\times m}A_{m\\times n}$具有相同的非零特征值 若$ABx=\\lambda x(\\lambda \\not= 0)$，则有$Bx\\not= 0$，且$BABx=B\\lambda x = \\lambda B x$ 上式可以看成$x$是$AB$的特征向量，$Bx$是$BA$的特征向量 $\\mathrm{EVD}$分解设$A_{n\\times n}$有$n$个线性无关的特征向量$x_1,\\cdots, x_n$对应的特征值分别为$\\lambda_1,\\cdots,\\lambda_n$ $A \\begin{equation} \\left[ \\begin{array}{lr} x_1 &amp; \\cdots &amp; x_n \\end{array} \\right] \\end{equation} = $ $\\begin{equation} \\left[ \\begin{array}{lr} \\lambda_1x_1 &amp; \\cdots &amp; \\lambda_nx_n \\end{array} \\right] \\end{equation} = $ $\\begin{equation} \\left[ \\begin{array}{lr} x_1 \\cdots x_n \\end{array} \\right] \\end{equation}$ $\\begin{equation} \\left[ \\begin{array}{lr} \\lambda_1 &amp; \\\\ &amp; \\ddots &amp; \\\\ &amp; &amp; \\lambda_n \\end{array} \\right] \\end{equation}$ 因此有$\\mathrm{EVD}$分解 $AX=X\\Lambda$ $A=X\\Lambda X^{-1}$ 其中$X$为$x_1,\\cdots, x_n$（列向量）构成的矩阵，$\\Lambda=diag(\\lambda_1,\\cdots,\\lambda_m)$ 即使固定$\\Lambda, X$也不唯一 谱定理进一步，如果$A$的特征值为实数，且有$n$个线性无关，彼此正交的特征向量。通过将这些特征向量标准化，得到$A$的一组标准正交基$q_1,\\cdots,q_n$,此时有 $AQ=Q\\Lambda$ $A=Q\\Lambda Q^T$ 其中$Q$为$q_1,\\cdots,q_n$（列向量）构成的正交方阵，$\\Lambda=diag(\\lambda_1,\\cdots,\\lambda_n)$，对角线形式的方阵 特别地，$A=Q\\Lambda Q^T=\\lambda_1q_1q_1^T+\\lambda_2q_2q_2^T+\\lambda_nq_nq_n^T$ 实对称方阵设$S$是实对称方阵，则$S$的特征值$\\lambda$是实数 若$Sx=\\lambda x$ ​ $\\bar{x}^TSx=\\bar{x}^T\\lambda x=\\lambda \\bar{x}^Tx \\\\ \\bar{x}^TSx=\\bar{\\bar{x}^TSx}^T=\\bar{(Sx)}^Tx=\\bar{(\\lambda x)}^Tx=\\bar{\\lambda}\\bar{x}^Tx$ ​ $\\lambda=\\bar{\\lambda}$ $S$有一组线性无关的特征向量 $S$有一组正交的特征向量 对于特征值不同的两个特征向量$x,y$， 对应的特征值$\\lambda \\not= \\gamma$ $x^TSy=x^T\\gamma y = \\gamma x^Ty \\\\ x^TSy = x^TS^Ty=(Sx)^Ty=\\lambda x^Ty$ 由于$\\lambda \\not= \\gamma$，所以$x^Ty=0$ 对于同一特征值下，选取一组标准正交基即可找到一组正交的特征向量 正定实对称方阵实对称方阵$S$是正定的，如果满足下述条件之一： $x^TSx&gt;0$，对所有非零$x$， 相当于满足正定的双线性函数构成的度量方阵就是正定实对称方阵 所有特征值$\\lambda_i&gt;0$ $S=A^TA$，$A$的列向量线性无关 所有顺序主子序$&gt;0$，即所有左上角的子矩阵的行列式$&gt;0$ 性质： $S,T$正定，则$S+T$正定 $x^T(S+T)x=x^TSx+x^TTx&gt;0$ $S$正定，则$S^{-1}$正定 $\\frac{1}{\\lambda}&gt;0$ 半正定对称方阵实对称方阵$S$是半正定的，如果满足下述条件之一： $x^TSx \\ge 0$，对所有非零$x$ 所有特征值$\\lambda_i\\ge 0$ 所有的顺序主子式$\\ge0$,即左上角的子矩阵的行列式$\\ge 0$ 根据谱定理，半正定是对称方阵能表示成$A^TA$。反过来，$A$是任意实矩阵，则$A^TA$ 对称的 特征值为实数，有正交的特征向量 $x^TA^TAx=||Ax||\\ge 0$，半正定 $\\mathrm{SVD}$分解一般矩阵的$\\mathrm{SVD}$分解对于一般矩阵$A\\in \\mathbb{R}^{m \\times n}$， 可以看成$\\mathbb{R}^n\\to \\mathbb{R}^m$的线性映射。进一步$A$诱导了$C(A^T)\\to C(A)$的满射（事实上是同构映射） $\\begin{equation} \\left\\{ \\begin{array}{lr} A v_1=\\alpha_1u_1 \\\\ Av_2=\\alpha_2u_2 \\\\ \\vdots \\\\ Av_r=\\alpha_ru_r \\\\ Av_{r+1}=0\\\\ \\vdots\\ \\\\ Av_n=0 \\end{array} \\right\\} \\end{equation}$ 希望找到$\\mathbb{R}^n$的一组标准正交基$v_1,\\cdots,v_n$（其中$v_1,\\cdots,v_n$是$C(A^T)$的一组标准正交基，$v_{r+1},\\cdots,v_r$是$\\mathcal{N}(A)$的一组标准正交基）使得$u_1,\\cdots,u_r$是$C(A)$的一组标准正交基。从而可以将其补充成$\\mathbb{R}^m$的一组标准正交基$u_1,\\cdots,u_m$ 假设标准正交基$v_1,\\cdots,v_n$和$u_1,\\cdots,u_m$满足上述条件，实矩阵$A\\in \\mathbb{R}^{m\\times n}$ 有奇异值分解 $A=U\\Sigma V^T = \\begin{equation} \\left[ \\begin{array}{lr} u_1, \\cdots, u_m\\end{array} \\right] \\end{equation}$ $\\begin{equation} \\left[ \\begin{array}{lr} \\sigma_1 &amp; &amp; &amp; \\\\ &amp; \\ddots &amp; &amp; 0 \\\\ &amp; &amp; \\sigma_r &amp; \\\\ &amp; 0 &amp; &amp; 0 \\end{array} \\right] \\end{equation}_{m\\times n}$ $\\begin{equation} \\left[ \\begin{array}{lr} v_1^T \\\\ \\vdots \\\\ v_n^T \\end{array} \\right] \\end{equation}$ 其中$U$为$m$阶正交方阵，$V$为$n$阶正交方阵的，$r$为$\\mathrm{rank}(A)$，$\\sum_{m\\times n}$非零对角元满足$\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge \\sigma_r \\ge 0$， 称为$A$的奇异值，$u_i,v_i$称为奇异向量 $\\mathrm{SVD}$分解的存在性若奇异值分解存在， $A^TA=V\\Sigma^TU^TU\\Sigma V^T=V(\\Sigma^T\\Sigma)V^T$, $U$是标准正交所以$U’=U^T$ 考察$A^TA$,$A^TA$的特点： 半正定，对称 特征值为实数($\\ge 0$)，有正交的特征向量，根据谱定理 $A^TA=V\\Lambda_{n\\times n}V^T$ 取$v_i$为$A^TA$的正交特征向量 $\\sigma_i^2$（奇异值的平方）是$A^TA$的第$i$个非零特征值(按大小顺序) 现只需证明$u_i=\\frac{Av_i}{\\sigma_i}(1 \\le i \\le r)$是正交的 $u^T_iu_j=\\frac{1}{\\sigma_i\\sigma_j}v_i^TA^TAv_j, i \\not= j \\le r$ 只看$A^TAv_j$，因为$v_j$是$A^TA$的特征向量，所以可以写成$A^TAv_j=\\sigma_i^2v_j$ 原式等于$\\frac{\\sigma_i}{\\sigma_j}v^T_iv_j =0$ 成立，说明$u_iu_j$是成交的 最后将$u_i$扩充成$\\mathbb{R}^m$的一组标准正交基，便得到了$\\mathrm{SVD}$分解 对于$AA^T$ $AA^T=U\\Sigma V^T\\Sigma^TU^T=U(\\Sigma \\Sigma^T)U^T$ 半正定，对称 特征值为实数($\\ge 0$)，有正交的特征向量，根据谱定理 $AA^T=U\\Lambda’_{m\\times m}U^T$ 取$u_i$为$AA^T$的(正交的)特征向量 $\\sigma^2_i$是$AA^T$的第$i$个非零特征值（按大小顺序） $\\sigma_i^2$即是$A^TA$的第$i$个非零特征值，也是$AA^T$的第$i$个非零特征值 不矛盾！因为$AB$和$BA$有相同的非零特征值 实际中，计算$\\mathrm{SVD}$分解并不是通过$A^TA$.比如$m&gt;&gt;n$,复杂度高 $\\mathrm{SVD}$分解性质当$A$可逆式($r=m=n$)，由于$U,V$式正交方阵，行列式为$\\pm 1$，$|\\det (A)|=\\sigma_1\\cdot \\sigma_2\\cdots \\sigma_r$ $\\sigma_1\\cdots\\sigma_2\\cdots\\sigma_r=|\\lambda_1\\cdot \\lambda_2\\cdots\\lambda_m|$ 通常$\\mathrm{tr}(A)\\not= \\sigma_1+\\sigma_2+\\cdots+\\sigma_r$ 当$A$为半正定方阵时，$\\mathrm{SVD}$分解也是普芬姐，奇异值就是非零特征值 矩阵的极分解根据方阵$A$的$SVD$分解，可以给出矩阵的极分解 $A=U\\Sigma V^T=(U\\Sigma U^T)(UV^T)=SQ$ 其中$S$为半正定对称方阵，$Q$为正交方阵 矩阵的$\\mathrm{SVD}$分解$A=U\\Sigma V^T = \\begin{equation} \\left[ \\begin{array}{lr} u_1, \\cdots, u_m\\end{array} \\right] \\end{equation}_{m\\times m}$ $\\begin{equation} \\left[ \\begin{array}{lr} \\sigma_1 &amp; &amp; &amp; \\\\ &amp; \\ddots &amp; &amp; 0 \\\\ &amp; &amp; \\sigma_r &amp; \\\\ &amp; 0 &amp; &amp; 0 \\end{array} \\right] \\end{equation}_{m\\times n}$ $\\begin{equation} \\left[ \\begin{array}{lr} v_1^T \\\\ \\vdots \\\\ v_n^T \\end{array} \\right] \\end{equation}_{n\\times n}$ $= \\alpha_1u_1v_1^T+\\alpha_2u_2v_2^T+\\cdots+\\alpha_ru_rv_r^T$ $=\\begin{equation} \\left[ \\begin{array}{lr} u_1, \\cdots, u_r\\end{array} \\right] \\end{equation}_{m\\times r}$ $\\begin{equation} \\left[ \\begin{array}{lr} \\sigma_1 &amp; &amp; \\\\ &amp; \\ddots &amp; \\\\ &amp; &amp; \\sigma_r \\end{array} \\right] \\end{equation}_{r\\times r}$ $\\begin{equation} \\left[ \\begin{array}{lr} v_1^T \\\\ \\vdots \\\\ v_r^T \\end{array} \\right] \\end{equation}_{r\\times n}$ $u_{r+1},\\cdots,u_m\\in \\mathcal{N}(A^T)$， $v_{r+1},\\cdots,v_n\\in \\mathcal{N}(A)$，没有贡献 $A_k$和$\\mathrm{Eckart-Young}$定理设$A_k\\in \\mathbb{R}_{m\\times n}$, $A = U\\Sigma V^T=\\sigma_1u_1v_1^T+\\sigma_2u_2v_2^T+\\cdots+\\sigma_ru_rv_r^T$ 对$1\\le k \\le r$，令 $A_K := U_k\\Sigma_kV_k^T=\\sigma_1u_1v_1^T+\\sigma+2u_2v_2^T+\\cdots+\\sigma_ku_kv_k^T$ 则$\\mathrm{rank}A_k = k,$且随着$k$增大，$A_k$ 逼近$A$ $\\mathrm{Eckart-Young}$定理： 对$\\mathbb{R}_{m\\times n}$中任意秩为$k$的矩阵$B_{m\\times n}$，有$||A-B||\\ge ||A-A_k||$ ($||A-b||$，两个矩阵的距离) 直观的说，$A_k$时所有$\\mathrm{rank}k$的矩阵中距离$A$最近的 谈距离，就需要定义度量 度量$d$需要满足三个性质： （非负性）$d(x,y)\\ge 0$且$d(x,y)=0\\Longleftrightarrow x=y$ （对称性）$dx(x,y)=d(y,x)$ （三角不等式） $d(x,z) \\le d(x,y)+d(y,z)$ 向量的度量通过范数定义$d(v_1,v_2):=||v_1-v_2||$ 向量的范数需要满足： （非负性）$||v||\\ge 0 $且$||V||=0 \\Longleftrightarrow v = 0$ （齐次性）$||cv|| = |c|||v||$ （三角不等式）$||v_1+v_2|| \\le ||v_1||+||v_2||$ 向量的范数 ($l_2$范数) $||v||_2 := \\sqrt{|v_1|^2+\\cdots||v_n|^2}$ ($l_1$范数)$||v||_1 := |v_1| + \\cdots||v_n|$ ($l_{\\infty}$范数) $||v||_{\\infty} := \\max\\limits_{1\\le i\\le n}|v_i|$ 矩阵的范数 $spertral\\ norm:$ $||A||_2 := \\max\\limits_{x\\not= 0} \\frac{||Ax||_2}{||x||_2}$ $Frobenius\\ norm :$ $||A||_F := \\sqrt{\\sum_{i,j}|a_{ij}|^2}$ 事实上，$||A||_2=\\sigma_1$ $\\max\\limits_{x \\not= 0} \\frac{||Ax||_2}{||x||_2}=\\max\\limits_{x\\not=0}\\frac{||U\\Sigma V^Tx||_2}{||x||_2} = \\max\\limits_{y\\not= 0}\\frac{||U\\Sigma y||_2}{||Vy||_2} = \\max\\limits_{y\\not= 0} \\frac{||\\Sigma y||_2}{||y||_2}$ 由于正交变换不影响范数 $||A||_F = \\sqrt{\\mathrm{tr}(A^TA)} = \\sqrt{\\Sigma_{i}\\sigma_i^2}$ 矩阵的伪逆定义矩阵$A_{m\\times n}$的伪逆为$A^{ \\dagger }_{n\\times m} = V\\Sigma^{\\dagger} U^T$ 其中$\\Sigma^{\\dagger} = \\begin{equation} \\left[ \\begin{array}{lr} 1/\\sigma_1 &amp; &amp; &amp; \\\\ &amp; \\ddots &amp; &amp; 0 \\\\ &amp; &amp; 1/\\sigma_r &amp; \\\\ &amp; 0 &amp; &amp; 0 \\end{array} \\right] \\end{equation}_{n\\times m}$ $A^{\\dagger}A=V \\begin{equation} \\left[ \\begin{array}{lr} 1 &amp; &amp; &amp; \\\\ &amp; \\ddots &amp; &amp; 0 \\\\ &amp; &amp; 1 &amp; \\\\ &amp; 0 &amp; &amp; 0 \\end{array} \\right] \\end{equation}_{n\\times n} V^T, AA^{\\dagger} = U$ $ \\begin{equation} \\left[ \\begin{array}{lr} 1 &amp; &amp; &amp; \\\\ &amp; \\ddots &amp; &amp; 0 \\\\ &amp; &amp; 1 &amp; \\\\ &amp; 0 &amp; &amp; 0 \\end{array} \\right] \\end{equation}_{m \\times m} U^T$ 若$A$可逆，$A^{\\dagger}=A^{-1}=V\\Sigma^{-1}U^T$ 若$\\mathrm{rank}A=n$，则$A^TA$可逆，$A^{\\dagger}=(A^TA)^{-1}A^T$ $(A^TA)^{-1}A^T=(V\\Sigma^T\\Sigma V^T)^{-1}V\\Sigma^T U^T \\\\ = V(\\Sigma^T\\Sigma)^{-1}V^TV\\Sigma^TU^T = V\\Sigma^{\\dagger}U^T$ 若$\\mathrm{rank}A=m$，则$AA^T$可逆，$A^{\\dagger}=A^T(AA^T)^{-1}$ 对于$1\\le i \\le r$ $Av_i=\\sigma_iu_i,A^{\\dagger}u_i=1/\\sigma_iv_i\\\\ A^{\\dagger}A=1_{C(A^T)}, AA^{\\dagger}=1_{C(A)}$ 令$b=b_A+n_N$, 其中$b_A\\in C(A)$是$b$在$C(A)$中的投影，$b_N\\in \\mathcal{N}(A^T)=\\mathcal{N}(A^{\\dagger})$ 此时$Ax=b_A$有解$\\hat{x}=A^{\\dagger}b_A$ $\\hat{x}=A^{\\dagger}b_A+A^{\\dagger}b_N=A^{\\dagger}b$","categories":[{"name":"智能计算数学基础","slug":"智能计算数学基础","permalink":"http://orzff.cn/categories/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://orzff.cn/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"代数","slug":"代数","permalink":"http://orzff.cn/tags/%E4%BB%A3%E6%95%B0/"}]},{"title":"数学基础-分析","slug":"数学基础-分析","date":"2021-07-06T14:46:19.000Z","updated":"2021-09-14T07:48:42.866Z","comments":true,"path":"/e403a46/","link":"","permalink":"http://orzff.cn/e403a46/","excerpt":"智能计算数学基础-分析","text":"向量范数向量一范数：$||X||_1=\\sum\\limits_{i=1}^n|x_i|$ 向量二范数：$||X||_2=(\\sum\\limits_{i=1}^nx_i^2)^{\\frac{1}{2}}=\\sqrt{\\sum\\limits_{i=1}^nx_i^2}$ 向量无穷范数：$||X||_{\\infty}=\\max\\limits_{i\\le i\\le n}|x_i|$ 不等式柯西不等式对于实数：$|\\sum\\limits_{i=1}^{n}a_i|\\le \\sum\\limits_{i=1}^n|a_i|,a_i\\in \\mathbb{R}$ 对于向量形式：$(\\sum\\limits_{i=1}^na_ib_i)^2\\le \\sum\\limits_{i=1}^na_i^2 \\sum\\limits_{i=1}^nb_i^2\\leftrightarrow| \\lt a,b \\gt|\\le ||a|| \\cdot ||b||$ 证明： 右边-左边$=\\sum\\limits_{ij}(a_ib_j-a_jb_i)^2\\ge0$ ??： $\\forall \\lambda \\ge 0,\\sum\\limits_{i=1}^n(a_i-\\lambda b_i)^2\\ge0$ $\\sum\\limits_{i=1}^n(a_i^2-2a_ib_i\\lambda+b_i^2\\lambda^2) \\ge 0 \\\\ (\\sum\\limits_{i=1}^{n}b_i^2)\\lambda^2-2(\\sum\\limits_{i=1}^na_ib_i)\\lambda+\\sum\\limits_{i=1}^na_i^2\\ge 0$ 这是关于$\\lambda$的二次函数 算数几何平均不等式$(a_1,a_2,…a_n)$ 算数平均值：$\\frac{\\sum\\limits_{i=1}^na_i}{n}$ 几何平均值：$(\\prod\\limits_{i=1}^na_i)^\\frac{1}{n}$ 算数平均值大于等于几何平均值 $\\frac{\\sum\\limits_{i=1}^na_i}{n} \\ge (\\prod\\limits_{i=1}^na_i)^\\frac{1}{n}$ 证明 $n=2$时： $\\frac{1}{2}(a_1+a_2)\\ge \\sqrt{a_1a_2}\\\\ \\leftrightarrow(a_1+a_2)^2\\ge4a_1a_2\\\\ \\leftrightarrow (a_1-a_2)^2 \\ge 0$ $n=3$时： $\\frac{1}{2}(a_1+a_2+a_3)\\ge (a_1a_2a_3)^{\\frac{1}{3}}\\\\ \\leftrightarrow x^3+y^3+z^3 \\ge 3xyz\\\\ \\leftrightarrow (x+y+z)((x-y)^2+(y-z)^2+(z-x)^2) \\ge 0$ 极限 序列$a_n$收敛跟$a_n$时柯西列等价 单调有界序列一定有极限 $\\lim\\limits_{n\\to\\infty}(1+\\frac{1}{n})^n=e$ $|a_n| \\le b_n$， $\\sum\\limits_{n\\ge 1}b_n$收敛那么$\\sum\\limits_{n\\ge 1}a_n$收敛 上极限：$\\lim\\limits_{n\\to \\infty}\\sup a_n \\triangleq \\lim\\limits_{n\\to \\infty}(\\sup\\limits_{m\\ge n}a_m) = \\inf\\limits_{n\\ge 1}(\\sup\\limits_{m\\ge n} a_m)$ 下极限：$\\lim\\limits_{n\\to \\infty}\\inf a_n \\triangleq \\lim\\limits_{n\\to \\infty}(\\inf\\limits_{m\\ge n}a_m) = \\sup\\limits_{n\\ge 1}(\\inf\\limits_{m\\ge n} a_m)$ $\\sum\\limits_{n\\ge 1}\\frac{1}{n^s}$收敛$\\iff\\ s&gt;1$，$\\sum\\limits_{n\\ge 1}\\frac{1}{n}$发散 $\\sum\\limits_{n\\ge 2}\\frac{1}{n(\\log n)^s}$收敛$\\iff\\ s&gt;1$，$\\sum\\limits_{n\\ge 2}\\frac{1}{n(\\log n)}$发散 $\\sum\\limits_{n\\ge0}\\frac{(-1)^n}{2n+1}=\\frac{\\pi}{4}$ 点集开集，闭集，紧集 开集定义： $A \\subset \\mathbb{R}^n, \\forall x \\in A$都存在以$x$为中心，$r&gt;0$为半径的一个球$\\{y\\in\\mathbb{R}^n: ||y-x|| &lt; r\\}$叫做$B(x,r)$ 然后$B(x,r)\\subset A$。 性质： 任意个开集并，那么也是开集$\\cup A_i$ 有限个开集交，那么也是开集 $\\cap^NA_i$ 闭集$A$闭集 $\\iff A^C$开集 $\\{ x_k\\}_{k\\ge 1} \\subset A, \\lim\\limits_{k\\to \\infty}x_k = x \\in A$ $x_k$序列属于$A$，并且$x_k$的极限在$A$中，那么$x$也属于$A$ 紧集$A$称为紧集，如果$A$是有界闭集，即$A$是闭集并且存在开球$B(x,r)$使得$A\\subset B(x,r)$ 空集和实数集空集：是开集，是闭集，是紧集 实数集：是开集，是闭集，不是紧集 连续连续函数： $\\lim\\limits_{x\\to a}f(x)=f(a)$ $\\forall \\gt 0, \\exists\\delta\\gt0$使得对于任何满足条件$||x-a||\\lt\\delta$的$x$都成立$|f(x)-f(a)|&lt;\\epsilon$ 若$f:D\\subset \\mathbb{R}^n \\to \\mathbb{R}$，那么$|f(x)-f(y)|\\le k||x-y||$对于任何属于$D$的$x,y$都成立 若$f:D\\subset \\mathbb{R}^n \\to \\mathbb{R}$在$D$中任何点都连续，则称其在$D$上连续 $f$在开集$D$上连续，等价于，对于任何开集$U\\subset \\mathbb{R}$，其逆像$f^{-1}(U)=\\{x\\in\\mathbb{R}^n : f(x)\\in U\\}\\subset \\mathbb{R}^n$仍是开集 常用函数(幂指对，三角函数，多项式)都是连续函数 两个重要函数极限 $\\lim\\limits_{x\\to 0}\\frac{sinx}{x}=1$ $0\\lt x \\lt \\frac{\\pi}{2} \\Longrightarrow cosx \\lt \\frac{sinx}{x} \\lt 1$ 因此，函数$\\frac{sinx}{x}$可看作定义在$\\mathbb{R}$上的连续函数 $\\lim\\limits_{x\\to +\\infty}(1+\\frac{1}{x})^x=e$ $n\\le x \\le n+1 \\Longrightarrow (1+\\frac{1}{n+1})^n \\lt (1+\\frac{1}{x})^x \\lt (1+\\frac{1}{n})^{n+1}$ 介值定理函数$f:[a,b]\\to \\mathbb{R}$连续，且$f(a)\\not= f(b)$,则对于任何$f(a)$和$f(b)$之间的值$s$,都存在$x\\in (a,b)$使得$f(x)=s$ 导数 可导$\\Longrightarrow$连续,可导$\\not\\Longleftarrow$连续 $(fg)’=f’g+fg’,(af+bg)’=af’+bg’,(\\frac{f}{g})’=\\frac{f’g-fg’}{g^2}$ 链式法则：$(f(g(x)))’=f’(g(x))g’(x)$ $f(x) = det(I+xA),f’(0)=tr(A)$ $f:[a,b]\\to\\mathbb{R}$,$f$在$x\\in (a,b)$取得局部最小值$\\Longrightarrow f’(x)=0$ 微分中值定理$f$在$[a,b]$上连续，并在$(a,b)$上可微，则存在$x\\in (a,b)$使得$f’(x)=\\frac{f(b)-f(a)}{b-a}$ $Rlolle$定理：如果$f(a)=f(b)$，则存在$x\\in(a,b)$使得$f’(x)=0$ 洛必达法则假设$f$和$g$在$(a,b)$上可微，并且对于任何$x\\in (a,b)$都有$g’(x)\\not=0$,如果下述条件满足 $\\lim\\limits_{x-\\to a}f(x)=\\lim\\limits_{x\\to a}g(x)=0$或者$\\lim\\limits_{x\\to a}g(x)=+\\infty$ $\\lim\\limits_{x\\to a}\\frac{f’(x)}{g’(x)}=A$ 则有$\\lim\\limits_{x\\to a}\\frac{f(x)}{g(x)}=A$ $\\frac{f(x)}{g(x)}\\approx \\frac{f’(x)}{g’(x)}=\\lim\\limits_{x\\to a}\\frac{f’(x)}{g’(x)}$ $[a,b]$上的单调函数几乎处处可微 泰勒展开若$f$在$x_0$的一个邻域内$(n+1)$次可微，则对于该邻域内的任意$x$都成立 $f(x)=\\sum\\limits_{k=0}^n\\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k+R_n(x)$ 其中余项$R_n(x)$满足 无穷小量形式：$R_n(x)=o((x-x_0)^n)$ 微分形式：存在$\\theta\\in(x,x_0)$使得$R_n(x)=\\frac{f^{(n+1)}(\\theta)}{(n+1)!}(x-x_0)^{(n+1)}$ 积分形式：$R_n(x)=\\frac{1}{n!}\\int_{x_0}^x(x-t)^nf^{(n+1)}(t)dt $ $e^x=\\sum\\limits_{k=0}^n\\frac{x^k}{k!}+o(x^n)$ $\\log(1+x)=\\sum\\limits_{k=1}^n(-1)^{(k+1)}\\frac{x^k}{k}+o(x^n)$ $\\log(1-x)=-\\sum\\limits_{k=1}^n\\frac{x^k}{k}+o(x^n)$ 多元微分一元微分$f$在点$x$处可微$\\iff f(y)=f(x)+a(y-x)+o(y-x),f(x)$是固定的$a(y-x)$可以看成增量$\\Delta x,$$o(y-x)$ 是无穷小量 不考虑无穷小量时，$f(y)$可近似看成$f(y)\\approx f(x)+a(y-x)$,这个就是关于增量$\\Delta x=y-x$的线性函数 这样一元微分就在$x$出展开成了一个线性函数 多元微分什么是多元函数多元函数就是在定义域$D\\subset\\mathbb{R}^n$ 通过某些规则达到$f(x)$ 比如$f(x)=||x||_2^2=\\sum\\limits_{i=1}^nx_i^2$这就是一个多元函数 如果$f:D\\subset \\mathbb{R}^n \\to \\mathbb{R}$ 这就代表$f(x)$是一个单值多元函数 如果：$f:D\\subset\\mathbb{R}^n\\to\\mathbb{R}^m$,这就代表$f(x)$是一个多值多元函数 关于多值多元函数，可以看成$x\\to(f_1(x),\\cdots,f_m(x))$其中每个$f$都是一个单值多元函数$f:D\\subset\\mathbb{R}^n \\to \\mathbb{R}$ $f(x_1,x_2)=(x_1+x_2, x_1x_2)$这个就是一个$\\mathbb{R}^2\\to\\mathbb{R}^2$的多元函数 多元微分对多元函数$f:D\\subset\\mathbb{R}^n\\to\\mathbb{R}^m$求微分可以借鉴一元微分的方法，在$x$处将微分展开成一个线性函数 $f(y)\\approx f(x)+L(y-x)$ $L$是一个线性映射，将$n$维的向量映射成$m$为的向量，也可以说是一个矩阵，$L(y-x)$是作用在$y-x$之上的 $L(y-x)$也可写成$L(y-x)=A(y-x)$,$L(y-x)$是$n\\times m$形式的， $y-x$是一个$n\\times1$的向量，$A$是一个$m\\times$n的矩阵，线性映射可以唯一的写成矩阵形式 对于$f:D\\subset \\mathbb{R}^n\\to \\mathbb{R}^m$，如果存在一个矩阵$A$，使得$f(y)=f(x)+A(y-x)+o(||y-x||)$成立，那么就称$f$在点$x\\subset D$处可微,$A$记作微分$A=Df(x)$ 也可以写成$\\exists A \\ \\ st. \\ \\ \\lim\\limits_{y\\to x} \\frac{||f(y)-f(x)-A(y-x)||}{||y-x||}=0$ 例子： $f(x)=Ax+b, A_{m\\times n},b\\in \\mathbb{R}^m$ 此时$Df(x)=?$ 证明： $f(y)-f(x)\\\\=Ay+b-(Ax+b)\\\\=A(y-x)$ 所以$f(y)-f(x)=A(y-x)$ 那么$\\lim\\limits_{y\\to x} \\frac{||f(y)-f(x)-A(y-x)||}{||y-x||}=0$成立，所以$Df(x)=A$ 偏导$f:D\\subset\\mathbb{R}^n\\to\\mathbb{R}$,对于这样一个映射，其多元微分可以写成$f(y)=f(x)+Df(x)(y-x)+o(||y-x||)$ 其中$Df(x)$是$1\\times n$的，所以$Df(x)$也可以看成$v^t$ 即$f(y)=f(x)+v^t(y-x)+o(||y-x||)\\\\f(y)=f(x)+\\sum\\limits_{i=1}^nv_i(y_i-x_i)+o(||y-x||)$ 将$i$固定，$\\forall j\\not= i,y_j=x_j$，保留一个$i$将其他方向的变量全部固定，这样$x,y$就可以看成处于同一条轴上 此时$f(x_1,\\cdots,x_{i-1},y_i,x_{i+1},\\cdots,x_n)=f(x_1,\\cdots,x_n)+v_i(y_i-x_i)+o(|y_i-x_i|)$ 因为$f$函数的所有其他变量全部都固定成了$x_i$,$f(x_1,\\cdots,x_{i-1},y_i,x_{i+1},\\cdots,x_n)$相当于只有一个自变量$y_i$这样$f(x_1,\\cdots,x_{i-1},y_i,x_{i+1},\\cdots,x_n)$可以看成是一个关于$y_i$的函数$g(y_i)$,此时$g(y_i)=g(x_1)+v_i(y_i-x_i)+o(|y_i-x_i|)$在这个一元函数中，可以明显发现$g$的微分就是$v_i=g’(x_i)$ 其他的$i$都被固定住，求出的这个$g’_i(x_i)$就叫做$f$在$x$处第$i$个方向的偏导数，$g’_i(x_i)$可以写成$\\partial_if(x)$ 如果偏导存在,那么$Df(x)=(g’_1(x_i),g’_2(x_i),\\cdots,g’_n(x_n))=(\\partial_1if(x),\\cdots,\\partial_nif(x))$ 将$Df(x)$竖起来的话，就叫做梯度 梯度和偏导如果$f$在点$x$处可维$\\Longrightarrow Df(x)=(\\triangledown f(x))^t$，梯度是多元微分的转置，也能推出$f(y)=f(x)+\\triangledown f(x)(y-x)+o(||y-x||)$ 可微$\\Longrightarrow $梯度存在，梯度存在$\\not\\Longrightarrow$ 可微 当$f:D\\in\\mathbb{R}^n\\to \\mathbb{R}，D是开集$，向量每个方向的偏导数$\\partial_if(x)$都存在并且连续，此时可以推出来$\\Longrightarrow $$f$在$D$上可微 $f$在$D$上偏导存在并且连续，我们记作$f\\in C^1(D)$ 计算微分1对于$A\\in \\mathbb{R}^{m\\times n},b\\in \\mathbb{R}^m$ 计算一个函数$f(x)=||AX-b||^2$的微分 $f(x)$ $ =||AX-b||^2$ $=(AX-b)^t(AX-b)$ $=(X^tA^t-b^t)(AX-b) $ $ = X^tA^tAX-b^tAX-X^tA^tb+b^tb $ $=X^t(A^tA)X-2(A^tb)^tX+b^tb$ 这个就是关于$X$的二次函数 $f(x)=\\frac{1}{2}X^tpX+q^tX+r,p=2A^tA,q=-2(A^tb)$ 此时对$X$微分，梯度就等于$\\triangledown f(x)=pX=q=2A^tAX+2A^tb$ 梯度转置一下就是微分了 2$f(x)=e^{w^tx},w,x\\in \\mathbb{R}^n$求微分 $f(x)$可以看成$f(x)=e^{w_1x_1+w_2x_2+\\cdots+w_nx_n}$ 求偏导时$\\partial_1f(x)=w_1e^{w_1x_1+\\cdots+w_nx_n} \\\\ \\partial_if(x)=w_ie^{w_1x_1+\\cdots+w_nx_n}$ $\\triangledown f(x) = (w_1e^{w_1x_1+\\cdots+w_nx_n},\\cdots, w_ne^{w_1x_1+\\cdots+w_nx_n})^t=f(x)w$ 计算出来的梯度为$wf(x)$，因为$f(x)$是连续的，所以梯度也是连续的，那么就可以推出$\\triangledown f(x)=(Df(x))^t, Df(x)=f(x)w^t$ 复合函数求导一元函数求导: $g(f(x))’=g’(f(x))f’(x)$ 多元函数: $D(g\\circ f(x))=D g(f(x))Df(x)$ $g\\circ f(x)=g(f(x))$ 其中$f:\\mathbb{R}^n\\to \\mathbb{R}^m \\\\g:\\mathbb{R}^m\\to \\mathbb{R}^k$ $g\\circ f(x): \\mathbb{R}^n\\to \\mathbb{R}^k$ 一元函数：$(fg)’(x)=f(x)g’(x)+f’(x)=g(x)$ 多元函数：$D(fg)(x)=f(x)Dg(x)+g(x)Df(x)$ 矩阵微分$f: D\\in \\mathbb{R}^{m\\times n}\\to \\mathbb{R}, f(A),A_{m\\times n}$ 多元函数参数是矩阵时求偏导，实际上$f(A)$的参数是一个$m\\times n$的行向量，但是写的时候还是当作矩阵来写 $(Df(A))_{i,j}=\\partial_{a_{ij}}f(A)$,对矩阵的第$i,j$位置求偏导 例子：$f(A)=tr(AB),A:m\\times n,B: n\\times m$，求$Df(A)$ $f(A) = tr(AB)=\\sum\\limits_{i=1}^m(AB)_{ii}\\\\ =\\sum\\limits_{i=1}^m\\sum\\limits_{j=1}^na_{i,j}b_{j,i}=\\sum\\limits_{i.j}a_{j,i}b_{i,j}$ 此时$f(A)=\\sum a_{i,j}b_{j,i}$ $\\partial_{a_{i,j}}f(A)=b_{j,i}\\\\ (Df(A))_{i,j}=b_{j,i}=(B^t)_{i,j}$ $f(A)=tr(AB) \\Longrightarrow D(f(A))=B^t$ 例子：$f(A)=tr(ABA^t),A:m\\times n,B: n\\times n$求$Df(A)$ $f(A)$$=tr(ABA^t) \\\\ =\\sum(ABA^t)_{i,i}\\\\ = \\sum (A)_{i,j}(B)_{j,k}(A^t)_{k.i} \\\\ = \\sum (A)_{i,j}(B)_{j,k}(A)_{i,k}\\\\ =\\sum a_{i,j}b_{j,k}a_{i,k}$ 此时，为了区分$\\partial a_{i,j}f$中的$i,j$,我们将$f(A)$中的$i,j,k$转换成$i’,j’,k’$ $f(A)=\\sum a_{i’,j’}b_{j’,k’}a_{i’,k’}\\\\ \\partial_{a_{i,j}}f=\\sum \\partial_{a_{i,j}}(a_{i’,j’}a_{i’k’})b_{j’,k’}$ 在$\\partial_{a_{i,j}}$中是两个函数相乘的形式$(fg)’=f’g+g’f$ 所以$\\partial_{a_{i,j}}f=\\sum \\partial_{a_{i,j}}(a_{i’,j’})a_{i’k’}b_{j’,k’}+\\partial_{a_{i,j}}(a_{i’,k’})a_{i’j’}b_{j’,k’}$ 前一项中的$\\partial_{a_{i,j}}(a_{i’,j’})$只有在$i’=i,j’=j$是才不为0，所以第一项可以写成$\\sum a_{i,k’}b_{j,k’}$ 后一项同理$i’=i,k’=j$时才为1，$\\sum a_{i,j’}b_{j’,k}$,整理一下$\\partial_{a_{i,j}}f=\\sum\\limits_{k}a_{i,k}b_{j,k}+\\sum\\limits_{k}a_{i,k}b_{k,j}\\\\=(AB^t)_{i,j}+(AB)_{i,j}=(AB^t+AB)_{i,j}$ 所以$f(A)=tr(ABA^t)\\Longrightarrow Df(A)=A(B+B^t)$ $tr(A)=tr(A^t) \\\\ f(A)=tr(ABA^t)\\Longrightarrow A(B+B^t)$ $||A||^2=tr(AA^t)=tr(AIA^t)\\\\Df(A)=A(I+I^t)=2AI=2A$ 例子：$f(A)=x^tA^{-1}x,$ $A$是可逆的$n$阶对称方阵，$x\\in \\mathbb{R}^n$,求$Df(X0)$ $f(A+ \\epsilon) - f(A)\\\\ =x^t(A+\\epsilon)^{-1}x-x^tA^{-1}x \\\\ = x^t((A+\\epsilon)^{-1}-A^{-1})x$ 因为$x^t,x$都是常量，所以关键就是$(A+\\epsilon)^{-1}-A^{-1}$ $(A+\\epsilon)^{-1}-A^{-1}\\\\ =(I+A^{-1}\\epsilon)^{-1}-A^{-1}$ 因为$\\epsilon$是一个小值，而一个小值可以写成$(I-X)^{-1}=I+X+X^2+X^3+\\cdots$ 所以，原式=$(I-A^{-1}\\epsilon+(A^{-1}\\epsilon)^2-(A^{-1}\\epsilon)^3+\\cdots)A^{-1}-A^{-1} \\\\ =A^{-1}-A^{-1}\\epsilon A^{-1}+(A^{-1}\\epsilon)^2 A^{-1}-(A^{-1}\\epsilon)^3 A^{-1} + \\cdots - A^{-1}\\\\ = -A^{-1}\\epsilon A^{-1} + o(\\epsilon)$ 后面那些小值可以看成一个关于$\\epsilon$的无穷小量 $f(A+\\epsilon)-f(A)=x^t(-A^{-1}\\epsilon A^{-1} + o(\\epsilon))x \\\\ = -x^tA^{-1}\\epsilon A^{-1}x + o(\\epsilon) $ $x^tA^{-1}$和$A^{-1}x$都是向量，所以$-x^tA^{-1}\\epsilon A^{-1}x$是关于$\\epsilon$分量的线性组合 设$A^{-1}x = y,y^t=x^t(A^{-1})^t=x^tA^{-1}$ 原式=$-y^t\\epsilon y + o(\\epsilon)$ $f(A+\\epsilon)-f(A) = -\\sum\\limits_{i,j}y_iy_j\\epsilon_{i,j}+o(\\epsilon)$ 偏微分就为：$\\partial_{a_{i,j}}f(A)=-y_iy_j = -(yy^t)_{i,j}$ 导数就为：$Df(A)=-yy^t=-A^{-1}x(A^{-1}x)^t=-A^{-1}xx^tA^{-1}$ 矩阵二阶展开 多元函数：$\\partial_j(\\partial_if(x))$等价于$\\partial_{i,j}f(x)$ 对于$f:D\\in \\mathbb{R}^n \\to \\mathbb{R}$,如果$\\partial_{i,j}f$都存在且连续，称$f$是$D$上二次连续可微的函数$f \\in C^2(D)$ $(\\partial_{i,j}f)_{1\\le i,j \\le n}$是一个$n\\times n$矩阵 ，称为$Hessian$矩阵， 梯度可以看成是一阶导数，对每个向量求偏导，$Hessian$可以看成是二阶导数，对已经求出的导数再对每个向量求偏导，最终得到的是一个$n\\times n$的矩阵 二阶展开： $f(y)=f(x)+Df(x)(y-x)+\\frac{1}{2}(y-x)^t(\\partial_{i,j}f)(y-x)+D(||y-x||^2)$ 因为$Df(x)$是梯度的转置，而$\\partial_{i,j}f$可以写成$\\triangledown^2f$ 所以也可以写成：$f(y)=f(x)+\\triangledown f(x)(y-x)+\\frac{1}{2}(y-x)^t\\triangledown^2f(x)(y-x)+o(||y-x||^2)$ 如果$f(y)=f(x)+q^t(y-x)+\\frac{1}{2}(y-x)^tp(y-x)+o(||y-x||^2),$其中$q=\\triangledown f(x),p=\\triangledown ^2 f(x)$ 优化对于定义域在$D$上的函数$f$找极小值 如果存在$x’$，在$x’$的邻域$B(x’,r)$内，所有值都小于$f(x’)$的$f(x’)\\le f(x)$，那么$x’$就是这个函数在$B(x’,r)$的局部极小值 局部极小值必要条件$x’$是局部极小值$\\Longrightarrow$ $Df(x^{})=0,\\triangledown^2f(x^{})\\ge 0$ 半正定矩阵: $P \\Longleftrightarrow x^tPx \\ge 0, \\forall x \\in \\mathbb{R}^n$ 正定矩阵: $P \\Longleftrightarrow x^tPx &gt; 0, \\forall x \\in \\mathbb{R}^n-\\{0\\}$ 局部极小值充分条件$Df(x’)=0,\\triangledown^2f(x^{*}) &gt; 0$ $\\Longrightarrow$ $x’$是局部极小值 无约束优化问题 例子： $f(x)=\\frac{1}{2}||Ax-b||^2,A$是$m\\times n, rank(A)=m \\le n, b\\in \\mathbb{R}^m$,求局部极小值$x’$ $f(x)$ $ = \\frac{1}{2}(Ax-b)^t(Ax-b)\\\\ = \\frac{1}{2}(x^tA^t-b^t)(Ax-b) \\\\ = \\frac{1}{2}x^t(A^tA)x - (A^tb)^tx+\\frac{1}{2}b^tb$ 令$p = A^tA,q = -A^tb$ 原式=$\\frac{1}{2}x^tpx+q^tx+r$ 那么这是一个关于$x$的二次函数，所以$\\triangledown f(x)=A^tAx-A^tb,\\triangledown^2f(x)=A^tA$ 如果$x’$是局部极小值点，那么$\\triangle f(x) = 0 , \\triangledown^2f(x) \\ge 0$ 即$A^tAx = A^tb,A^tA \\ge 0$ 如果$A^tAx = A^tb,A^tA &gt; 0$那么就能推出$x’$是局部极小 因为$rank(A)$等于$m$,所以$A$是可逆的，那么$x’$就可以用$(A^tA)^{-1}A^tb$求出 例子： $f(x)= \\frac{1}{2}||Ax-b||^2 + \\frac{\\lambda}{2}||x||^2$,求局部最优解$x’$ $x’$ 局部极小值可以推出 $\\triangledown f(x’)=A^tAx’-A^tb+\\lambda x’=0, \\triangledown^2 f(x’)=A^tAI+\\lambda \\ge 0$ $A^tA+\\lambda I\\ge0$永远成立，因为$A^tA+\\lambda I$可以左右加上$x$，可以写成$x^t(A^tA+\\lambda I)x \\Longrightarrow ||Ax||^2 + \\lambda ||x||^2 \\ge 0$ $\\triangledown f(x’)=0, \\triangledown^2f(x’) &gt; 0$可以推出$x’$是局部极小，当$x$不为零时，$\\triangledown^2f(x’)$永远成立 ​ 所以$x’$是局部极小值等价于$\\triangledown f(x’) = 0 \\Longleftrightarrow A^tAx’+\\lambda x’=A^tb$ 因为$A^A+\\lambda I$是正定矩阵，所以是$A^A+\\lambda I$可逆的 $A^tAx’+\\lambda x’=A^tb \\Longleftrightarrow (A^tA+\\lambda I)x’ = A^tb \\Longleftrightarrow x’ = (A^tA+\\lambda I)^{-1}A^tb$ 有约束优化问题线性约束例子： $\\begin{equation} \\left\\{ \\begin{array}{lr} minimize_{x\\in D}\\ f(x) \\\\ sub\\ to\\ Ax = b &amp; A_{p \\times n}, rank(A) = p, b\\in \\mathbb{R}^p \\end{array} \\right. \\end{equation}$ $x$满足线性约束条件，在这个线性约束条件下来找最小值 $x’$满足$Ax’=b$,如果存在$Ax=b$,那么可以推导到$A(x-x’)=0$，此时，$x-x’$是$Ay=0$的解 $\\{x: Ax=b\\}=x’+\\{y: Ay= 0\\}$,所有的$y$构成的集合被称为矩阵$A$的零空间$N(A)$，矩阵的零空间是一个线性空间 $N(A):A$的零空间，是一个线性空间 $dim(N(A)) = n-p$ 假设$\\{\\alpha_1,\\cdots,\\alpha_{n-p} \\}$是$N(A)$的一组基，其中$\\alpha_1,\\cdots,\\alpha_{n-p}$线性无关 那么$N(A)=\\{ u_1\\alpha_1+u_2\\alpha_2+\\cdots+u_{n-p}\\alpha_{n-p}： u_i \\in \\mathbb{R} \\}$，零空间中的所有元素都可以通过基来构造出来 $\\alpha_i$是$n\\times 1$的向量， 因为 $Ax=b$,$b$ 是$p \\times 1$的向量 所以$\\{x:Ax=b \\}=x’+N(A)$ 如果$x$使得$Ax-b=0$，那么可以等价于$x=x’+\\sum\\limits_{i=1}^{n-p}u_i\\alpha_i = x’ + (\\alpha_1,\\cdots,\\alpha_{n-p})\\begin{equation} \\left( \\begin{array}{lr} u_1 \\\\ \\vdots \\\\ u_{n-p} \\end{array} \\right) \\end{equation}$ 将$(\\alpha_1,\\cdots,\\alpha_{n-p})$写成矩阵形式得到一个$n\\times (n-p)$的矩阵$B$ $Ax=b \\Longleftrightarrow x = x’ + By,B:n\\times (n-p), y\\in \\mathbb{R}^{n-p} \\\\ \\{ x\\in \\mathbb{R}^n: Ax=b \\}=\\{ y\\in \\mathbb{R}^{n-p} \\} \\Longleftrightarrow x = x’ + By$ $Ax =b$的解就相当于$x = x’ + By$,在$f(x)$中将$x$替换成$x’+By$，即$\\min\\limits_{y\\in \\mathbb{R}^{n-p}}f(x’+By)$。 有约束问题通过将约束条件的解求出来，写成一个$x’$加零空间的形式将有约束问题转化成无约束的优化问题 将$f(x’)$做二阶的泰勒展开后得到 $f(x’+\\epsilon)=f(x’)+\\triangledown f(x’)^t\\epsilon + \\frac{1}{2}\\epsilon^t\\triangledown^2f(x’)\\epsilon+o(||\\epsilon||^2)$ 将$\\epsilon =By$代入 $f(x’+By)=f(x’)+(B^t\\triangledown f(x))^t y + \\frac{1}{2}y^t(B^t\\triangledown^2f(x’)B)y+o(||y||^2)$ 设$f(x’+By)$ 写成一个关于$y$的函数 $g(y)$ 则：$g(y)=g(0)+(B^t\\triangledown f(x))^t y + \\frac{1}{2}y^t(B^t\\triangledown^2f(x’)B)y+o(||y||^2)$ 那么：$\\triangledown g(0)=B^t \\triangledown f(x’)\\\\ \\triangledown^2g(0)=B^t\\triangledown^2f(x’)B$ $g(y)=f(x’+By)$，如果$x’$是$f$的局部极小，那么等价于$0$是$g$的局部极小，而$g$的一阶微分和二阶微分都已经求出来了，那么其解也就确定了 $\\begin{equation} \\left\\{ \\begin{array}{lr} minimize_{x\\in D}\\ f(x) \\\\ sub\\ to\\ Ax = b \\end{array} \\right. \\end{equation}$ $x’$是局部极小$\\Longrightarrow$ $\\triangledown g(0)=0， \\triangledown^2g(0) \\ge 0$ 如果$B^t \\triangledown f(x’) = 0,B^t\\triangledown^2f(x’)B &gt; 0 \\Longrightarrow x’$是局部极小 拉格朗日乘子法 $N(A)=\\{x:Ax=0\\} $ 零空间 $ R(A)=\\{Ax: x\\in \\mathbb{R}^n\\}$ 矩阵$A$的像空间 $(N(A))^{\\bot}=R(A^t)$ 零空间的正交补时$A^t$的像空间 正交补的定义：$V^{\\bot}=\\{y\\in\\mathbb{R}^n : y^tx = 0, \\forall x \\in V\\}$ 因为$B^t=\\begin{equation} \\left( \\begin{array}{lr} \\alpha^t_1 \\\\ \\vdots \\\\ \\alpha^t_{n-p} \\end{array} \\right) \\end{equation}$ 所以$B^t\\triangledown f(x’)=0$ $\\Longleftrightarrow \\alpha_i^t\\triangledown f(x’)=0,\\forall i\\in \\{1,\\cdots,n-p\\}\\\\ \\Longleftrightarrow \\triangledown f(x’) \\in N(A)^{\\bot} \\\\ \\Longleftrightarrow \\triangledown f(x’) \\in R(A^t) , R(A^t)=\\{A^ty: y\\in \\mathbb{R}^p \\} \\\\ \\Longleftrightarrow \\exists \\mu \\in \\mathbb{R}^p st.\\ \\triangledown f(x’)+A^t\\mu=0 $ 关于$B^t\\triangledown f(x’)=0$ 经过一些看不懂的变换可以等价于$\\exists \\mu \\in \\mathbb{R}^p$,使得$\\triangledown f(x’)+A^t\\mu=0$ 而在拉格朗日乘子法中针对一开始的优化问题，可以写成$L(x,\\mu) = f(x)+\\mu^t(Ax-b)$ 而$L(x,\\mu)$对$x$求导就可得 $\\triangledown f(x’) + A^t\\mu$ 拉格朗日乘子对于$\\begin{equation} \\left\\{ \\begin{array}{lr} minimize_{x\\in D}\\ f(x) \\\\ sub\\ to\\ Ax = b \\end{array} \\right. \\end{equation}$ $x’$局部极小$\\Longrightarrow\\partial_x L(x’,\\mu)=0$，其中$L(x,\\mu)=f(x)+\\mu^t(Ax-b)$ 例子 $\\begin{equation} \\left\\{ \\begin{array}{lr} minimize\\ \\sum\\limits_{i=1}^nx_i\\log x_i \\\\ sub\\ to\\ \\sum\\limits_{i=1}^nx_i=1 \\end{array} \\right. \\end{equation}$ $L(x,\\mu)=\\sum\\limits_{i=1}^nx_i\\log x_i + \\mu(\\sum\\limits_{i=1}^nx_i-1)$ $x$局部最小$\\Longrightarrow \\partial_xL=0,\\Longrightarrow \\forall i,\\partial_{xi}L=0 \\\\ \\Longrightarrow 1+ \\log x_i + \\mu = 0, \\forall i\\\\ \\Longrightarrow \\log x_i = -(1+\\mu) \\Longrightarrow x_i = e^{-(1+\\mu)}, \\forall i \\\\ \\Longrightarrow x_1 = x_2=…=x_n=\\frac{1}{n}$ 考虑$B^t\\triangledown^2f(x)B$,其中$\\partial_{x,i}f = 1+\\log x_i$，那么$\\triangledown ^2f(x)=\\begin{equation} \\left( \\begin{array}{lr} \\frac{1}{x_1} &amp;&amp; &amp;&amp; \\\\ &amp;&amp; \\frac{1}{x_2} \\\\ &amp;&amp; &amp;&amp; \\ddots &amp;&amp; \\\\ &amp;&amp; &amp;&amp; &amp;&amp; \\frac{1}{x_n} \\end{array} \\right) \\end{equation} &gt; 0$ $\\triangledown ^2f(x)$是正定矩阵，而$B$又是满秩的所以$B^t\\triangledown^2f(x)B$是正定矩阵 所以$x=(\\frac{1}{n},\\cdots,\\frac{1}{n})^t$是局部极小 非线性约束$\\begin{equation} \\left\\{ \\begin{array}{lr} minimize\\ f(x) \\\\ sub\\ to\\ h_i(x)=0 \\end{array} \\right. \\end{equation}$ 解局部参数化$g:(-1,1)\\to \\mathbb{R}^n,g(0)=x^{*}$ $R(g)\\subset D$，$D$是$f(x)$的定义域 同时符合$h_i(g)=0$ $x’$是局部极小$\\Longrightarrow 0$是$f \\circ g$的局部极小 $\\Longrightarrow (f \\circ g)’(0)= 0, f(f \\circ g)’’(0)\\ge 0$ $h_i \\circ g=0 \\Longrightarrow (h_i \\circ g)’(0) = 0, (h_i \\circ g)’’(0) = 0$ 根据上面的4个导数和$g$的任意性可以得到解$x’$的必要条件","categories":[{"name":"智能计算数学基础","slug":"智能计算数学基础","permalink":"http://orzff.cn/categories/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数学基础","slug":"数学基础","permalink":"http://orzff.cn/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"微分","slug":"微分","permalink":"http://orzff.cn/tags/%E5%BE%AE%E5%88%86/"}]},{"title":"吴恩达机器学习5","slug":"吴恩达机器学习5","date":"2021-07-03T06:32:32.000Z","updated":"2021-09-07T01:39:01.327Z","comments":true,"path":"/7e4dc831/","link":"","permalink":"http://orzff.cn/7e4dc831/","excerpt":"吴恩达机器学习笔记(五)","text":"代价函数神经网络 使用$L$来代表神经网络的层数 使用$s_l$来代表第$l$层的神经元数目 代价函数 相对于单个的逻辑回归的代价函数，整个神经网络的代价函数只对输出层进行计算，计算第$i$的输出与训练集的结果$y_i$之间的差距。因为神经网络的数据不是唯一，可能由多个分类的输出，所以$K$代表输出的分类个数。计算正则化也是如何，跟逻辑回归类似，不计算0下表的$\\Theta$ 反向传播算法向前传播方法向前传播方法是前面用到的方法 从输入开始，对每一层进行计算得到下一层的结果，以此往复得到最终结果 反向传播方法方向传播方法从直观上说就是对每一个节点计算$\\delta_j^{(l)}$代表第$l$层，第$j$个节点的误差 还是使用4层的神经网络来说 $\\delta_j^{(4)}=a_j^{(4)}-y_j$ 第四层就是输出值和$y$值的误差，然后我们反向传播到第三层 $\\delta^{(3)}=(\\Theta^{(3)})^T\\delta^{(4)} * g’(z^{(3)})$ $\\delta^{(3)}$由参数$\\Theta^{(3)}$转置叉乘$\\delta^{(4)}$然后点乘(这里点乘只是各个数字相乘) $g(z^{(3)})$的导数， 对$g$函数求导，先设 $a = g(z) = \\frac{1}{1+e^{-z}} $ $g’(z) \\\\ = (\\frac{1}{1+e^{-z}})’ \\\\ = \\frac{1’(\\frac{1}{1+e^{-z}})+1(\\frac{1}{1+e^{-z}})’}{(1+e^{-z})^2} \\\\ = \\frac{e^{-z}}{(1+e^{-z})^2} \\\\ = \\frac{e^{-z}+1-1}{(1+e^{-z})^2} \\\\ = \\frac{(e^{-z}+1) -1}{(1+e^{-z})^2} \\\\ = \\frac{1}{(1+e^{-z})}-\\frac{1}{(1+e^{-z})^2} \\\\ = a - a^2 \\\\ = a(1-a)$ 那么现在$g’(z^{(3)})$就为$a^{(3)}*(1-a^{(3)})$ 同样的$\\delta^{(2)}$也是如此 $\\delta^{(2)}=(\\Theta^{(2)})^T\\delta^{(3)} * g’(z^{(2)})$ 在不严谨的情况下，我们可以得到初略的偏导数$\\frac{\\partial}{\\partial \\Theta_{ij}^{(l)}}J(\\Theta)=a_j^{(l)}\\delta_i^{l+1}$ 这些都是忽略的正则化的情况下 反向传播算法 一开始我们将所有的$\\Delta$设置为0，$\\Delta$是$\\delta$的大写形式 然后我们每一层计算$a^{l}$,计算到输出层以后倒回来计算$\\delta$,一直计算到$\\delta^2$ 然后计算$\\Delta$,$\\Delta$的计算公式:$\\Delta_{ij}^{(l)}:=\\Delta_{ij}^{(l)}+a_j^{(l)}\\delta_i^{(l+1)}$ 向量式写法可以写成$\\Delta^{(l)}:=\\Delta^{(l)}+\\delta^{(l+1)}(a^{(l)})^T$ 最终计算$D$,$ \\begin{array}{lr} D_{ij}^{(l)}:=\\frac{1}{m}\\Delta_{ij}^{(l)}+\\lambda\\Theta_{ij}^{(l)} &amp; if\\ j \\not=0 \\\\ D_{ij}^(l) := \\frac{1}{m}\\Delta_{ij}^{(l)} &amp; if\\ j = 0 \\end{array} $ 这里加上了正则化 最终的偏导正好等于$\\frac{\\partial}{\\partial \\Theta_{ij}^{(l)}}J(\\Theta)=D_{ij}^{(l)}$ 理解反向传播算法以单一的输出并且忽略$\\lambda$为例，代价函数可以写成$cost(i)=y^{(i)}\\log h_{\\Theta}(x^{(i)})+(1-y^{(i)})\\log h_{\\Theta}(x^{(i)})$ 最终的代价值是由每个节点的误差累计而成，所以对于最终的带价值，每一个$\\delta_j^{(l)}$都相当于这个代价的偏导，由这些误差联合作用得到最终的误差值，而每一个$\\delta_{i}^{(l)}$都可以从后面的$\\delta$推导出来，比如$\\delta_2^{2}=\\Theta_{12}^{(2)}\\delta_{1}^{(3)}+\\Theta_{22}^{(2)}\\delta^{(3)}_2$ 这样就可以得出$\\delta$的推导公式$\\delta^{(l)}=(\\Theta^{(l)})^T\\delta^{(l+1)}$，至于那么求导暂时没搞懂 展开参数假设一个神经网络第一层有10个节点，第二层有10个节点，第三层有1个节点 $s_1=10,s_2=10,s_3=1$ 那么对应的参数就为 $\\Theta^{(1)}\\in\\mathbb{R}^{10\\times11},\\Theta^{(2)}\\in\\mathbb{R}^{(10\\times11)},\\Theta^{(3)}\\in\\mathbb{R}^{(1\\times11)}$ $D^{(1)}\\in\\mathbb{R}^{10\\times11},D^{(2)}\\in\\mathbb{R}^{(10\\times11)},D^{(3)}\\in\\mathbb{R}^{(1\\times11)}$ $\\Theta,D$都是矩阵，但是对于高级优化函数 $function\\ [jVal,\\ gradient] = costFunction(theta)\\\\ … \\\\ optTheta=fminunc(@costFunction, initialTheta, options)$ $theta, initialTheta, gradient$都是向量 所以这里就有一个向量展开的问题，通过操作将各个参数合并成一个向量 $thetaVec = [Theta1(:); Theta2(:);Theta3(:)];\\\\DVec=[D1(:);D2(:);D3(:)];$ 在使用时再通过操作将向量转化成矩阵 $Theta1=reshape(thetaVec(1:110), 10,11);\\\\Theta2=reshape(thetaVec(111:220), 10,11);\\\\Theta1=reshape(thetaVec(221:231), 1,11);$ 在使用高级优化函数时，也传入合并的向量 $fminunc(@costFunction,initialTheta,options)$ 代价函数也有所改变 $function\\ [jval,gradientVec]=costFunction(thetaVec)$ 从$thetaVec$中获得$\\Theta^{(1)},\\Theta^{(2)},\\Theta^{(3)}$， 通过反向传播算出$D^{(1)},D^{(2)},D^{(3)}$和$J(\\Theta)$,再将矩阵转化成向量得到$gradientVec$ 梯度检测有时反向传播会出现一些我们发现不了的bug，而为了检测出这个bug，可以使用梯度检测的方法 再常数的情况下，取一个很小的$\\epsilon$，这样$\\frac{d}{d\\theta}J(\\theta)\\approx\\frac{J(\\theta+\\epsilon)-J(\\theta-\\epsilon)}{2\\epsilon}$ 在向量的情况下，每个偏导都计算一次，跟反向传播所计算出来的导数相比，就可以得出反向传播的正确率了 $for i = 1:n,$ ​ $thetaPlus = theta;$ ​ $thetaPlus(i) = thetaPlus(i) + EPSILON;$ ​ $thetaMinus = theta;$ ​ $thetaMinus(i) = thetaMinus(i) - EPSILON;$ ​ $gradApprox(i) = (J(thetaPlus)-J(thetaMinus)) / (2*EPSILON)$ $end;$ 检查是否$gradApprox\\approx DVec$ 如果跟$DVec$相差不是很大，那么就可以证明反向传播是正确的。 注意梯度检测只适用于检测阶段，是检测手段，不能再正式运行梯度下降时使用梯度检测，这会大大拖慢梯度下降的效率 随机初始化在梯度下降算法中，需要初始化初始的参数，那么如何初始化呢。 对称权重 逻辑回归的初始化是将所有的参数设置成0，这样会造成一个问题，就是对称权重，每个输入值的权重相同，那么就导致隐藏层的值也相同，反馈到输出结果是造成每个隐藏层的$\\delta$也相同，这也就意味着偏导数相同，对于隐藏层的一个节点，它的输入的边偏导相同时，无论经过多少次迭代，边始终都相同。$a^{(2)}_1,a^{(2)}_2$以相同的参数进行计算，它们始终相同。 所有的隐藏节点都在计算相同的特征，所有的隐藏单元都在以相同的函数作为输入，这是一种高度冗余的现象，因此这也意味着最终的输出单元，只能得到一种特征，因为所有的单元都一样。 随机初始化随机初始化是解决对称权重的初始化方法。 随机初始化所有的$\\Theta_{ij}^{(l)}$在$[-\\epsilon,\\epsilon]$之间 $Theta = ranf(10,11) \\times (2 \\times INIT_EPSILON) - INIT_EPSILON$ 组合选择神经网络结构 根据特征的维度确定输入单元个数 根据分类的需求确定输出单元个数 一般情况下隐藏层个数1个或者多个，每一层隐藏层单元数量个数相等，可以是输入单元的倍数 一般情况下，隐藏层个数越多越好，但是越多计算量越大 训练神经网络 构建神经网络，随机初始化权重 执行向前传播算法，根据输入的$x^{(i)}$计算输出值$h_{\\Theta}(x^{(i)})$ 通过代码计算代价函数$J(\\theta)$ 执行反向传播算法算出偏导数项$\\frac{\\partial}{\\partial \\Theta_{jk}^{(l)}}J(\\Theta)$ 使用梯度检测来检测已经计算出来的偏导数项，通过梯度检测方法可以保证我们反向传播得到的结果是正确的，然后停止梯度检测，因为梯度检测非常的慢 使用高级优化算法与反向传播算法结合","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"机器学习/学习笔记","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://orzff.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"吴恩达机器学习4","slug":"吴恩达机器学习4","date":"2021-06-28T13:28:27.000Z","updated":"2021-07-04T11:44:11.247Z","comments":true,"path":"/94af8a7/","link":"","permalink":"http://orzff.cn/94af8a7/","excerpt":"吴恩达机器学习笔记(四)","text":"神经网络对于复杂的问题，由于特征值的数量增多，对于拟合出来的多项式复杂度可能会急剧膨胀，这样一来单独使用线性回归或逻辑回归可能就不太能满足需求了 神经元神经元是神经网络里的一个运算单元，可以是线性回归，可以实逻辑回归或是其他算法，图中简单的表示对$h$函数做运算，$h_{\\theta}(x)=\\frac{1}{1+e^{-\\theta^TX}}$ ，有输入$x_1,x_2,x_3$，有$x_0$没有绘出但是$x_0$存在且始终等于0，$x_0$称为偏移单元或偏移神经元。 有时我们会说这是一个带有$Sigmoid$或者是$Logistic$激活函数的人工神经元，在神经网络的术语中，激活单元是指代非线性函数$g(z)=\\frac{1}{1+e^{-z}}$的另一个术语 $\\theta$在之前的描述种被称为模型的参数，在神经网络种有人会称它为模型的权重 神经网络神经网络其实就是一组神经元链接在一起的集合，图中的神经网络输入$x_1,x_2,x_3$，当然有一个隐藏的$x_0$,$a_1^{(2)},a_2^{(2)},a_3^{(2)}$是3个神经元，并且有一个隐藏的神经元$a_0^{(2)}$，最后一层有一个输出节点假设函数$h_{\\Theta}(x)$。 在神经网络的术语中第一层叫做输入层，最后一层叫做输出层，中间的叫做隐藏层 计算步骤$a_i^{(j)}$代表第$j$层第$i$个神经元或单元 $\\Theta^{(j)}$ 权重参数，控制从某一层到下一层的映射 从第一层的4个参数到第二层的3个神经元，通过$\\Theta$来转换，$\\Theta$的维度可以表示为$s_{j+1}\\times (s_j+1)$ 每一层的转换都是通过$\\Theta$来实现， 向量化表示仔细观察$x$向$z$转换的过程，我们将$x$组成一个向量，$z^{(2)}$来表示运算时$g$的参数,$z^{(2)}$的大小时$3\\times 1$ $z^{(2)}$由$\\Theta^{(1)}$与$a^{(1)}$矩阵相乘而来，$a^{(1)}$时输入的参数，加上隐藏的$x_0$的话，$a^{(1)}$的规格时$4\\times 1$，以此类推， 计算$z^{(3)}$时，通过$\\Theta^{(2)}$与$a^{(2)}$相乘就可以得到，而结果$h_{\\Theta}(x)$就是$z^{(3)}$ 神经网络与常规的逻辑回归相比特殊之处在于，不直接使用输入的参数来计算结果，而是通过$\\Theta$来计算中间隐藏层，通过隐藏层来计算最终结果 神经元计算样例通过神经网络的一层层传递，我们可以在一些简单的计算的基础上再进行一些复杂计算，从而得到很好的计算结果 与运算 如图所示，我们设计设计一个神经元，将参数设置成$(-30,10,10)$，利用$g$函数可以达到与运算的效果 或运算 跟与运算相似，将参数设置成$(-10, 20, 20)$就可以达到或运算的效果 非运算 非运算，在需要运算的值前面加上一个很大的参数，就可以实现非运算了 异或运算.32ylofm62j40.png) 异或运算在中间的隐藏层实现与预算和非与运算来通过或运算得到异或运算，通过真值表可以看到正确性 多元分类多元分类是在单元分类的基础上输出多个结果代表多个种类 再多元分类中$y^{(i)}$不在代表一个值，而是一个向量，其中1的位置代表$y^{(i)}$的类型，我们要做的就是通过训练找到合适的$\\Theta$，使得$h_{\\Theta}(x^{(i)})\\approx y^{(i)}$","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"机器学习/学习笔记","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://orzff.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"吴恩达机器学习3","slug":"吴恩达机器学习3","date":"2021-06-25T13:37:42.000Z","updated":"2021-07-04T11:49:59.250Z","comments":true,"path":"/972e6d04/","link":"","permalink":"http://orzff.cn/972e6d04/","excerpt":"吴恩达机器学习笔记(三)","text":"逻辑回归二元分类二元分类中$y$值只能取两个值，0或1 $y=\\{ 0, 1\\}$ 一般的话，0代表没有，1代表有 逻辑回归逻辑回归实际是一种分类算法，逻辑回归的输出值在0到1之间 $0\\le h_{\\theta}(x)\\le1$ 线性回归的一般公式是：$h_{\\theta}(x)=\\theta^Tx$,得到的是一个数值 而逻辑回归的公式则为：$h_{\\theta}(x)=g(\\theta^Tx)\\\\g(z)=\\frac{1}{1+e^{-z}}$ $g$函数一般被称为 $sigmoid\\ $函数或 $logistic\\ $函数 逻辑函数$h$的曲线在0到1之间，也可以说逻辑曲线的值参数$x$为1的可能性 $h_{\\theta}(x)=p(y=1|x;\\theta)$ 在给定参数下，$h$函数判断同一数据为0的概率和为1的概率应该和是1 $P(y=0|x;\\theta)+P(y=1|x;\\theta)=1$ 决策界限根据上图所示，当$g$的参数$\\ge0$时，$g$函数的值大于$0.5$，相应的当$g$的参数$\\lt0$时，$g$函数的值小于$0.5$,而$g$函数的参数又是$\\theta^TX$，所以我们可以得到结论当$\\theta^TX\\ge0$时，$h_{\\theta}(x)\\ge0.5$，当$\\theta^TX&lt;0$时，$h_{\\theta}(x)&gt;0.5$ 图上两种分类中间的直线就是决策界限 代价函数原先的代价函数可以写成 $J(\\theta)=Cost(h_{\\theta}(x^{(i)}),y^{(i)})=\\frac{1}{2}(h_{\\theta}(x^{(i)})-y^{(i)})^2$ 因为$h$函数是一个复杂的函数$h_{\\theta}(x)=\\frac{1}{1+e^{-\\theta^Tx}}$，导致代价函数$J$是一个非凹函数，这样在梯度下降的过程中不一定会找到全局最小值 很显然这个代价函数并不适合逻辑回归，这里将介绍一个新的代价函数 $Cost(h_{\\theta}(x),y) = \\left\\{ \\begin{array}{lr} -\\log(h_{\\theta}(x)) &amp; if\\ y = 1 \\\\ -\\log(1-h_{\\theta}(x)) &amp; if\\ y = 0 \\end{array} \\right. $ 当$y=1,h_{\\theta}(x) =1$时$Cost$为0，如果$h_{\\theta}(x)\\to0$ ，那么$Cost\\to \\infty$ 当$y=0,h_{\\theta}(x)=0$时$Cost$为1，如果$h_{\\theta}(x)\\to1$，那么$Cost\\to \\infty$ 简化代价函数$J(\\theta)=\\frac{1}{m}\\sum\\limits_{i=1}^mCost(h_{\\theta}(x^{(i)}), y^{(i)})$ $Cost(h_{\\theta}(x),y) = \\left\\{ \\begin{array}{lr} -\\log(h_{\\theta}(x)) &amp; if\\ y = 1 \\\\ -\\log(1-h_{\\theta}(x)) &amp; if\\ y = 0 \\end{array} \\right. $ 因为代价函数中包括了两种不同的状态，不利于梯度下降函数的运行，所以我们要简化代价函数 $Cost(h_{\\theta}(x),y) = -y \\log(h_{\\theta}(x)) - (1-y)\\log(1-h_{\\theta}(x))$ 关于为什么要选择这个代价函数，我偶然看见一个UP做过一个视频，视频在这我简单说一下我的理解 因为神经网络的每次迭代都是通过改变$W,b$的值来实现，那么对于每一次训练我们来比较差错的话，就是在 当前$W,b$的情况下，去得到得出原本正确的$x_1,x_2,x_3…$的概率$P(x_1,x_2,…,x_n|W,b)$ 因为神经网络得到的$y_i$跟$W,b$存在线性关系，所以还可以写成$\\prod\\limits_{i=1}^nP(x_i|y_i)$ 神经网络算出的$y_i$的值只有01两种情况，所以这个式子还符合伯努利分布 : $x_i\\in{0,1}$ $f(x)=p^x(1-p)^{1-x}= \\left\\{ \\begin{array}{lr} p, &amp; x=1 \\\\ 1-p, &amp; x=0 \\end{array} \\right. \\ $ 在伯努利分布中$p$代表为1的概率，而神经网络中的$y_i$也是为真的概率,那么方程就可以写成 $\\prod\\limits_{i=1}^ny_i^{x_i}(1-y_i)^{1-x_i}$，加上$log$变成加法 $\\log(\\prod\\limits_{i=1}^ny_i^{x_i}(1-y_i)^{1-x_i}) \\\\ = \\sum\\limits_{i=1}^n \\log(y_i^{x_i}(1-y_i)^{1-x_i}) \\\\ = \\sum\\limits_{i=1}^n (x_i \\log y_i + (1-x_i) \\log(1-y_i)) $ 那么这里就是在当前迭代的情况下，最符合训练集的概率，这个公式是寻找最大值，所以加上负号变成 寻找最小值，以符合梯度下降，这就是逻辑回归的梯度下降 $Cost(h_{\\theta}(x),y) = -y \\log(h_{\\theta}(x)) - (1-y)\\log(1-h_{\\theta}(x))$ 这样我们就将两个式子简化成一行，新的代价函数为： $J(\\theta)=\\frac{1}{m}\\sum\\limits_{i=1}^mCost(h_{\\theta}(x^{(i)}), y^{(i)}) \\\\ = -\\frac{1}{m}\\sum\\limits_{i=1}^m[y^{(i)}\\log(h_{\\theta}(x^{(i)}))+(1-y^{(i)})\\log(1-h_{\\theta}(x^{(i)}))] $ 我们利用梯度下降去寻找最小的$\\min\\limits_{\\theta}J(\\theta)$,去预测一个新的参数$x$为1的概率 梯度下降逻辑回归的的梯度下降公式跟线性回归的几乎一样 $Repeat \\{ \\\\ \\theta_j:=\\theta_j-\\frac{\\alpha}{m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})x^{(i)}_j \\\\ \\}$ 向量式写法： $\\theta := \\theta - \\frac{\\alpha}{m}X^T(g(X\\theta)-y)$ 高级优化Octave中有许多由于梯度下降的算法，但是你并不需要全部掌握，你可以使用Octave提供的库 比如说fminunc你只需要提供所计算的代价函数，每个$\\theta$的导数，初始$\\theta$即可以使用 比如对于图上的代价函数$J$，你需要提供一个代价函数costFunction，返回[代价值jVal，每个参数的导数gradient] 设置高级优化函数的参数options,提供初始化的参数initialTheta，函数经过计算会返回[最佳的参数optTheta, 代价函数的值functionVal，是否收敛exitFlag] 多类别分类有时候需要你区分的类别可能不止2中，可能有3种，4种或更多 比如，病人带着鼻塞来到诊所，你需要区分是没生病，还是着凉还是流感，这里$y=0$代表没生病，$y=1$代表着凉, $y=2$代表流感 对于这种情况，我们可以将3种类型看成2种，进行3次的逻辑回归 我们每次只看1类，$h_{\\theta}^{(i)}(x) = P(y=1|x;\\theta)$为为这种情况为1的概率 当我们接收一个新的$x$时，我们对于每个逻辑回归最判断，得出最有可能的概率$\\max\\limits_{i}h_{\\theta}^{(i)}(x)$ 过拟合问题在拟合数据时，为了更好的拟合数据集，我们可能会选择一个很复杂的函数，它对于数据集有很好的效果，但是对于验证集的效果却很差 怎么解决减少特征的数量 尽量减少特征的数量 通过模型选择算法 正则化 保持所有的特征，但是减少$\\theta$的量级或是大小 当你面对大量的特征时，使用正则化 正则化和代价函数正则化思想： 每个参数都很小 对于很小的参数，我们可以得到更简单的假设模型 更不容易出现过拟合的情况 但是我们要怎么决定哪些参数应该去缩小呢，这就要去修改我们的代价函数 这是线性回归的代价函数$J(\\theta)=\\frac{1}{2m}(h_{\\theta}(x^{(i)})-y^{(i)})^2$ 我们在后面加入一个新的项用来减小每个$\\theta$,$J(\\theta)=\\frac{1}{2m}[(h_{\\theta}(x^{(i)})-y^{(i)})^2 + \\lambda\\sum\\limits_{i=1}^n\\theta_{j}^2]$ $\\lambda$：正则化参数，控制两个不同目标的取舍，第一个目标就是我们的代价函数，我们想让代价函数尽可能的小，同时第二个目标是$\\theta$的和，我们也想让参数的和尽可能的小 正则化线性回归代价函数发生了改变，那么相对于的，线性回归的梯度下降公式也会发生改变 $Repeat\\ \\{ \\\\ \\theta_{0} := \\theta_{0} - \\alpha \\frac{1}{m}\\sum\\limits_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})x_{0}^{(i)} \\\\ \\theta_{j} := \\theta_{j} - \\alpha [(\\frac{1}{m}\\sum\\limits_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})x_{j}^{(i)}) + \\frac{\\lambda}{m}\\theta_j] \\\\ \\}$ 因为正则化并没有加入$\\theta_0$,所以$\\theta_0$需要特殊处理 观察$\\theta_j$，我们能可以做一个简单的合并$\\theta_j := \\theta_j(1-\\alpha\\frac{\\lambda}{m})-\\lambda\\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})x_{j}^{(i)}$ 正则化正规方程$X = \\begin{bmatrix} (x^{(1)})^T \\\\ \\dots \\\\ (x^{(m)})^T \\end{bmatrix}$ $y=\\begin{bmatrix} y^{(1)} \\\\ \\dots \\\\ y^{(m)} \\end{bmatrix}$ 正规方程的公式修改后成为： $\\theta = (X^TX + \\lambda \\begin{bmatrix} 0 &amp; &amp; &amp; \\\\ &amp; 1 &amp; &amp; \\\\ &amp; &amp; \\ddots \\\\ &amp; &amp; &amp; 1 \\end{bmatrix}_{(n\\times1)\\times(n\\times1)})^{-1}X^Ty$ 正则化逻辑回归逻辑回归的代价函数 $J(\\theta)=-[\\frac{1}{m}\\sum\\limits_{i=1}^{m}y^{(i)}\\log h_{\\theta}(x^{(i)})+(1-y^{(i)})\\log (1-h_{\\theta}(x^{(i)}))]+\\frac{\\lambda}{2m}\\sum\\limits_{j=1}^n\\theta_j^2$ 逻辑回归的梯度下降 $Repeat\\ \\{ \\\\ \\theta_{0} := \\theta_{0} - \\alpha \\frac{1}{m}\\sum\\limits_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})x_{0}^{(i)} \\\\ \\theta_{j} := \\theta_{j} - \\alpha [(\\frac{1}{m}\\sum\\limits_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})x_{j}^{(i)}) + \\frac{\\lambda}{m}\\theta_j] \\\\ \\}$ 逻辑回归的梯度下降的转换跟线性回归的类似，但是因为$h$函数的不同，它们实际上还是不同的函数 正则化高级优化函数","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"机器学习/学习笔记","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://orzff.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"吴恩达机器学习作业","slug":"吴恩达机器学习作业","date":"2021-06-25T12:05:15.000Z","updated":"2021-07-04T11:44:11.268Z","comments":true,"path":"/74ea918c/","link":"","permalink":"http://orzff.cn/74ea918c/","excerpt":"吴恩达机器学习作业","text":"第一周基础$Warm\\ Up\\ Exercise$— $warmUpExercise.m$ function A = warmUpExercise() % ============= YOUR CODE HERE ============== A = eye(5); % =========================================== end $Plot\\ Data$— $plotData.m$ function plotData(x, y) % ====================== YOUR CODE HERE ====================== figure(1); plot(X, y, 'r'); xlabel(\"x\"); ylabel(\"y\"); % =========================================================== end $Compute\\ Cost$且代价函数直接套公式 $J(\\theta)=\\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$ — $computeCost.m$ function J = computeCost(X, y, theta) m = length(y); % number of training examples % You need to return the following variables correctly J = 0; % ====================== YOUR CODE HERE ====================== J = X * theta - y; J = 1/(2*m) * sum(J .^ 2); % ========================================================================= end $Gradient\\ Descent$直接套公式即可 $Repeat \\{ \\\\ \\theta_j:=\\theta_j-\\alpha\\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})x^{(i)}_j \\\\ \\}$ — $gradientDescent.m$ function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters) m = length(y); % number of training examples J_history = zeros(num_iters, 1); for iter = 1:num_iters % ====================== YOUR CODE HERE ====================== theta = theta - alpha/m * X' * (X*theta - y); % ============================================================ % Save the cost J in every iteration J_history(iter) = computeCost(X, y, theta); end end 附加$Feature\\ Normalize$特征放缩，每个特征减去平均值并除以方差 — $featureNormalize.m$ function [X_norm, mu, sigma] = featureNormalize(X) X_norm = X; mu = zeros(1, size(X, 2)); sigma = zeros(1, size(X, 2)); % ====================== YOUR CODE HERE ====================== mu = mean(X); sigma = std(X); for i = 1:size(X, 1) for j = 1:size(mu, 2) X_norm(i,j) = (X_norm(i,j) - mu(1,j)) / sigma(1, j); endfor end % ============================================================ end $Compute\\ CostMulti$套公式 — $computeCostMulti.m$ function J = computeCostMulti(X, y, theta) m = length(y); % number of training examples J = 0; % ====================== YOUR CODE HERE ====================== % You should set J to the cost. J = 1 / (2 * m) * sum(((X * theta) - y) .^ 2); % ========================================================================= end $Gradient\\ DescentMulti$跟单个特征的算法类似，直接套公式即可 — $gradientDescentMulti.m$ function [theta, J_history] = gradientDescentMulti(X, y, theta, alpha, num_iters) m = length(y); % number of training examples J_history = zeros(num_iters, 1); for iter = 1:num_iters % ====================== YOUR CODE HERE ====================== theta = theta - alpha / m * (X' * (X * theta - y)); % ============================================================ % Save the cost J in every iteration J_history(iter) = computeCostMulti(X, y, theta); end end $Normal\\ Equations$直接套公式即可 $\\theta=(X^TX)^{-1}X^Ty$ — $normalEqn.m$ function [theta] = normalEqn(X, y) theta = zeros(size(X, 2), 1); % ====================== YOUR CODE HERE ====================== theta = pinv((X'*X))*X'*y % ============================================================ end 第二周基础$Sigmoid\\ function$$sigmoid$函数是$\\frac{1}{1+e^{-x}}$ 根据传进来的数据输出$sigmoid$ — $sigmoid.m$ function g = sigmoid(z) %SIGMOID Compute sigmoid function g = zeros(size(z)); % ====================== YOUR CODE HERE ====================== [m, n] = size(z); for i = 1:m for j = 1:n g(i,j) = 1 / (1 + e ^ (-z(i, j))); endfor endfor % ============================================================= end $Cost\\ function\\ and\\ gradient$使用逻辑回归的代价函数公式 $J(\\theta)=-\\frac{1}{m}\\sum\\limits_{i=1}^m[y^{(i)}\\log(h_{\\theta}(x^{(i)}))+(1-y^{(i)})\\log(1-h_{\\theta}(x^{(i)}))]$ 直接求代价函数 关于代价函数的导数以后再证 $\\frac{\\partial J(\\theta)}{\\partial \\theta_j}=\\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})x^{(i)}_j$ — $costFunction.m$ function [J, grad] = costFunction(theta, X, y) %COSTFUNCTION Compute cost and gradient for logistic regression m = length(y); J = 0; grad = zeros(size(theta)); % ====================== YOUR CODE HERE ====================== h = sigmoid(X * theta); J = -1 / m * (y' * log(h) + (1-y') * log(1-h)); grad = 1 / m * (X' * (h - y)); % ============================================================= end $predict$— $predict.m$ function p = predict(theta, X) %PREDICT Predict whether the label is 0 or 1 using learned logistic m = size(X, 1); % Number of training examples p = zeros(m, 1); % ====================== YOUR CODE HERE ====================== p = sigmoid(X * theta); for i = 1:m if p(i) &gt;= 0.5 p(i) = 1; else p(i) = 0; endif end % ========================================================================= end 附加$Cost\\ function\\ and\\ gradient$代价函数：$J(\\theta)=-\\frac{1}{m}\\sum\\limits_{i=1}^m[y^{(i)}\\log(h_{\\theta}(x^{(i)}))+(1-y^{(i)})\\log(1-h_{\\theta}(x^{(i)}))]+\\frac{\\lambda}{2m}\\sum\\limits_{i=1}^n\\theta_j^2$ 导数： $\\frac{\\partial J(\\theta)}{\\partial \\theta_j}=\\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})x^{(i)}_j \\ for\\ j = 0$ $\\frac{\\partial J(\\theta)}{\\partial \\theta_j}=(\\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})x^{(i)}_j)+\\frac{\\lambda}{m}\\theta_j \\ for\\ j \\ge 1$ — $costFuntionReg.m$ function [J, grad] = costFunctionReg(theta, X, y, lambda) %COSTFUNCTIONREG Compute cost and gradient for logistic regression with regularization m = length(y); % number of training examples J = 0; grad = zeros(size(theta)); % ====================== YOUR CODE HERE ====================== J = costFunction(theta, X, y) + lambda / (2 * m) * (sum(theta .^ 2) - theta(1) .^ 2); h = sigmoid(X * theta); grad = 1 / m * X' * (h - y) + lambda / m * theta; grad(1) = 1 / m * (X' * (h - y))(1); % ============================================================= end 第三周$Vectorize\\ Logistic\\ Regression$跟过拟合的代价函数类似，可以直接套 — $lrCostFunction.m$ function [J, grad] = lrCostFunction(theta, X, y, lambda) %LRCOSTFUNCTION Compute cost and gradient for logistic m = length(y); J = 0; grad = zeros(size(theta)); % ====================== YOUR CODE HERE ====================== h = sigmoid(X * theta); J = -1 / m * (y' * log(h) + (1-y')*(log(1-h))) + lambda / (2 * m) * (sum(theta .^ 2) - theta(1) .^ 2); grad = 1 / m * X' * (h - y) + lambda / m * theta; grad(1) = 1 / m * (X' * (h - y))(1); % ============================================================= grad = grad(:); end $One-vs-All\\ Training$利用$fmincg$来计算$all_theta$ ,$fmincg$计算训练集对每个数字算出的参数，把参数加入$all_theta$ 即可 — $oneVsAll.m$ function [all_theta] = oneVsAll(X, y, num_labels, lambda) m = size(X, 1); n = size(X, 2); all_theta = zeros(num_labels, n + 1); X = [ones(m, 1) X]; % ====================== YOUR CODE HERE ====================== initial_theta = zeros(n + 1, 1); options = optimset('GradObj', 'on', 'MaxIter', 50); for i = 1:num_labels all_theta(i,:) = fmincg(@(t)(lrCostFunction(t, X, (y==i), lambda)), initial_theta, options); endfor % ======================================================================== end $Predict\\ for\\ One-Vs-All$用$X\\times \\theta^T$来计算每个样例对每个数字的几率 $[m\\times(n+1)]\\times[10\\times(n+1)]^T$ 利用max来得到最大几率的索引 — $predictOneVsAll.m$ function p = predictOneVsAll(all_theta, X) m = size(X, 1); num_labels = size(all_theta, 1); p = zeros(size(X, 1), 1); X = [ones(m, 1) X]; % ====================== YOUR CODE HERE ====================== all_p = sigmoid(X * all_theta'); [A, p] = max(all_p, [], 2); % ========================================================================= end $Implement\\ Predict$题目给出了$4000\\to 25\\to10$的神经网络，输入层400个参数，隐藏层25个，输出层10个，代表这个样例是某个数字的可能性 题目给出了参数$\\Theta_1$和$\\Theta_2$,我们只需要使用即可 — $predict.m$ function p = predict(Theta1, Theta2, X) m = size(X, 1); num_labels = size(Theta2, 1); p = zeros(size(X, 1), 1); % ====================== YOUR CODE HERE ====================== X = [ones(m, 1) X]; hide_layer = sigmoid(X * Theta1'); hide_layer = [ones(m, 1) hide_layer]; out_layer = sigmoid(hide_layer * Theta2'); [A, p] = max(out_layer, [], 2); % ========================================================================= end","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习作业","slug":"机器学习/机器学习作业","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习作业","slug":"机器学习作业","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%9C%E4%B8%9A/"}]},{"title":"吴恩达机器学习2","slug":"吴恩达机器学习2","date":"2021-06-03T13:26:40.000Z","updated":"2021-06-26T14:40:57.770Z","comments":true,"path":"/e0295d92/","link":"","permalink":"http://orzff.cn/e0295d92/","excerpt":"吴恩达机器学习笔记(二)","text":"多个特征值对于多个特征的线性回归，我们使用 $m$：代表训练集的大小 $n$：代表特性的数量 $x^{(i)}$：代表第$i$组数据 $x^{(i)}_j$：代表第$i$组数据中的第$j$个特征 对于多个特性的线性回归公式 $h_{\\theta}(x)=\\theta_0+\\theta_1x_1+\\theta_2x_2+\\cdots+\\theta_nx_n$ 我们把参数和特征值看成两个向量 $\\theta=\\begin{bmatrix}\\theta_0 \\\\ \\theta_1 \\\\ \\dots \\\\ \\theta_n \\end{bmatrix} ,X = \\begin{bmatrix}x_0\\\\ x_1\\\\ \\dots \\\\x_n \\end{bmatrix}(x_0=1),$ 那么$h$就可以看成 $h_{\\theta}(x) = \\theta^{T}X$ 多个特征值的梯度下降线性回归：$h_{\\theta}(x)=\\theta_0+\\theta_1x_1+\\theta_2x_2+\\cdots+\\theta_nx_n=\\theta^TX$ 代价函数：$J(\\theta)=\\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$ 梯度下降跟原来$n=1$的时形式相同，只不过扩展了一下 梯度下降：$Repeat \\{ \\\\ \\theta_j:=\\theta_j-\\alpha\\frac{\\alpha}{\\alpha\\theta_j}J(\\theta) \\\\ \\}$ 经过求偏导以后梯度下降变为: $Repeat \\{ \\\\ \\theta_j:=\\theta_j-\\alpha\\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})x^{(i)}_j \\\\ \\}$ 特征放缩 尽量保证多个特征的值都处于一个相近的范围 更一般的将特征放缩到$-1\\le x_i \\le 1$ 如果一个特征的范围再$-3\\le x_i \\le 3$是可以接收的 如何特征放缩一般的使用：$x_i:=\\frac{x_i-\\mu_i}{s_i}$来进行特征缩放 $\\mu_i$：一般表示训练集中特征$i$的平均值 $s_i$：一般表示训练集中特征$i$的范围(最大值-最小值) $\\alpha$的调整画一个代价函数随着迭代次数的增加，$J(\\theta)$的值的变化图，确保$J(\\theta)$随着迭代次数的增加而减小，如果不是，就需要考虑是否再减小$\\alpha$ 但是如果$\\alpha$太小，那么$J(\\theta)$的收敛就会变得非常缓慢 收敛如果$J(\\theta)$在一次迭代中减小到小于$E$，那么证明$J(\\theta)$已经收敛，$E$是某个小值，如$10^{-3}$。但在实际应用中，这个阈值的选择比较困难。 多项式回归有时线性回归不足以拟合训练集中的数据，这时我们可以选择多项式回归。 我们可以改变我们的假设函数的行为或曲线，使它成为二次，三次或平方根函数(或任何其他形式)。 例如我们的假设方法是$h_{\\theta}(x)=\\theta_0+\\theta_1x_1$,我们可以根据$x_1$创建附加的特征使其成为二次函数$h_{\\theta}(x)=\\theta_0+\\theta_1x_1+\\theta_2x_1^2$或者三次函数$h_{\\theta}(x)=\\theta_0+\\theta_1x_1+\\theta_2x_1^2+\\theta_3x^3_1$或者我们也可以使用开平方$h_{\\theta}(x)=\\theta_0+\\theta_1x_1+\\theta_2\\sqrt {x_1}$ 值得注意的是，任何形式的参数都需要注意特征放缩使其在一个能够接受的范围 正规方程梯度下降是得到最小代价函数的一种方法，而正规方程也可以得到最小的代价函数，而且是借助数学推导而不是迭代。 在正规方程中，我们显式的对线性回归的每个参数进行偏导，并使它们为0来最小化$J(\\theta)$,这使我们在不需要迭代的情况下就能找到最优，正规方程的公式如下 $\\theta=(X^TX)^{-1}X^Ty$ 正规方程的特征值不需要进行缩放 梯度下降与正规方程的比较 梯度下降 正规方程 需要选择$\\alpha$ 不需要选择$\\alpha$ 需要很多次迭代 不需要跌代 复杂度$O(kn^2)$ 复杂度$O(n^3)$ 在$n$很大时也能很好的工作 $n$很大时会很慢 一般$n\\gt 10000$时就不再考虑正规方程了 梯度下降对于很多其他的算法也能有很好的表现，但是正规方程可能并不适合 当$X^TX$不可逆时在使用Octave时，我们使用$pinv$来求逆，即使你的矩阵不可逆，它也能够求出逆元 但是当$X^TX$不可逆时，我们可能从两个方面找原因 特征之间线性相关 太多的特征值，而样本又太少 解决上述问题的方法包括删除一个线性相关的特性，如果有太多的特性，删除一个或多个特性。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"机器学习/学习笔记","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://orzff.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"525-连续数组","slug":"525-连续数组","date":"2021-06-03T03:25:07.000Z","updated":"2021-07-04T11:44:11.247Z","comments":true,"path":"/f303f9cc/","link":"","permalink":"http://orzff.cn/f303f9cc/","excerpt":"","text":"525. 连续数组跟523类似，只不过将0的数量减去1的数量的值做前缀和，再用哈希表存储下标。 int findMaxLength(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; int dis = 0, ans = 0, pre = 0; m[0] = -1; for (int i = 0; i &lt; nums.size(); ++ i) { pre += nums[i] == 0 ? 1 : -1; if(m.count(pre)) { ans = max(ans, i - m[pre]); }else m[pre] = i; } return ans; }","categories":[],"tags":[]},{"title":"523-连续的字数组和","slug":"523-连续的字数组和","date":"2021-06-02T06:41:03.000Z","updated":"2021-07-04T11:44:11.247Z","comments":true,"path":"/51b0a147/","link":"","permalink":"http://orzff.cn/51b0a147/","excerpt":"","text":"523. 连续的子数组和直接用前缀和和$k$取余来记录前面k的余数的位置，判断是否大于2即可 bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; m; int n = nums.size(); int pre = 0; m[0] = -1; for (int i; i &lt; n; ++i) { int x = nums[i]; pre = (x + pre) % k; if(m.count(pre)) { if(i - m[pre] &gt;= 2) return true; }else m[pre] = i; } return false; }","categories":[],"tags":[]},{"title":"杭电多校第一场","slug":"杭电多校第一场","date":"2021-05-31T11:58:01.201Z","updated":"2021-05-31T11:58:01.201Z","comments":true,"path":"/9d88cf0e/","link":"","permalink":"http://orzff.cn/9d88cf0e/","excerpt":"杭电多校第一场","text":"A: Blank题意有 $n (n \\leq 100)$ 个格子，向其中填入 $0、1、2、3 $这$4$个数，但是有 $m ( m ≤ 100)$ 个限制 限制 $l$ $ r$ $x$ ：表示 $l ~ r$ 的格子内不同的数的个数为$x$ 要求满足所有限制的方案有多少种？ 思路我们首先设$dp[i][j][k][r]$为这$0，1，2，3$四个数字的最后一次出现的位置,$dp$值为方案数 那么转移可以这样写一下: $dp[cur][j][k][r] += dp[i][j][k][r], dp[i][cur][k][r] += dp[i][j][k][r]$ $dp[i][j][cur][r] += dp[i][j][k][r], dp[i][j][k][cur] += dp[i][j][k][r]$ 因为$i,j,k,r$互不相同, 且当位一定为一个数字并且相互之间有大小顺序，那么我们把$dp$按照大小来转移的话 还是$dp[cur][i][j][k]$ 其中$cur \\geq i \\geq j \\geq k$ 那么转移就变成 $dp[cur+1][i][j][k]+=dp[cur][i][j][k], dp[cur+1][cur][j][k] += dp[cur][i][j][k]$ $dp[cur+1][cur][i][k] += dp[cur][i][j][k], dp[cur+1][cur][i][j] += dp[cur][i][j]$ 我们不必要区分$0,1,2,3$对应的是哪一个，因为这对结果没影响 这样的$dp$数组太大，我们可以用滚动数组来优化一下空间 AC代码实测$dp$数组降序会$T$，可能是因为$dp$过程中地址变换太大造成超时. #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e2 + 7; const int inf = 0x3f3f3f3f; const int mod = 998244353; typedef pair&lt;int, int&gt; pis; vector&lt;pis&gt; lo[maxn]; ll dp[maxn][maxn][maxn][2]; //dp[i][j][k][cur] 升序 void add(ll &amp;a, ll b) { a = a + b; if(a &gt; mod) a -= mod; if(a &lt; 0) a += mod; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) { lo[i].clear(); lo[i].push_back(pis{i, 1}); } for (int i = 1; i &lt;= m; i ++) { int l, r, x; scanf(\"%d %d %d\", &amp;l, &amp;r, &amp;x); lo[r].push_back(pis{l, x}); } memset(dp, 0, sizeof(dp)); dp[0][0][0][0] = 1; for (int cur = 1; cur &lt;= n; cur ++) { int np = cur &amp; 1; for (int i = 0; i &lt;= cur; i ++) for (int j = i; j &lt;= cur; j ++) for (int k = j; k &lt;= cur; k ++) dp[i][j][k][np] = 0; for (int i = 0; i &lt;= cur; i ++) for (int j = i; j &lt;= cur; j ++) for (int k = j; k &lt;= cur; k ++) { /*add(dp[i][k][cur-1][np], dp[i][j][k][np^1]); 地址跨越比add(dp[np][cur-1][k][i], dp[np^1][k][j][i]); 要大，可能是造成超时的原因 */ add(dp[j][k][cur-1][np], dp[i][j][k][np^1]); add(dp[i][k][cur-1][np], dp[i][j][k][np^1]); add(dp[i][j][cur-1][np], dp[i][j][k][np^1]); add(dp[i][j][k][np], dp[i][j][k][np^1]); } for (int i = 0; i &lt;= cur; i ++) for (int j = i; j &lt;= cur; j ++) for (int k = j; k &lt;= cur; k ++) for (pis it: lo[cur]) { int l = it.first, r = cur, x = it.second; int cnt = (i &gt;= l) + (j &gt;= l) + (k &gt;= l) + 1; if(cnt != x) dp[i][j][k][np] = 0; } } ll ans = 0; for (int i = 0; i &lt;= n; i ++) for (int j = i; j &lt;= n; j ++) for (int k = j; k &lt;= n; k ++) add(ans, dp[i][j][k][n&amp;1]); printf(\"%lld\\n\", ans); } return 0; } L: Sequence题意给一个长度为n的数组，有m次操作，操作有3种，给一个x，每次改变序列的值$b_i=\\sum\\limits_{j=i-k*x}a_j$ 求改变完了的序列的$(i\\times a[i])$值的异或和 思路通过打表观察可以发现，一种操作多次操作就是把序列$a$和组合数序列进行卷积，然后就直接用ntt就行了 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 5e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 998244353; typedef pair&lt;int, int&gt; pis; #define g 3 #define Mod(x) ((x)&gt;=mod?(x)-mod:(x)) ll rnk[maxn]; ll a[maxn], b[maxn]; ll Ksm(ll a, ll b) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } ll Fac[1000005], inv[1000005]; void FacPre() { inv[0] = Fac[0] = 1; for (int i = 1; i &lt;= 1000000; i ++) Fac[i] = 1ll * Fac[i-1] * i % mod; inv[1000000] = Ksm(Fac[1000000], mod-2); for (int i = 999999; i &gt;= 1; i --) inv[i] = 1ll * inv[i+1] * (i+1) % mod; } ll C(int n, int m) { if(m &gt; n) return 0; return 1ll * Fac[n] * inv[m] % mod * inv[n-m] % mod; } void ntt(long long *a, int op, int n) { for (int i = 0; i &lt; n; i ++) if(i &lt; rnk[i]) swap(a[i], a[rnk[i]]); for (int i = 2; i &lt;= n; i &lt;&lt;= 1) { int nw = Ksm(g, (mod-1)/i); if(op == -1) nw = Ksm(nw, mod-2); for (int j = 0, m = i &gt;&gt; 1; j &lt; n; j += i) for (int k = 0, w = 1; k &lt; m; k ++) { int t = 1ll * a[j+k+m] * w % mod; a[j+k+m] = Mod(a[j+k]-t+mod); a[j+k] = Mod(a[j+k]+t); w = 1ll * w * nw % mod; } } if(op == -1) for (int i = 0, inv = Ksm(n, mod-2); i &lt; n; i ++) a[i] = 1ll * a[i] * inv % mod; } void solve(ll *a, ll *b, int len) { int n = 1, lim = 0; while(n &lt;= len + len) n &lt;&lt;= 1, lim++; for (int i = 0; i &lt; n; i ++) rnk[i] = (rnk[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1) &lt;&lt; (lim-1)); ntt(a, 1, n); ntt(b, 1, n); for (int i = 0; i &lt; n; i ++) a[i] = (1ll * a[i] * b[i]) % mod; ntt(a, -1, n); for (int i = len; i &lt; n; i ++) a[i] = 0; } int cnt[5]; int main() { FacPre(); int t; scanf(\"%d\", &amp;t); while(t --) { memset(cnt, 0, sizeof(cnt)); int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++) scanf(\"%lld\", &amp;a[i]); for (int i = 1, op; i &lt;= m; i ++) { scanf(\"%d\", &amp;op); cnt[op] ++; } for (int i = 1; i &lt;= 3; i ++) { memset(b, 0, sizeof(b)); for (int j = 0; j * i &lt; n; j ++) b[j*i] = C(cnt[i]-1+j, j); if(cnt[i] == 0) b[0] = 1; solve(a, b, n); } ll ans = 0; for (int i = 0; i &lt; n; i ++) ans = ans ^ (1ll * (i+1) * a[i]); printf(\"%lld\\n\", ans); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"合并排序链表+指针指向问题","slug":"合并排序链表+指针指向","date":"2021-05-31T11:58:01.179Z","updated":"2021-05-31T11:58:01.179Z","comments":true,"path":"/f9d7dd15/","link":"","permalink":"http://orzff.cn/f9d7dd15/","excerpt":"合并排序链表+指针指向问题","text":"LeetCode 题目连接：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/题目描述：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例1： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4限制： 0 &lt;= 链表长度 &lt;= 1000 思路：很简单的题，直接定义一个头，然后两个指针相互比较即可。 问题再最初版本出现了问题，最开始的想法很简单，定义一个头pre 用他去遍历两个链表，再用一个ans来记录pre的头部，然后问题出现了，使用pre=pre-&gt;next, pre=l2时，发现ans并不能完全表达pre的值 ListNode *pre = NULL; if(l1-&gt;val &lt;= l2-&gt;val) { pre = l1; l1 = l1-&gt;next; }else { pre = l2; l2 = l2-&gt;next; } ListNode* ans = pre; pre = pre-&gt;next; while(l1 != NULL &amp;&amp; l2 != NULL) { if(l1-&gt;val &lt;= l2-&gt;val) { pre = l1; l1 = l1-&gt;next; }else { pre = l2; l2 = l2-&gt;next; } pre = pre-&gt;next; } 类似如此，ans返回的时第一次的pre值 为什么第一次ans=pre，此时ans与pre指向同一个地址，类似如此 当执行pre=pre-&gt;next时 当这时执行到pre=l2时， 会发现pre指针直接指向l2,而不会带着next指针一起指向l2，这就造成了pre自己走完了一整个链表而ans却一直指向开始的位置。 解决方案指的时候带上next就可以了 ListNode* pre = new ListNode(0); ListNode* cur = pre; while(l1 != NULL &amp;&amp; l2 != NULL) { if(l1-&gt;val &lt;= l2-&gt;val) { cur-&gt;next = l1; l1 = l1-&gt;next; }else { cur-&gt;next = l2; l2 = l2-&gt;next; } cur = cur-&gt;next; } AC代码/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* pre = new ListNode(0); ListNode* cur = pre; while(l1 != NULL &amp;&amp; l2 != NULL) { if(l1-&gt;val &lt;= l2-&gt;val) { cur-&gt;next = l1; l1 = l1-&gt;next; }else { cur-&gt;next = l2; l2 = l2-&gt;next; } cur = cur-&gt;next; } if(l1 != NULL) cur-&gt;next = l1; if(l2 != NULL) cur-&gt;next = l2; return pre-&gt;next; } };","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"http://orzff.cn/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"Deepin安装NVIDIA以及refind","slug":"Deepin安装NVIDIA以及refind","date":"2021-05-31T11:58:01.074Z","updated":"2021-05-31T11:58:01.074Z","comments":true,"path":"/81fa645f/","link":"","permalink":"http://orzff.cn/81fa645f/","excerpt":"Deepin安装NVIDIA以及refind","text":"Deepin安装NVIDIA驱动安装驱动下载驱动首先根据自己电脑独显的型号去NVIDIA官网选择对应驱动 如果不确定自己电脑显卡型号，可以用sudo lshw -numeric -C display来查看 卸载以前的驱动如果之前在Linux中安装过NVIDIA驱动的话，请将其全部删除 sudo apt autoremove nvidia 禁用nouveaunouveau是通过逆向“Nvidia的Linux驱动”创造的一个开源第三方Nvidia显卡驱动程序，因此其效果差，性能低。在手动安装NVIDIA时需要禁用nouveau驱动。 终端执行以下命令修改文件。 sudo vi /etc/modprobe.d/blacklist.conf 以下内容复制到文件中 blacklist nouveau blacklist lbm-nouveau options nouveau modeset=0 alias nouveau off alias lbm-nouveau off 保存退出。其中，blacklist nouveau是禁用nouveau第三方驱动，之后不需要改回来由于nouveau是构建在内核中的，所以要执行下面命令生效: sudo update-initramfs -u 重启reboot 重启后查看nouveau有没有运行,没输出代表禁用生效 lsmod | grep nouveau 关闭图形界面安装Nvidia驱动程序时，需要停止当前的图形界面。使用快捷键CTRL+ALT+F2进入超级终端，登录账号，并关闭图形界面： sudo service lightdm stop 给驱动文件添加执行权限下载好的nvidia驱动文件是.run，需要添加执行权限。使用cd指令进入下载好的驱动文件路径，如果没有改浏览器的下载路径，路径一般是/home/（你的用户名）/Downloads 。 sudo chmod +x NVIDIA***.run #记得文件名改成自己下载的文件。 驱动安装sudo ./NVIDI**.run #记得文件名改成自己下载的文件。 这个时候会出现一个页面，一系列yes，还有一个界面选择install and cover，意为安装和覆盖。然后等待几分钟。 重启reboot 这样NVIDIA驱动就装好了。 检测NVIDIA驱动是否成功安装使用nvidia-settings命令nvidia-settings 可以看到显卡数据 使用nvidia-smi命令英伟达系统管理接口（NVIDIA System Management Interface, 简称 nvidia-smi）是基于NVIDIA Management Library 的命令行管理组件,旨在帮助管理和监控NVIDIA GPU设备。 nvidia-smi 执行这条命令将会打印出当前系统安装的NVIDIA驱动信息 命令行搜索集显和独显lspci | grep VGA # 查看集成显卡 lspci | grep NVIDIA 查看nouveau是否运行lsmod | grep nouveau 集显与独显切换笔记本外出时使用集显可以节省电量，增长待机时间。可以使用插件：dde-dock-switch_graphics_cardGithub：https://github.com/zty199/dde-dock-switch_graphics_card安装后可以方便地在dock栏切换显卡 使用refind引导win10和deepin安装refind最好在deepin环境下安装refind，因为这样比较简单。 在deepin环境下安装refind有两种方法，使用终端命令行或者下载安装包。 sudo apt-add-repository ppa:rodsmith/refind sudo apt-get update sudo apt-get install refind 安装好refind后重启，你会发现电脑默认引导已经变成了refind，EFI 分区也出现了refind文件夹。但此时的引导界面有两个问题： 1、选项很多，而且界面很丑；2、选择deepin系统后还是会进入grub引导界面，浪费时间。 因此接下来我们需要修改一些东西。 修改设置grub等待时间为0在deepin中，通用&gt;启动&gt;启动延时关闭 下载好看的refind主题首先下载主题压缩包，特别推荐我自己使用的这款极简主题（自带凤凰系统的图标），下载地址： github：https://github.com/EvanPurkhiser/rEFInd-minimal 将解压后的文件放入refind文件夹下的themes文件夹（没有的话可以自行创建）内，可以在deepin环境下使用终端命令操作，也可以切换到win10系统用diskgenius软件进行操作。 修改refind配置文件使用deepin终端修改/EFI/refind/refind.conf文件，需要使用的基本命令如下： su root #获取root权限 vim 你的目录/refind.conf #使用vim修改文件 i #进入修改模式 ESC按键 #退出修改模式 :wq #保存并退出 进入vim编辑模式后，可以看到配置文件有大量的注释，需要修改的命令行其实只有如下几处： timeout 3 resolution 1920 1080 dont_scan_files /EFI/ubuntu/grubx64.efi,/EFI/UOS/fbx64.efi,/EFI/UOS/mmx64.efi,/EFI/UOS/shimx64.efi,/EFI/boot/bootx64.efi,/EFI/boot/grubx64.efi scan_all_linux_kernels false include themes/rEFInd-minimal/theme.conf 这样就可以用refind引导deepin和win10了","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://orzff.cn/tags/Deepin/"},{"name":"NVIDA驱动","slug":"NVIDA驱动","permalink":"http://orzff.cn/tags/NVIDA%E9%A9%B1%E5%8A%A8/"},{"name":"refind","slug":"refind","permalink":"http://orzff.cn/tags/refind/"}]},{"title":"C++学习笔记（三）","slug":"C-学习笔记(三)","date":"2021-05-31T11:58:00.997Z","updated":"2021-05-31T11:58:00.997Z","comments":true,"path":"/a8ec0156/","link":"","permalink":"http://orzff.cn/a8ec0156/","excerpt":"C++学习笔记（三）","text":"C++ 学习笔记(三)静态成员静态成员变量​ 在一个类中，若将一个成员变量声明为static，这种成员成为静态变量，与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝，静态成员变量，属于某个类，所有对象共享。 ​ 静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。 静态成员变量必须在类中声明，在类外定义 静态数据成员 不属于某个对象，在为对象分配空间中不包括静态对象成员所占空间 静态数据成员可以通过类名或者对象名来引用 静态成员变量在类内声明，在类外初始化 静态成员变量也有权限 静态成员函数 静态成员函数不可以访问普通的成员变量，可以访问静态成员变量 静态成员函数也是有权限的 普通成员函数可以访问普通成员变量，也可以访问静态成员变量 面向对象模型初探成员变量和函数的存储数据 和 处理数据的操作是分开存储的 C++中的非静态数据成员直接内含在类对象中，就像C struct一样 成员函数虽然内含在class声明之内，却不出现在对象中 每一个非内联成员函数只会诞生一份函数实例 空类的大小为1,每一个实例的对象，都有独一无二的地址，char维护这个地址 class Person{ public: int m_A; // 非静态成员变量，属于对象身上 void func() {}; //非静态成员函数，不属于对象身上 static int m_B; // 静态成员变量，不属于对象身上 static void func2() {}; //静态成员函数，不属于对象身上 } // 结论： 非静态成员变量，才属于对象身上 this指针this指针称为“永远指向本对象的指针”，this指针并不是对象的一部分,*this是对象本体 this指针是一种隐含指针，它隐含于每个类的非静态成员函数中，静态成员函数不能访问this指针 this指针指向被调用的成员函数所属的对象 Person p1; p1.func(Person*this);// 编译器会偷偷加上一个p1的this指针 空指针访问成员函数空指针可以访问成员函数，但是如果成员函数中用到了this指针，那么就会执行失败 const 修饰成员函数this永远指向本体，类似Person * const this,this的指向不能修改，但指针指向的值可以修改 void showInfo() const { // const加后面代表常函数，意味着不允许修改指针指向的值 this-&gt;m_B = 100; // 如果在常函数中修改，那么就在成员变量前面加mutable } mutable int m_B; 常对象常对象不允许修改属性 const Person p2; 常对象不可以调用普通的成员函数，可以调用常函数 友元友元函数可以访问类的私有成员属性 全局函数做友元全局函数可以作为类的友元函数，在类中声明全局函数，并加上friend关键字 class A{ public: friend void test(); }; void test() { // ... } 类做友元class A{ friend class B; // B作为A的友元类，可以访问A的私有成员属性 } 成员函数做友元class A{ firend void B::test(); // B的成员函数作为A的友元，可以访问A的私有成员属性 } 运算符重载如果想让自定义数据类型进行运算符运算，那么就需要重载运算符。 在成员函数或者在全局函数中，重写一个运算符重载，运算符重载也可以进行重载 对于内置数据类型的表达式运算符是不可以改变的（例如int类型的+号） +号重载class A { // 类内重载 A operator + (A &amp; b) { A tmp; // ... return tmp; } } // 全局重载 A operator + (A &amp;a, A &amp;b) { A tmp; // ... return tmp; } &lt;左移运算符不要随意使用符号重载，cout &lt;&lt;可以对自定义数据类型进行输出 ostream&amp; operator &lt;&lt; (ostream &amp;cout, A &amp;a) { // 第一个参数cout，第一个参数A cout &lt;&lt; \"A: \" &lt;&lt; a &lt;&lt; endl; }//全局重载可以在类中添加friend，访问类的私有成员属性 前置后置递增运算符重载class MyInt{ // 前置++重载 MyInt&amp; operator++(){ this-&gt;num ++; return *this;}// 后置++重载，使用int来区分 MyInt operator++(int) { MyInt tmp = *this; this-&gt;num ++; return tmp;}private: int num;} 指针运算符重载智能指针，用来托管自定义类型对象，让对象进行自动的释放 智能指针就是一个包含对象类型的类，重载-&gt;可以使得智能指针调用类内指针的成员函数以及成员变量 A * operator -&gt; () { // 加上*代表返回指针 return this-&gt;a; } A &amp; operator * () { return *this-&gt;a; } 赋值运算符重载一个类默认创建，默认构造、析构、拷贝构造 、operator=赋值元算符 class Person { // 重载= Person&amp; operator = (const Person&amp; p) { //先判断堆区是否有内容 if (this-&gt;pName != NULL) { delete[] this-&gt;pName; this-&gt;pName = NULL; } this-&gt;pName = new char[strlen(p.pName)+1]; strcpy(this-&gt;pName, p.pName); return *this; } private: char* pName; } []重载class MyArray{ public: // []重载 int&amp; operator[] (int idx) { return *this-&gt;pAddress[idx]; } private: int *pAddress; int m_Size; int m_Capacity; }; 关系运算符重载class Person{ bool operator == (Person &amp;p) { if(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) { return true; } return false; } bool operator != (Person &amp;p) { if(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) { return false; } return true; }public: string name; int age; } 函数调用运算符()重载 class MyPrint{ public: void operator() (string s) { cout &lt;&lt; s &lt;&lt; endl; } } MyPrint mp;//仿函数 MyPrint()(\"你好\") mp(\"你好\");// 匿名对象 总结 =， []，-&gt; 操作符只能通过成员函数进行重载 &lt;&lt;，&gt;&gt;只能通过全局函数配合友元函数重载 不要重载&amp;&amp;，||操作符，因为无法实现短路规则","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"吴恩达机器学习1","slug":"吴恩达机器学习1","date":"2021-05-30T04:12:23.000Z","updated":"2021-07-06T14:45:07.833Z","comments":true,"path":"/79200c28/","link":"","permalink":"http://orzff.cn/79200c28/","excerpt":"吴恩达机器学习笔记(一)","text":"什么是机器学习 $A\\ computer\\ program\\ is\\ said\\ to\\ learn\\ from\\ experience\\ E\\ with $ $respect\\ to\\ some\\ class\\ of\\ tasks\\ T\\ and\\ performance\\ measure\\ P,\\ if\\ $ $its\\ performance\\ at\\ tasks\\ in\\ T,\\ as\\ measured\\ by\\ P,\\ improves\\ with\\ $ $experience\\ E.$ 一个计算机程序可以从经验$E$中学习，执行任务$T$，由$P$做性能评估，并且他在$T$任务中的表现(由$P$衡量)随着经验$E$的提高而提高。 以下跳棋为例: $E:$ 下过很多跳棋的经验 $T：$下跳棋的任务 $P ：$下一局赢下跳棋的可能性 一般的任何机器学习都可以分类两类：监督学习和非监督学习 什么是监督学习 $In\\ supervised\\ learning,\\ we\\ are\\ given\\ a data\\ set\\ and\\ already\\ know\\ $ $what\\ our\\ correct\\ output\\ should\\ look\\ like,having\\ the\\ idea\\ that\\ there\\ $ $is\\ a\\ relationship\\ between\\ the\\ input\\ and\\ the\\ output.$ 在监督学习中，我们已知一个数据集，并且已经知道正确的输出应该是什么样的，我们知道输入与输出之间存在着一种关系。 在监督学习中，我们已经知道数据集的含义、分布，根据已知的信息来预测。 $Supervised\\ learning\\ problems\\ are\\ categorized\\ into\\ “regression”\\ and\\ $ $”classification”\\ problems.\\ In\\ a\\ regression\\ problem,\\ we\\ are\\ trying\\ to\\ $ $predict\\ results\\ within\\ a\\ continuous\\ output,\\ meaning\\ that \\ we\\ are\\ $ $trying\\ to\\ map\\ input\\ variables\\ to\\ some\\ continuous\\ function.\\ In\\ a\\ $ $classification\\ problem,\\ we\\ are\\ instead\\ trying\\ to\\ predict\\ results\\ $ $in\\ a\\ discrete\\ output.\\ In\\ other\\ words,\\ we\\ are\\ trying\\ to\\ map\\ input\\ $ $variables\\ into\\ discrete\\ categories.\\ $ 监督学习问题分为“回归”问题和“分类”问题。在回归问题中，我们试图预测连续输出中的结果，这意味着我们试图将输入变量映射到某个连续函数。在分类问题中，我们试图预测离散输出中的结果。换句话说，我们试图将输入变量映射到离散的类别中。 例子回归问题：给一张照片，去预测照片中人的年龄 分类问题：对于患有肿瘤的病人，去预测肿瘤是良性还是恶性 什么是无监督学习 $Unsupervised\\ learning\\ allows\\ us\\ to\\ approach\\ problems\\ with\\ little\\ or\\ $ $no\\ idea\\ what\\ our\\ results\\ should\\ look\\ like.\\ We\\ can\\ derive\\ $ $ structure\\ from\\ data\\ where\\ we\\ don’t\\ necessarily\\ know\\ the\\ effect\\ of\\ $ $the\\ variables.\\ $ $We\\ can\\ derive\\ this\\ structure\\ by\\ clustering\\ the\\ data\\ based\\ on\\ $ $relationships\\ among\\ the\\ variables\\ in\\ the\\ data.$ $With\\ unsupervised\\ learning\\ there\\ is\\ no\\ feedback\\ based\\ on\\ the\\ prediction\\ results.$ 无监督学习让我们在几乎不知道结果是什么的情况下处理问题。我们可以从数据中得出结构，而我们并不一定知道变量的影响。 我们可以根据数据中变量之间的关系对数据进行聚类，从而得到这种结构。 在无监督学习中，没有基于预测结果的反馈。 例子收集100万个不同的基因，然后找到一种方法将这些基因分组，这些分组在某种程度上是相似的，或者由不同的变量(如寿命、位置、角色等)相关的。 建立符号规则$m$ 表示训练集数量，对于训练集中的每一项，我们使用$x^{(i)}$表示训练集中的第$i$行输入的变量，使用$y^{(i)}$表示训练集中第$i$行输出的变量 。 一对$(x^{(i)},y^{(i)})$成为一个训练样例，$(i)$只是表示训练集中的索引，而不是次幂。还使用$X$来表示输入值的空间，$Y$表示输出值的空间。 监督学习 $To\\ describe\\ the\\ supervised\\ learning\\ problem\\ slightly\\ more\\ formally,\\ $ $our\\ goal\\ is,\\ given\\ a\\ training\\ set,\\ to\\ learn\\ a\\ function\\ h\\ :\\ X\\ →\\ Y\\ $ $ so\\ that\\ h(x)\\ is\\ a\\ “good”\\ predictor\\ for\\ the\\ corresponding\\ value\\ of\\ y.\\ $ $For\\ historical\\ reasons,\\ this\\ function\\ h\\ is\\ called\\ a\\ hypothesis.\\ $ $Seen\\ pictorially,\\ the\\ process\\ is\\ therefore\\ like\\ this:\\ $ 为了更正式地描述监督学习问题，我们的目标是，给定一个训练集，学习一个函数$h: X → Y$，使$h(X)$是对应的$Y$值的一个很好的预测器。由于历史原因，这个函数$h$被称为一个假设。从图片上看，这个过程是这样的 代价函数假设的$h$函数由$h_{\\theta}(x)=\\theta_0 + \\theta_1x$拟合而来，$\\theta_0$和$\\theta_1$是两个未知参数 我们的目的是选择最适合的$\\theta_0,\\theta_1$以便于$h_{\\theta}(x)$最接近与真正的训练集对应$Y$值的分布 代价函数$J(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum\\limits_{i=1}^m(\\hat y_i -y_i)^2=\\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$表示$h$函数与$Y$值之间的误差 $Goal:\\ \\min\\limits_{\\theta_0,\\theta_1}J(\\theta_0, \\theta_1)$ 把$\\theta_0$设成0,不同的$\\theta_1$对应的$h$函数所形成的误差在$J(\\theta_1)$的图像上呈现一个二次函数的图像，寻找$J(\\theta_1)$的最小值，就是寻找最适合，最拟合与$Y$的$h(\\theta_1)$函数 梯度下降梯度下降算法就是根据当前的参数和代价函数选择一个下降方向，最终达到局部最优解的一种算法。 $The\\ way\\ we\\ do\\ this\\ is\\ by\\ taking\\ the\\ derivative\\ (the\\ tangential$ $line\\ to\\ a\\ function)\\ of\\ our\\ cost\\ function.\\ The\\ slope\\ of\\ the\\ tangent$ $is\\ the\\ derivative\\ at\\ that\\ point\\ and\\ it\\ will\\ give\\ us\\ a\\ direction$ $to\\ move\\ towards.\\ We\\ make\\ steps\\ down\\ the\\ cost\\ function\\ in\\ the$ $direction\\ with\\ the\\ steepest\\ descent.$ 梯度下降算法是求当前代价函数的导数（也就是函数图像的切线），这一点的导数会给我们一个方向，我们按下降最陡的方向逐步降低成本函数。 $The\\ size\\ of\\ each\\ step\\ is\\ determined\\ by\\ the\\ parameter\\ α,\\ which\\ is$ $called\\ the\\ learning\\ rate.$ 每个步骤的大小由参数α决定，称为学习率。 $repeat\\ until\\ convergence\\ \\{ \\\\ \\theta_j\\ :=\\ \\theta_j\\ - \\alpha \\ \\frac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1) (for j=0 and j=1) \\\\ \\}$ $\\theta_0$和$\\theta_1$同时更新，而不是先更新$\\theta_0$，然后再更新$\\theta_1$ 泰勒展开 泰勒公式是将一个在$x=x_0$处具有$n$阶导数的函数$f(x)$利用关于$(x-x0)$的$n$次多项式来逼近函数的方法。 若函数$f(x)$在包含$x_0$的某个闭区间$[a,b]$上具有$n$阶导数，且在开区间$(a,b)$上具有$(n+1)$阶导数，则对闭区间$[a,b]$上任意一点$x$，成立下式： $f(x) = \\frac{f(x_0)}{0!}+\\frac{f’(x_0)}{1!}(x-x_0)+…+\\frac{f^{(n)}(x_0)}{n!} + R_n(x)$ 梯度下降在推导过程中使用了1阶泰勒展开 $f(x+\\Delta x)\\approx f(x) + a^t\\Delta x$ $\\Delta x$是一个向量，$a$也是一个向量,$a^t$就是当前的梯度 梯度下降的目的是找到一个方向使得$f(x)\\gt f(x+\\Delta x)$, 在$x$附近小范围的$\\Delta x$找到一个点使得$f(x+\\Delta x)$最小，然后向着这个的方向移动并迭代，在计算$\\min\\limits_{||\\Delta x|| \\le \\epsilon} f(x+\\Delta x)$时使用泰勒展开减小计算量 柯西不等式 两个向量做内积时$||||^2 \\le ||a||^2 ||b||^2$,等式成立当且仅当$a,b$在一条直线上，或者说$a,b$线性相关 $a^t\\Delta x= \\ge -||a|| \\ ||b|| \\ge -||a||\\epsilon$ 即$a^t\\Delta x \\ge -\\epsilon ||a||$不等式成立时$\\Delta x = -\\lambda a, \\lambda &gt;0$ 梯度下降如何达到最优点我们现在使用一个简单函数来解释一下梯度下降算法 假设我们的参数只有一个 $\\theta_1 :=\\theta_1-\\alpha \\frac{\\partial}{\\partial\\theta_1}J(\\theta_0)$ 图上第一个例子：当所在点在最优解右侧时，斜率为正$\\theta$减去的时正值，$\\theta$向左边移动 图上第二个例子：当所在点在最优解左侧时，斜率为正$\\theta$减去的时负值，$\\theta$向右边移动 根据斜率（也就是导数）移动，可以移动到当前可以到达的最优点 步距 当我们的步距过大和过小时都会出现问题 过小时移动次数太多，移动距离太小 过大时会越过最优点 梯度下降如何与固定步长相结合 当点越接近最低点时，导数最小，到最低点时导数为零，这就控制了步长使得步长的移动合适 梯度下降与代价函数结合拟合函数：$h(\\theta_0,\\theta_1)=\\theta_0+\\theta_1x$ 代价函数: $J(\\theta_0, \\theta_1) = \\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$ 梯度下降:$repeat\\ until\\ convergence\\ \\{ \\\\ \\ \\ \\ \\ \\theta_j\\ :=\\ \\theta_j\\ - \\alpha \\ \\frac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1) (for j=0 and j=1) \\\\ \\} $ 结合一下: $\\frac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1)\\\\ = \\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2 \\\\ = \\frac{1}{2m}\\sum\\limits_{i=1}^m(\\theta_0+\\theta_1(x^{(i)})-y^{(i)})^2$ 经过简单的微分过程:$\\theta_0\\ j = 0 \\ :\\ \\ \\frac{\\partial}{\\partial\\theta_0}J(\\theta_0,\\theta_1)= \\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)}) \\\\ \\theta_1\\ j = 1 \\ :\\ \\ \\frac{\\partial}{\\partial\\theta_1}J(\\theta_0,\\theta_1)= \\frac{1}{m}\\sum\\limits_{i=1}^m(h_{\\theta}((x^{(i)})-y^{(i)}) \\cdot x^{(i)}) $ $m$是训练集的大小，$\\theta_0$是常量它会随着$\\theta_1$同步变化 这种方法在每一步上看整个训练集中的每个例子，称为批梯度下降。 矩阵和向量矩阵的定义不在赘述，向量是一种特殊的矩阵，向量的结构是$n \\times 1$的矩阵 $y=\\begin{bmatrix} a\\\\ b\\\\c\\\\d\\\\ \\end{bmatrix}$ $y_i$表示第$i$个元素 向量的下标可以有不同的起始，从1开始和从0开始，在数学中通常使用从1开始，在计算机领域通常使用从0开始 $y=\\begin{bmatrix} y_1\\\\ y_2\\\\ y_3\\\\ y_4\\\\ \\end{bmatrix} , y=\\begin{bmatrix} y_0\\\\ y_1\\\\ y_2\\\\ y_3\\\\ \\end{bmatrix}$ 矩阵加法两个矩阵相加必须是规格相同的两个矩阵对应位置相加 $\\begin{bmatrix}1 &amp;&amp; 0\\\\2 &amp;&amp; 5 \\\\ 3 &amp;&amp; 1\\end{bmatrix} + \\begin{bmatrix}4 &amp;&amp; 0.5\\\\2 &amp;&amp; 5 \\\\ 0 &amp;&amp; 1\\end{bmatrix}=\\begin{bmatrix}5 &amp;&amp; 0.5\\\\4 &amp;&amp; 10 \\\\ 3 &amp;&amp; 2\\end{bmatrix}$ 矩阵乘除矩阵乘以常量就是每个矩阵的每一元素乘上常量，除法类似 $k\\times \\begin{bmatrix}1 &amp;&amp; 0\\\\2 &amp;&amp; 5 \\\\ 3 &amp;&amp; 1\\end{bmatrix} = \\begin{bmatrix}1k &amp;&amp; 0k\\\\2k &amp;&amp; 5k \\\\ 3k &amp;&amp; 1k\\end{bmatrix}$ 两个矩阵相乘必须是$m\\times n$和$n \\times k$ 形式的矩阵才能相乘 $\\begin{bmatrix} A_{11} &amp;&amp; A_{12} &amp;&amp; A_{13} \\\\ A_{21} &amp;&amp; A_{22} &amp;&amp; A_{23}\\end{bmatrix} \\times \\begin{bmatrix} B_{11} &amp;&amp; B_{12} \\\\ B_{21} &amp;&amp; B_{22} \\\\ B_{31} &amp;&amp; B_{32} \\end{bmatrix}$ 比如$2\\times 3$的矩阵和$3\\times 2$的矩阵相乘，新矩阵的元素为$a_{ij}=\\sum\\limits_{k=1}^{n}A_{ik}*B_{kj}$ 新矩阵为： $\\begin{bmatrix} (A_{11}\\times B_{11}+A_{12}\\times B_{21}+A_{13}\\times B_{31}) &amp;&amp; (A_{11}\\times B_{12}+A_{12}\\times B_{22}+A_{13}\\times B_{32}) \\\\ (A_{21}\\times B_{11}+A_{22}\\times B_{21}+A_{23}\\times B_{31}) &amp;&amp; (A_{21}\\times B_{12}+A_{22}\\times B_{22}+A_{23}\\times B_{32}) \\end{bmatrix}$ 元矩阵$\\begin{bmatrix}1 &amp;&amp; 0\\\\0 &amp;&amp; 1\\end{bmatrix}$或者 $\\begin{bmatrix}1 &amp;&amp; 0 &amp;&amp; 0\\\\0 &amp;&amp; 1 &amp;&amp; 0 \\\\ 0 &amp;&amp; 0 &amp;&amp; 1\\end{bmatrix}$ 或者更大 元矩阵通常写作$I$，对于任意矩阵$A$ $A \\cdot I=I\\cdot A=A$ 逆矩阵如果矩阵$A$是一个方矩阵$m\\times m$,那么$A$存在逆矩阵$A^{-1}$ $AA^{-1}=A^{-1}A=I$ 矩阵的转置转置就是将矩阵转过来$B_{ji}=A_{ij}$ $A=\\begin{bmatrix}1 &amp;&amp; 2 &amp;&amp; 0 \\\\ 3 &amp;&amp; 5 &amp;&amp; 9 \\end{bmatrix}$ $A^T=\\begin{bmatrix}1 &amp;&amp; 3 \\\\ 2 &amp;&amp; 5 \\\\ 0 &amp;&amp; 9 \\end{bmatrix}$ 矩阵与梯度下降结合两个矩阵，一个$A(m\\times n)$ 一个$B(n \\times o)$，我们将$B$中的每一列单独取出来最矩阵乘法，得到的结果再合并，跟原来的结果相同 类似的矩阵的每一列我们都可以看成是一个向量，把不同的$h$函数也看成向量，那么两个矩阵相乘就可以得到不同$h$函数的预测量","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"机器学习/学习笔记","permalink":"http://orzff.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://orzff.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://orzff.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"机器学习笔记(一)","slug":"Learn-ML1","date":"2021-05-29T04:54:19.000Z","updated":"2021-06-25T13:01:46.628Z","comments":true,"path":"/deefd94b/","link":"","permalink":"http://orzff.cn/deefd94b/","excerpt":"机器学习笔记(一)","text":"机器学习三大步骤先写出一个带有未知参数的数学式$Function \\ with \\ Unknown \\ Parameters$ $y = b + w x_1$ 带有未知参数$b, w$的公式，叫做model(带有未知的参数的数学式) $x_1:$ 公式中已知的东西叫做feature $w:$ 不知道的参数叫做weight（权重） $b:$ 不知道的参数叫做bias （偏移） 根据训练集定义$Loss$$Loss(b,w)$是一个函数，输入是$b,w$ Loss代表训练出来的函数对于训练集的拟合程度 $Loss: L = \\frac{1}{N}\\sum\\limits_n{e_n} (e = |y - y’|)$ 每项$e$是$model$对于训练集的误差 最佳化$w^{\\star}, b^{\\star} = arg \\ \\min\\limits_{w,b}L$ $Gradient\\ Descent$ 随机选取一个初始点$w^0$ 计算微分 $\\frac{\\partial L}{\\partial w}|_{w= w^0}$ 根据微分的正负选择向前或向后移动$\\eta\\frac{\\partial L}{\\partial w}|_{w= w^0}$, $\\eta$学习速率，自己设置 迭代的更新$w$值 $model$ 的限制对于一次项的$model$是一条单纯的斜线，可能无法很好的拟合数据集，这叫做$Model$的$bias$，解决方法，写一个更复杂的，有更多未知参数的$model$ 例如需要拟合一个复杂的函数（红色线段）， 可以在每次的转折点添加一个蓝色线段，斜率保持相同即可，按理说，越是复杂的红色线段所需要的蓝色线段越多 对于连续的曲线可以选择足够多的点，就可以来使用蓝色线段拟合 如何来表达蓝色线段通过一个函数来逼近蓝色线段 $y = c \\frac{1}{1 + e ^{-(b+wx_1)}}$ 即 $y = c \\ sigmoid (b + wx_1)$ 调整$b, w, c$就可以得到各种各样的蓝色线段，改变$w$可以改变斜率，改变$b$会改变偏移，改变$c$会改变高 对于不同的蓝色线段使用不同的$b,w,c$来通过$sigmoid$逼近，那么红色线段的函数式就为$y = b + \\sum\\limits_{i}c_i\\ sigmoid(b_i + w_ix_1)$ 线性代数表达对于数据$x_1, x_2, x_3$ $\\sum\\limits_{i}c_i\\ sigmoid(b_i + w_ix_1)$可以表示为 r_1 = b_1 + w_1x_1\\\\ r_2 = b_2 + w_2x_2 \\\\ r_3 = b_3 + w_3 x_3矩阵写法 \\begin {bmatrix} r_1\\\\r_2\\\\r_3 \\end {bmatrix} = \\begin {bmatrix} b_1\\\\b_2\\\\b_3 \\end {bmatrix} + \\begin {bmatrix} w_1 \\ 0 \\ 0\\\\0\\ w_2\\ 0\\\\0 \\ 0\\ w_3 \\end {bmatrix}\\begin {bmatrix} x_1\\\\x_2\\\\x_3 \\end {bmatrix}$r = b + Wx$ 在对每一个$r$做$sigmoid$运算 $a = \\partial(r)$ 红色线段函数: $y = b + \\sum\\limits_{i}c_i \\ a$ 使用线性代数表达方式: $y = b + c^T a$ 使用$\\theta $ 来包含所有的未知参数$\\theta = \\begin{bmatrix} \\theta_1\\\\ \\theta_2 \\\\ \\theta_3 \\\\ \\dots \\\\ \\end{bmatrix}$ $Loss$ 使用$\\theta $参数$Loss$现在使用写成$L(\\theta)$ 新的$Loss$表示为：$Loss: \\ L = \\frac{1}{N}\\sum\\limits_ne_n$ 迭代最好的$model$$\\theta^* = arg \\ \\min\\limits_{\\theta}L$ 随机选择一个初始的$\\theta^0$， 对$\\theta$的每一项进行微分得到一个向量$g$ , $g = \\begin{bmatrix} \\frac{\\partial L}{\\partial \\theta_1}|_{\\theta = \\theta^0} \\\\ \\frac{\\partial L}{\\partial \\theta_2}|_{\\theta = \\theta^0} \\\\ \\frac{\\partial L}{\\partial \\theta_3}|_{\\theta = \\theta^0} \\\\ \\dots \\end{bmatrix}= \\nabla L (\\theta ^0)$ 在$\\theta = \\theta^0$的位置把所有的参数都对$L$做微分 更新$\\theta$的值 $\\begin{bmatrix} \\theta_1^1 \\\\ \\theta_2^1\\\\ \\dots \\end{bmatrix} \\longleftarrow \\begin{bmatrix} \\theta_1^0 \\\\ \\theta_2^0\\\\ \\dots \\end{bmatrix} - \\begin{bmatrix} \\eta \\frac{\\partial L}{\\partial \\theta_1}|_{\\theta = \\theta^0} \\\\ \\eta \\frac{\\partial L}{\\partial \\theta_2}|_{\\theta = \\theta^0} \\\\ \\dots \\end{bmatrix}$ 新的$\\theta$由原先的$\\theta^0$ 减去 微分的向量 × $\\eta$ $\\theta^1 \\longleftarrow \\theta^0 - \\eta g$ 步骤： 先随机选取$\\theta^0$，通过计算$gradient$ 得到 $ g = \\nabla L (\\theta ^0)$,在如此迭代得到$\\theta^1, \\theta^2,…$直到无法在计算$gradient$时结束 实际操作时，将数据集分为多组，利用每一组来计算$gradient$更新$\\theta$ 从 $sigmoid$到$RELU$利用$RELU$来拟合函数 $c\\ max(0, b+wx_1)$ $ y = b + \\sum\\limits_i c_i \\ sigmoid(b_i + \\sum\\limits_jw_{ij}x_j)$ $y = b + \\sum\\limits_{2i}c_i max(0, b_i+\\sum\\limits_jw_{ij}x_j)$ $sigmoid$ 和 $RELU$ 统称为$activation\\ function$, $RELU$更好一些 过拟合当拟合的函数次数过多时，对于训练数据会出现拟合效果好，但是对于测试数据拟合率爆炸的情况。","categories":[{"name":"ML 学习","slug":"ML-学习","permalink":"http://orzff.cn/categories/ML-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"ML 学习笔记","slug":"ML-学习笔记","permalink":"http://orzff.cn/tags/ML-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++学习笔记(五)","slug":"C-学习笔记(五)","date":"2021-05-10T03:03:12.000Z","updated":"2021-05-31T11:58:01.022Z","comments":true,"path":"/2c61a387/","link":"","permalink":"http://orzff.cn/2c61a387/","excerpt":"C++学习笔记(五)","text":"C++ 学习笔记（五）C++类型转换尽量少使用类型转换，除非用来解决特殊问题 静态转换static_cast目标类型 目标对象 = static_cast&lt;目标类型&gt;(原对象); 用于类层次结构中的基类和派生类之间指针或引用的转换，没有父子关系的不能转换 进行上行转换（派生类的指针或引用转换成基类）是安全的 进行下行转换（基类指针或引用转换成派生类）时，由于没有动态类型检查，所以时不安全的 用于基本数据类型之间的转换，如将int转换成char，把char转换成int，这种转换的安全性也要开发人员来保证 动态转换dynamic_castdynamic_cast非常严格，失去精度或者不安全都不可以转换 目标类型 目标对象 = dynamic_cast&lt;目标类型&gt;(原对象); 基础类型之间不能转换 dynamic_cast如果发生了多态，那么可以让基类转为派生类，向下转换 常量转换const_cast用来修改const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 常量引用被转换成非常量引用，并且仍然指向原来的对象 注意:不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的const const int * p = NULL; int *newp = const_cast&lt;int *&gt; (p); int * p1 = NULL; const int *newp1 = const_cast&lt;const int *&gt; (p1); 重新解释转换reinterpert_cast最不安全，不推荐使用 异常try{ // 试图执行的内容 // 在可能出现异常的地方抛出异常throw } catch() { // try下面catch捕获异常 // catch(捕获类型) ... 代表所有其他类型 // 如果不想处理异常，继续向上抛出throw } 跳级 异常基本处理int myd(int a, int b){ if(b == 0) { // return -1; 早期处理方式，返回-1 throw -1; // 抛出int类型异常，异常必须处理，如果不处理就挂掉 } return a/b; } void test() { int a = 10, b = -10; int ret = myd(a, b); // 早期如果返回-1， 无法区分到底是结果还是异常 try{ myd(a, b); } catch(int) {// 捕获int类型异常 // 如果不想在这处理，就抛出，返回上一层处理,类型不变 throw; //. 异常处理 } catch(...) { //其他类型异常捕获 } } void test2() { try{ test(); }catch(int) { // 如果异常都没有处理，那么成员terminate函数是程序中断 // ... } } 自定义异常类class MyException{ public : void printError(); } // try{ 抛出异常 // throw MyException(); // } // 捕获异常 catch(MyException e) { e.printError(); } 栈解旋 从try开始到throw抛出异常之前，所有栈上的对象，都会被释放，这个过程称为栈解旋 栈上对象构造和析构顺序相反 异常的接口声明void func() throw(int) { //thrwo(int) 只能抛出int类型异常 throw 3.14; // 抛出double类型直接挂掉 } void func() throw() { //thrwo() 不跑出任何类型异常 throw 3.14; } 异常变量声明周期异常变量的构造是在throw抛出异常时构造，析构实在catch处理完以后析构 class MyException{ public : void printError(); } void dowork() { throw MyException(); } void test() { try { dowork(); }catch(MyException e) { // catch时通过拷贝构造又会有一份数据，所以建议使用&amp; // catch(MyException &amp;e) } } // 返回指针，使用new，在堆区开辟内存，然后手动delete void dowork() { throw new MyException(); } void test() { try { dowork(); }catch(MyException * e) { // catch时通过拷贝构造又会有一份数据，所以建议使用&amp; // catch(MyException &amp;e) delete e; } } 异常的多态利用多态来实现printError同一个接口的使用 系统的异常库#include &lt;stdexcept&gt; 文件读写头文件#include &lt;fstream&gt; 写文件void test() { ofstream ofs(path， ios::out|ios::trunc); if(!ofs.is_open) { //... 打开失败 } ofs &lt;&lt; \"content\" &lt;&lt; endl;} 读文件void test() { ifstream ifs(path, ios::in); if(!ifs.is_open) { //... 打开失败 } // 第一种方式 char buf[1024]; while(ifs &gt;&gt; buf) { // 按行读取 cout &lt;&lt; buf &lt;&lt; endl; } // 第二种方式 while(!ifs.enf()) { // enf读到文件尾 ifs.getline(buf, sizeof(buf)); cout &lt;&lt; buf &lt;&lt; endl; } // 第三种方式 不推荐 按单个字符读取 char c; while((c = ifs.get()) != EOF) { cout &lt;&lt; c &lt;&lt; endl; } }","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++学习笔记(四)","slug":"C-学习笔记(四)","date":"2021-05-08T10:29:45.000Z","updated":"2021-05-31T11:58:01.055Z","comments":true,"path":"/2acaf4fa/","link":"","permalink":"http://orzff.cn/2acaf4fa/","excerpt":"C++学习笔记(四)","text":"C++学习笔记（四）继承class 子类 : 继承方式 父类 继承权限 继承方式 特点 父类私有属性能不能访问 public 父类的属性权限不变 不能 protect 父类的属性全变为protect 不能 private 父类的属性全变为private 不能 子类中会继承父类的私有成员，但是被编译器隐藏了起来 继承中的构造与析构构造： 先执行父类的构造函数，在调用子类的构造函数 析构：先执行子类的析构，在执行父类的析构 子类并不能继承父类的构造和析构函数，只有父类自己知道自己构造和析构的属性 如果父类没有默认构造，那么子类在构造时可以通过初始化列表的方式显示调用父类的有参构造 class Base{ Base(int a) ; } class Son : public Base{ Son(int a): Base(a) { } } 继承中的同名处理子类与父类属性或函数同名时，根据就近原则，属性为子类的值，如果想使用父类的值，那么就在调用时加上作用域 class Base{ public: int m_a; } class Son : punlic Base{ public; Son(int a) { this-&gt;m_a = 200; } int m_a; } void test() { Son s; cout &lt;&lt; s.m_a &lt;&lt; endl; // 子类的m_a cout &lt;&lt; s.Base::m_a &lt;&lt; endl;// 父类的m_a } 如果子类与父类的成员函数名称相同，子类会把父类的所有同名版本全隐藏，像调用父类的方法，必须加作用域 继承中的静态成员处理静态成员属性，子类可以继承下来，使用时直接在静态成员属性前加作用域即可 静态成员函数，子类也可以继承下来，使用时 Son::func() // 子类的func Son::Base::func() // 父类的func 非自动继承的函数不是所有的函数都能继承到子类，构造和析构函数不能继承，operator=也不能继承，因为它完成类似构造函数的行为 多继承一个类可以继承多个类 class A: public B, public C 二义性多继承中如果多继承的多个类有相同的成员属性，那么子类在调用父类相同的属性时会引发二义性 class A: public B, public C A a; cout &lt;&lt; a.m_a &lt;&lt; endl; // 如果B和C中都有m_a会引发二义性 cout &lt;&lt; a.B::m_a &lt;&lt; a.C::m_a &lt;&lt; endl;// 使用时在前面加上作用域 菱形继承子类继承的父类继承自同一个基类，会导致二义性的产生 class A; class B: public A; class C: public A; class D: public B, public C; 菱形继承解决方案虚继承class A; class B: virtual public A; //虚基类B class C: virtual public A; // 虚基类C class D: public B, public C; 虚继承后，子类中会有一个虚指针，指向一张虚基类表，通过表找到偏移量可以找到共有数据 多态多态分为编译时多态（静态多态）和运行时多态（动态多态），运算符重载和函数重载是编译时多态，派生类和虚函数是运行时多态 静态联编： 地址早绑定，编译阶段绑定好地址 动态联编： 地址晚绑定，运行时绑定号地址 多态： 父类的引用或指针 指向子类对象 class Animal { public: virtual void speak() { cout &lt;&lt; \"animal speak\" &lt;&lt; endl; } }; class Cat : public Animal { public: void speak() { cout &lt;&lt; \"cat speak\" &lt;&lt; endl; } }; // 调用dospeak，没有使用virtual时 speak函数的地址早就绑定好了，静态联编， 编译阶段确定好了地址 // 如果想使用cat的speak，那么就不能提前绑定函数的地址，所以需要运行时确定函数地址 // 动态联编，写法 dospeak 改为虚函数，在父类上声明虚函数，发生了多态 // 父类的引用或指针 指向子类对象 void doSpeak(Animal&amp; animal) { // 使用虚函数时 Animal &amp; animal = cat animal.speak(); } void test() { Cat cat; //如果发生了继承，编译器允许进行类型转换 doSpeak(cat); } 当Animal有了虚函数后，内部结构发生了改变， 内部多了一个虚指针，指向Animal的虚函数表 ,Cat内部也有一个虚指针，继承自Animal的虚指针，指向自己内部的虚函数表，父类和子类的虚函数表相同但是地址不同。如果Cat没有重写Animal的speak函数，那么虚函数表中的函数就是Animal的speak，如果重写了，那么就是Cat自身的speak Animal * animal = new Cat; animal-&gt;spead()； // 调用的是cat的speak，因为父类指针指向子类对象，指向时，子类已经发生多态，调用的也是多态后的函数 纯虚函数virtual int abc() = 0; // 告诉编译器在vtable中保留一个位置 如果父类有纯虚函数，那么子类必须实现纯虚函数 如果父类有了纯虚函数，那么父类就无法实例化对象，变成抽象类 虚析构和纯虚析构普通析构函数是不会调用子类的析构的，所以可能导致释放不干净，虚析构可以解决这个问题 纯虚析构需要声明并且实现，在类内声明，在类外实现，只声明不实现会报错，如果类出现了纯析构函数，那么这个类也算抽象类 类型转换 基类转派生类，向下转换，不安全 Animal * animal = new Animal; Cat *cat = (Cat*)animal; 派生类转基类，向上转换，安全 Cat * cat = new Cat; Animal *animal = (Animal*)cat; 如果发生了多态，总是安全的 模板int swap(int &amp;a, int &amp;b) { int tmp = a; a = b; b = tmp; } double swap(double &amp;a, double &amp;b) { int tmp = a; a = b; b = tmp; } 对于逻辑相似类型不同的函数，可以使用泛型编程—模板技术 template&lt;class T&gt; // 告诉编译器下面如果出现T，不要报错， T是一个通用类型 //template &lt;typename T&gt; class与typename 作用相同 void swap(T &amp;a, T &amp;b) { T tmp = a; a = b; b = tmp; } 模板特点： 自动类型推导，自动推导传参的数据类型到模板 swap(a, b) // 自动类型推导，按照a，b的类型来替换T 显示指定类型 swap&lt;int&gt; (a, b) 模板必须指定出T才可以使用 函数模板必须紧跟着template&lt;class T&gt; 函数模板与普通函数的区别以及调用规则 普通函数可以进行隐式类型转换，函数模板不可以进行隐式类型转换 如果函数模板与普通函数出现了重载，那么优先使用普通函数，如果没有实现，出现错误。如果想强制调用模板，可以使用空参数列表 swap&lt;&gt;(a, b); 函数模板可以发生重载 template&lt;class T&gt; swap(T a, T b, T c); 如果函数模板可以产生更好的匹配，那么调用函数模板 char a, b; swap(a, b); //调用函数模板 模板机制 编译器并不是把函数模板处理成能够处理任何类型的函数 函数模板通过具体类型产生不同的函数 编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译 模板局限性对于自定义的数据类型，使用具体化自定义数据类型解决 class Person{ int m_age; int m_name; }; template&lt;class T&gt; bool Compare(T &amp;a, T &amp;b) { if(a == b) return true; return false; } template&lt;&gt; bool Compare&lt;Person&gt;(Person &amp;a, Person&amp;b) { if(a.m_age == b.m_age) return true; return false; } 如果具体化能够优先匹配，那么就选择具体化 template&lt;&gt; 返回值 函数名&lt;具体类型&gt; (参数) 类模板template&lt;class NameType, class AgeType=int&gt; class Person{ public: Person(NameType name, AgeType age) { this-&gt;m_name = name; this-&gt;m_age = age; } NameType m_name; AgeType m_age; } 类模板不支持自动类型推导 类模板参数可以设默认值 需要指点显示类型 Person&lt;string, int&gt; p('abc', 18); 成员函数一开始不会创建出来，而是运行时才去创建 类模板做函数的参数//指定传入类型 void dowork(Person&lt;string, int&gt; &amp;p); template&lt;class T1, class T2&gt; // 参数模板化 void dowork2(Person&lt;T1, T2&gt; &amp;p); void test() { Person&lt;string, int&gt; p('ab', 18); dowork2(p); } // 整体类型化 template&lt;class T&gt; void dowork3(T &amp;p); void test() { Person&lt;string, int&gt; p('aa', 18); dowork3(p); } 类模板和继承template &lt;class T&gt; class Base{ public: T m_a; } // child 继承与base必须告诉base中的T的类型，否则T无法分配内存 class Child : public Base&lt;int&gt;{ } // childr2 也是模板类 template&lt;class T1, class T2&gt; class Child2 : public Base&lt;T2&gt;{ public: T1 m_b; } 基类如果是模板类，必须让子类告诉编译器基类中的T是什么类型，如果不告诉，那么就无法分配内存 利用参数列表class Child : public Base&lt;int&gt; 类模板类外实现成员函数template&lt;class T1, class T2&gt; class Person{ public: Person(T1 name, T2 age); T1 m_name; T2 m_age; } template&lt;class T1, class T2&gt; Person&lt;T1,T2&gt;::Person(T1 name, T2 age) { this-&gt;m_name = name; this-&gt;m_age = age; } 类模板分文件编写问题以及解决--- Person.h --- Person.cpp --- main.cpp Person.h写Person模板类的声明，Person.cpp写Person模板类的实现，在main.cpp中导入Person.h时，由于类模板的成员函数运行阶段才会去创建，所以编译器在编译时不会对Person.cpp中的方法进行创建，导致在链接时无法链接到方法。无法解析外部命令 解决方法：将类的声明和实现写到同一文件，后缀为.hpp 类模板和友元函数 友元函数类内实现跟普通类实现相同 声明时需要加上&lt;&gt;代表声明的是模板函数 template&lt;class T1, class T2&gt; class Person; // 让编译器看到Person声明 template&lt;class T1, class T2&gt; void printPerson(Person&lt;T1, T2&gt; &amp;p); // 让编译器提前看到printPerson声明 template&lt;class T1, class T2&gt; class Person{ friend void printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p); // 加上&lt;&gt;代表模板函数 public: Person(T1 name, T2 age); T1 m_name; T2 m_age; } template&lt;class T1, class T2&gt; // 友元函数类外实现 void printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p) { // ... }","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++学习笔记(二)","slug":"C-学习笔记(二)","date":"2021-05-04T06:21:25.000Z","updated":"2021-05-31T11:58:01.011Z","comments":true,"path":"/5287e3ee/","link":"","permalink":"http://orzff.cn/5287e3ee/","excerpt":"C++学习笔记(二)","text":"C++学习笔记（二）类类是对对象的抽象 对象是对类的实例 class 类名{ public: 公共权限 设置 成员属性 设置 成员函数 } 设计一个圆类，求圆的周长/* 设计一个类，求圆的周长 */ const double pi = 3.1415926535; class Circle{ //class 代表声明一个类，后面紧跟的是类的名称 public: //公共权限 // 半径 成员属性 int m_R; // 求圆周长的函数 double calZC() { // 类里面的函数，叫作成员函数 return 2 * pi * m_R; } // 设置半径的成员方法 成员函数通常可以修改成员属性 void setR(int r) { m_R = r; } }; 设计学生类class Student { public: string m_Name; // 姓名 int m_Id; // 学号 void setName(string name) { m_Name = name; } void setId(int id) { m_Id = id; } void showInfo() { cout &lt;&lt; \"姓名:\" &lt;&lt; m_Name &lt;&lt; \" 学号:\" &lt;&lt; m_Id; } }; 内联函数​ 宏函数只是简单的在编译期进行替换，所以宏函数无法对传参进行检查，也会出现歧义。内联函数是一个真正的函数，会检查函数参数列表，并返回值。内联函数在编译期也会进行替换，所以内联函数会占用空间，但是内联函数相对于普通函数的优势是省去了函数调用时的压栈，跳转和返回的开销。我们可以理解为内联函数以空间换时间。类中的成员函数默认是内联函数。 ​ 内联仅仅是给编译器的一个建议，编译器不一定会接受这种建议，如果你没有江汉数声明为内联函数，那么编译器也可能将此函数做内联编译，一个好的编译器将会内联小的、简单的函数。 函数默认参数void test(int a = 10, int b = 20, int c = 30) { cout &lt;&lt; a + b + c&lt;&lt; endl; } // 形参b设置默认值，那么后面的形参c也需要设置默认值，如果一个位置有个默认参数，那么后面的参数也必须有默认值 void test(int a, int b = 20, int c = 30) {} // 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能在设置默认参数 void test(int a = 0, int b = 0); // 声明时 void test(int a, int b) { //定义时 // ... } 占位参数void test(int a, int = 1) {} ​ 占位参数，函数调用时必需提供这个参数，但是用不到参数，可以有默认值 函数重载实现重载的条件 同一个作用域 参数个数不同 参数类型不同 参数顺序不同 当函数重载碰到默认参数时，要注意避免二义性问题 void func2(int a, int b = 10) {} void func2(int a){} 这里出现了二义性问题 引用的重载 void func(int &amp;a) {} //引用必需要合法的空间 void func(const int &amp;a) {} //const 也可以作为重载的条件 void test() { func(10); } 函数重载的原理​ 编译器为了实现重载，会用不同的参数来修饰不同的函数名，比如void func(); 编译器可能会将函数名修饰成_func，当编译器碰到void func(int x);编译器可能会将函数名修饰为_func_int，当编译器遇到void func(int x, char c);编译器可能会将函数名修改为_func_int_char。这个可能字眼是因为不同的编译器有不同的规则 extern C在C++中函数可以重载，在编译器会将函数名称偷偷改变，但是如果想调用C语言的方法时，也会将函数名改变，但是C中是没有重载的，所以编译会出错。这时使用extern可以将函数以C语言方式做链接。 extern \"C\" void show(); 也可以在C的头文件中加上 #ifdef __cplusplus extern \"C\"{ #endif void show(); #ifdef __cplusplus } #endif 封装​ 封装就是将现实中的具体的事物抽象化，把其具有的属性和操作合成一个整体，封装到一个类中。 ​ C语言使用struct来进行封装，但是在C语言中的struct不能写成员函数，属性和行为是分离的，类型检测不够，写起来比较麻烦。 ​ C++ 中的封装，严格类型转换检测，让属性和行为绑定到一起。属性和行为作为一个整体来表示生活中的事物。C++中控制权限 public公共权限、private私有权限、protect保护权限。 ​ 在C++中struct和class是一个意思，唯一的不同是默认权限，struct是public，但是class的默认权限是private。 class Animal{ void eat(); // 如果不声明权限，默认权限是private //所谓私有权限就是私有成员（属性、函数），在类内部可以访问，类外部不可以访问 public： int height; // 公共权限，在类内部和类外部都可以访问 protected: int wight; // 保护权限，类内部可以访问，（当前类的子类可以访问），类外部不可以访问 } 关键词 类内访问 类外访问 子类访问 public 可以 可以 可以 protect 可以 不可以 可以 private 可以 不可以 不可以 封装一个立方体类class Cube{ public: void setL(int l) {m_L = l;} int getL() {return m_L;} void setW(int w) {m_W = w;} int getW() const{return m_W;} //成员函数加const，代表这个成员函数没有修改成员属性 void setH(int h) {m_H = h;} int getH() {return m_H;} void getCubeS() { cout &lt;&lt; \"立方体面积为:\" &lt;&lt; 2 * m_L*m_W + 2 * m_W * m_H + 2 * m_L * m_H &lt;&lt; endl; } void getCubeV() { cout &lt;&lt; \"立方体体积:\" &lt;&lt; m_L * m_W * m_H &lt;&lt; endl; } //成员函数判断是否相等 bool compareCubeByClass(Cube &amp; cube) { //... } private: int m_L; int m_W; int m_H; }; // 传入参数如果加了const，那么只能调用const方法 bool compareCube(Cube &amp; cub1, Cube &amp; cub2) { // ... } 对象的构造和析构构造函数没有返回值，没有void，类名相同，可以发生重载，可以有参数 析构函数写法，与类名相同，类名前面加上一个符号 ~ ,也没有返回值，不写void，不可以有参数（不能发生重载） class Person { public: // 构造函数写法，与类名相同，没有返回值，可以发生重载（可以有参数） // 构造函数由编译器自动调用，而不是手动，而且只会调用一次 Person() { cout &lt;&lt; \"构造函数\" &lt;&lt; endl; } // 析构函数写法，与类名相同，类名前面加上一个符号 ~ ,也没有返回值，不写void，不可以有参数（不能发生重载） // 自动调用，只会调用一次 ~Person(){ cout &lt;&lt; \"析构函数\" &lt;&lt; endl; } }; void test() { Person p1; //默认调用构造和析构，是系统提供的两个空函数 } 构造函数的分类及调用按照参数进行分类 分为无参构造函数，有参构造函数 按照类型进行分类 分为普通构造函数，拷贝构造函数 无参构造写法和调用 Person p1; 注意不能写成Person p1(), 因为编译器认为这个是函数声明 有参构造写法和调用 Person p2(10)或者 Person p2 = Person(10) Person(10)匿名对象，执行当前行后就会释放这个对象 拷贝构造函数 Person(const Person &amp;p) Person p1(p2) 或者 Person p1 = Person(p2) 不能用拷贝构造函数初始化匿名对象 如果写成 Person (p1) 这种写法等价于 Person p1 写到右值可以做拷贝构造函数 Person p = 100 ,隐式类型转换，相当于调用 Person=Person(100) class Person { public: // 构造和析构必须写在public下 Person() { // 默认 无参构造函数 cout &lt;&lt; \"构造\"; } Person(int a) { //有参构造函数 cout &lt;&lt; a &lt;&lt; endl; } Person(const Person&amp; p) { // 拷贝函数 cout &lt;&lt; \"拷贝函数\" &lt;&lt; endl; } ~Person() { cout &lt;&lt; \"析构函数调用\" &lt;&lt; endl; } }; int main() { Person p3; //默认构造函数不加(),加（），编译器认为这是函数的声明 Person(100); // 叫匿名对象，匿名对象特定，如果编译器发现了对象是匿名对象，那么这行执行完，就执行析构函数 Person p1 = Person(100); // 这时声明了一个匿名对象并将其命名为p1 Person(p1); // 不能用拷贝构造来初始化匿名对象 Person p4 = Person(p3); //如果写成左值，编译器认为你写Person p4,对象的声明，如果写成右值，那么可以 Person p6 = 100; //相当于调用了Person p7 = Person(100)， 隐式类型转换 return 0; } 拷贝构造调用的时机 用已经创建好的对象来初始化新的对象 以值传递的方式给函数参数传值 void dowork(Person p1) {}// Person p1 = Person(p) 以值的方式返回局部对象 void dowork2() { Person p1; return p1; } void test() { Person p = dowork2(); } 构造函数调用规则系统默认给一个类提供3个函数，默认构造、拷贝构造、析构函数 当提供了有参构造函数，那么系统就不会给我们提供默认构造函数，但是系统还会提供默认拷贝构造函数 当我们提供了 拷贝构造，那么系统就不会提供其他构造了 深拷贝和浅拷贝类在进行指针类型的拷贝时，浅拷贝只是简单的复制堆区地址，会导致重复释放内存的异常，而深拷贝是重新开辟一片内存空间。 Person(const Person &amp;p) { m_age = p.m_age; m_name = (char*)malloc(strlen(p.m_name)+1); strcpy(n_name, p.m_name) } //析构函数 ~Person(){ if(m_name != NULL) { free(m_name); m_name = NULL; } } 初始化列表构造函数后面 +: 属性(参数),属性(参数) … //利用初始化列表初始化数据 Person(int a,int b,int c): m_a(a), m_b(b), m_c(c) {} 类对象作为成员构造时，类中的类成员先执行构造函数，类自身在执行构造。析构相反 explicit防止隐式类型转换 new 和delete new在堆区开辟空间 所有new出来的对象，都会返回该类型的指针，malloc返回void *使用时需要强转 malloc不会调用构造函数，new会调用 new是运算符，malloc是系统的一个函数 delete也是运算符，配合new使用，malloc与free配合使用 使用void *来接收new出来的指针，会出现释放问题 new会调用默认构造函数 new申请内存是无需指定内存块大小，malloc需要 Person *pa = new Person[10]; delete [] pa; // new 数组时需要有默认构造函数 // delete 数组时需要加[] // new 的时候加[], 那么delete时加上，new的时候不加，那么delete时也不加","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"C++学习笔记(一)","slug":"C-学习笔记(一)","date":"2021-05-02T06:54:52.000Z","updated":"2021-05-31T11:58:00.996Z","comments":true,"path":"/b34cf332/","link":"","permalink":"http://orzff.cn/b34cf332/","excerpt":"C++学习笔记(一)","text":"C++ 学习笔记（一）双冒号运算符作用域运算符 ::全局作用域 int a = 200; void test() { int a = 100; cout &lt;&lt; a &lt;&lt; endl; // 输出 100 cout &lt;&lt; ::a &lt;&lt; endl; //输出200 std::cout &lt;&lt; \"nihao\"; //::前面加std则是说明cout是std作用域下的 } namespace的使用namespace命名空间主要用于解决命名冲突 命名空间下可以放函数、变量、结构体、类 命名空间必须定义在全局作用域下 命名空间可以检讨命名空间 命名空间是开放的，可以随时往原先的命名空间添加内容 一个命名空间分开写会自动合并 命名空间可以匿名，匿名命名空间内的变量相当于static 命名空间可以起别名 using 声明和using 编译using 声明使用using声明时要避免二义性问题， namespace KG{ int sunwukongId = 10; } void test() { int sumwukongId = 20; using KG::sunwukongId; // 写了using 声明后，说明以后的所有sunwukongId都是KG下的， // 但是编译器又有就近原则，这就造成了二义性 cout &lt;&lt; sunwukongId &lt;&lt; endl; } using 编译void test2() { int sunwukongId = 20; using namespace KG; //打开命名空间KG，可以执行 cout &lt;&lt; sunwukongId &lt;&lt; endl; } C++对C的增强全局变量检测增强//全局变量中 int a; int a = 10; //在C语言中可以通过编译 //在C++中不能通过编译 函数检测增强// 函数 参数类型增强 int getRecS(w, h) { // 无返回值可以通过C编译不能通过C++编译 } // 在C中可以通过编译 // 在C++中不可以通过编译 //参数检测增强 void test02() { getRecS(10, 10, 10)； } 类型转换检测增强void test03() { char *p = malloc(sizeof(64)); //malloc返回值是void* } // C可以通过编译，因为C认为void*是一个万能指针，可以转换成char*， // 而C++不行，C++ 版本须为 // char *p = (char*)malloc(sizeof(64)); struct增强struct Person{ int m_Age; void plusAge(); // C中struct不能加函数，C++可以 } void test04() { struct Person p1; // C语言必须加上struct } bool类型增强// C中没有bool类型，在C++中bool类型 非0的值都是1 三目运算符增强void test05() { int a = 10; int b = 20; printf(\"%d\\n\", a &gt; b ? a : b); a &gt; b ? a : b = 100; // 三目运算符，C语言中返回值，C++返回的是变量 // C语言模仿C++写法 // *(a &gt; b ? &amp;a : &amp;b) = 100 } const增强const int m_A = 10; //全局const，在C和C++中都不能修改 void test07() { const int m_B = 20; //C中伪常量，C++中真常量 int *p = (int*)&amp;m_B; printf(\"%d\\n\", *p); // 在C中const的作用仅仅是不允许修改，但是可以通过指针来修改 // 在C++中通过指针修改的仅仅是*p, 而m_B并没有变 // int arr[m_B] 在C中不能来定义数组，在C++中可以 } C语言中，const修饰的变量，是伪常量，编译器是会分配内存的，只要分配内存就可以更改 C++中，const不会分配内存，在C++中int *p = (int*)&amp;m_B的*p指向的是编译器临时开辟的一块内存空间 const在C中默认是外部外部链接，在其他文件中使用extern可以找到变量，而在C++中则是默认内部链接 const分配内存，取地址会分配临时内存，使用extern时编译器也会给const变量分配内存，用普通变量初始化const变量也会给const分配内存 int a = 10; const int b = a; //会分配内存 自定义数据类型，加const也会分配内存 struct Person{ string m_Name; int m_Age; } void test() { const Person p1; // 分配了内存 Person *p = (Person*)&amp;p1; p-&gt;m_Name = \"abc\"; (*p).m_Age = 18; } const和define区别总结 1. const 有类型，可进行编译器类型安全检查，#define五类性，不可进行检查 2. const 有作用域，而#define 不重视作用域，默认定义处到文件结尾，如果定义在指定作用域下有效的常量，那么#define就 不能用，#define可以用undef 来结束作用周期 引用引用是C++对C的重要扩充。在C/C++中指针的作用基本都是一样的，但是C++增加了另一种给函数传递地址的途径，这就是按引用传递，他也存在与其他一些编程语言中，并不是C++的发明。 变量名实质上是一段连续内存的别名，是一个标号（门牌号） 程序中通过变量来申请并命名内存空间 通过变量的名字可以使用存储空间 int a = 10; int &amp;b = a; b = 200;//修改b时，a也会修改 引用引用使用格式：type &amp;别名=原名 引用 就是起别名，这里a的b都指向同一片地址空间，&amp;写到左侧叫引用，写到右侧是取地址。 引用必须初始化，引用初始化后不可以修改 void test() { //int &amp;a;//编译不通过 int a = 10; int &amp;b = a; //引用初始化后不可以修改 int c = 20; b = c;//这里是把c的值赋给b，而不是b引用c，初始化后不可以修改 } 对数组建立引用 void test() { int arr[10]; for (int i = 0; i &lt; 10; i ++) arr[i] = i; int (&amp;parr[i])[10] = arr; for (int i = 0; i &lt; 10; i ++) { cout &lt;&lt; parr[i]; } } 参数传递// 值传递，直接传递a，b的值，不更改a与b的值 void swap1(int a, int b){ int tmp = a; a = b; b = tmp; } // 指针传递，传递a，b的指针，更改a，b的值 void swap2(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } //引用传递，类似传递地址，相当于int &amp;a = a，可以通过引用改变a，b的值 void swap3(int &amp;a, int &amp;b) { int tmp = a; a = b; b = tmp; } void test() { int a = 10, b = 20; swap1(a, b); swap2(&amp;a, &amp;b); swap3(a, b); } 引用注意事项 引用必需引一块合法的内存空间 void test() { int &amp;a = 10;//引用必需引一块合法的内存空间 } 不要返回局部变量的引用 int &amp;dowork() { int a = 10; return a; } int&amp; work2() { static int a = 10; return a; } void test() { int &amp;ret = dowork(); // 局部引用已经销毁，数据不准确 dowork2() = 1000; // 如果函数的返回值引用，那么这个函数调用可以作为左值， //相当于写了a=1000 } 引用的本质引用的本质在C++内部实现是一个指针常量 指针的引用struct Person{ int m_age; } // 通过指针给对对象分配内存 void allocat(Person **p) { *p = (Person *)malloc(sizeof(Person)); (*p)-&gt;m_age = 100; } void test01() { Person *p = NULL; allocat(&amp;p); } // 利用指针引用开辟空间 void allocat(Person* &amp;p) { p = (Person*)malloc(sizeof(Person)); p-&gt;m_age = 100; } void test02() { Person *p = NULL; allocat(p); } 常量引用void test() { int &amp;ref = 10; // 引用了不合法的内存，不可以 const int &amp;ref = 10; //加入const后，编译器处理方式为 // int tmp = 10; const int &amp;ref = tmp; // 常量引用ref可以通过指针来修改 int *p = (int*)&amp;ref; *p = 1000; } 常量引用使用场景，通常用来修饰形参 void showValue(const int &amp;val) { //如果只是想展示内容，而不修改内容，那么就用const来修饰这个形参 } 483","categories":[{"name":"C++ 学习","slug":"C-学习","permalink":"http://orzff.cn/categories/C-%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++ 学习笔记","slug":"C-学习笔记","permalink":"http://orzff.cn/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Qt无法输入中文","slug":"Qt无法输入中文","date":"2021-04-29T06:13:29.000Z","updated":"2021-05-31T11:58:01.150Z","comments":true,"path":"/20641ee8/","link":"","permalink":"http://orzff.cn/20641ee8/","excerpt":"Qt无法输入中文","text":"安装fcitx-frontend-qt5sudo apt-get install fcitx-frontend-qt51 查看`fcitx-frontend-qt5的安装目录。 dpkg -L fcitx-frontend-qt5 一般是这个 /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so 复制到安装目录我安装的是QT6 sudo cp libfcitxplatforminputcontextplugin.so {QT安装目录}/6.0.3/gcc_64/plugins/platforminputcontexts sudo cp libfcitxplatforminputcontextplugin.so {QT安装目录}Tools/QtCreator/lib/Qt/plugins/platforminputcontexts","categories":[{"name":"报错处理","slug":"报错处理","permalink":"http://orzff.cn/categories/%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://orzff.cn/tags/QT/"}]},{"title":"VI和VIM基本操作","slug":"VI和VIM基本操作","date":"2021-04-28T16:21:54.000Z","updated":"2021-05-31T11:58:01.150Z","comments":true,"path":"/a67e3062/","link":"","permalink":"http://orzff.cn/a67e3062/","excerpt":"VI和VIM基本操作","text":"Vi和Vim 基本操作Vi的插入 按键 功能 a 光标位置右边插入文字 i 光标位置当前处插入文字 o 光标位置下方开启新行 O 光标位置上方开启新行 I 光标所在行首插入文字 A 光标所在行尾插入文字 Vi 的退出 按键 功能 ZZ(shift+z+z) 保存退出 :wq 保存退出 :x 保存退出 :w filename 保存在指定文件 :q 退出，如果文件修改但没有保存，会提示无法退出 :q! 退出，不保存 :!命令 暂时离开vi，执行命令 Vi的删除和修改功能 按键 功能 [n]x 删除光标后n的字符 [n]X 删除光标前n的字符 D 删除光标所在开始到此行尾的字符 [n]dd 删除从当前行开始的n行（准确来说，是剪切，剪切不粘贴即为删除） [n]yy 复制从当前行开始的n行，向下复制 p 把粘贴板上的内容插入到当前行 dG 删除光标所在开始到文件尾的所有字符 J 合并两行，将光标所在行和下一行进行合并，在两行中间加入一个空格 . 执行上一次的操作 u 撤销前一个命令 Vi的行定位功能 按键 功能 ctrl+f 向前滚动一个屏幕 ctrl+b 向后滚动一个屏幕 gg 到文件第一行行首 G 到文件最后一行行首，G必需大写 :$ 到文件最后一行（行首） mG或mgg 到指定行，m为目标行数 /内容 查找指定内容 Vi的文本查找功能 按键 功能 /字符串 查找指定字符串 n 寻找下一个 N 回到前一个 ? 查找上一个 /^字符串 查找以字符串开始的行 /字符串$ 查找以字符串结尾的行 /a.b 查找字符串a任意字符b Vi的替换功能 按键 功能 r 替换当前光标字符 :r 文件名 在光标当前位置下一行载入另一个文件 :s/p1/p2/g 将当前行中所有p1均用p2替代 :g/p1/s//p2/g 将文件中所有p1均用p2替代 :n1,n2 s/p1/p2/g 将n1到n2行中所有p1用p2替代 Vi的set指令 按键 功能 :set ic 搜寻是忽略大小写 :set noic 搜寻是不忽略大小写 :set nu 显示行号 :set nonu 不显示行号","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://orzff.cn/tags/Vim/"}]},{"title":"Linux系统管理","slug":"Linux系统管理","date":"2021-04-27T14:51:51.000Z","updated":"2021-05-31T11:58:01.149Z","comments":true,"path":"/6c72ecbc/","link":"","permalink":"http://orzff.cn/6c72ecbc/","excerpt":"Linux系统管理","text":"Linux系统管理日历 calcal命令用户查看当前日历，-y显示整年日历 显示或设置时间date设置时间格式 date [MMDDhhmm[CC]YY][.ss] + format CC为年的前两位yy为年的后两位，前两为的mm为月，后两位的mm为分钟，dd为天，hh为小时，ss为秒 查看进程信息 ps进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元， ps命令可以查看进程的详细状况，常用选项（选项可以不加-） 进程 含义 -a 显示终端上所有进程，包括其他用户的进程 -u 显示进程的详细状态 -x 显示没有控制终端的进程 -w 显示加宽，一边显示更多的信息 -r 只显示正在运行的进程 动态显示进程 toptop命令用来动态显示运行中的进程，top命令能够在运行后，在指定时间间隔更新显示信息，可以在使用top命令时加上-d&lt;interval&gt;来指定显示信息更新时间间隔。 在top命令执行后，可以按下按年得到对显示结果进行排序 按键 含义 M 根据内存使用量来排序 P 根据CPU占有率来排序 T 根据进程运行时间的长短来排序 U 可以根据后面输入的用户名来筛选进程 K 可以根据后面输入的PID来杀死进程 结束进程 KILLkill命令指定进程号的进程，需要配合ps使用 kill [-signal] pid 信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。 后台程序 &amp;、jobs、fg 用户可以将一个前台执行的程序调入后台执行，方法为：命令 &amp; 如果程序已经在执行，ctrl+z可以 将程序调入后台 jobs查看后台运行程序 fg编号（编号为通过jobs查看的编号），将后台运行程序调出到前台 关机重启 reboot、shutdown、init 命令 含义 reboot 重新启动操作系统 shutdown -r now 重新启动操作系统，shutdown会给别的用户提示 shutdown -h now 立刻关机，其中now相当于时间为0的状态 shutdown -h 20：25 系统在今天20：25会关机 shutdown -h +10 系统再过十分钟会自动关机 init 0 关机 init 6 重启 字符界面和图形界面切换在redhat平台下，可通过命令进行切换 init 3 ： 切换到字符界面 init 5 ： 切换到图形界面 通过快捷键切换（适用于大部分平台） Ctrl+Alt+F2 切换到字符界面 Ctrl+Alt+F7 切换到图形界面 检测磁盘空间 dfdf命令用户检测文件系统的磁盘空间占用和空余情况，可以显示所有文件系统对节点和磁盘块的使用情况。 选项 含义 -a 显示所有文件系统的磁盘使用情况 -m 以1024字节为单位显示 -t &lt;fs&gt; 显示各指定文件系统的磁盘空间使用情况 -T 显示文件系统 ## 格式化 `mkfs` mkfs命令相当于DOS/WINDOWS系统中的格式化命令，用户创建指定的文件系统 mkfs [选项] 设备文件名 [blocks] 选项 含义 -V 详细显示模式 -t &lt;.fs&gt; 指定文件系统类型，默认值为ext2 -c 在创建文件系统的同时，进行磁盘坏块检查 blocks 文件系统块的大小 应用软件安装和卸载在Linux系统中，几乎所有的软件均通过RPM进行安装、卸载及关机等操作。 rpm [选项] [软件包名] 选项 含义 -i 指定安装的软件包 -h 使用#显示详细的安装过程和进度 -v 显示安装的详细信息 -q 查询系统是否已安装指定的软件包 -a 查看系统以安装的所有软件包 -e 卸载软件包 -nodeps 配合-e参数使用，强制卸载不检查依赖项 -force 强制操作，如强制安装删除等 查看或配置网卡信息 ifconfig如果，我们只是敲ifconfig，它会显示所有网卡的信息 显示字段 说明 eh0 网络接口名称 Link encap 链路封装协议 Hwaddr 网络接口的MAC地址 Inet addr IP地址 Bcast 广播地址 Mask 子网掩码 UP 网络接口状态标识，UP已经启用，DOWN已经停用 BROADCAST 广播协议，表示网络接口是否支持广播 RUNNING 传播协议，表示网络接口是否已经开始传输分组数据 MULTICAST 多播协议，表示网络接口是否支持多播 MTU,Metric MTU最大传输单位，单位：字节，Metric度量值，用于RIP建立 RX bytes 接受数据字节统计 TX bytes 发送数据字节统计 测试远程主机连通性 ping ping通过ICMP协议向远程主机发送ECHO_REQUEST请求，期望主机回复ECHO_REPLY消息 通过ping命令可以检查是否与远程主机建立了TCP/IP连接 网络路由设置 routeroute可以增加、修改、显示路由信息 route [-v] [-A family] add default [gw 默认网关地址] [[dev interface]] 监控网络状态 netstatnetstat命令监控网络状态，包括接口设置、`IP路由、各种网络协议的统计","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux 系统管理","slug":"Linux-系统管理","permalink":"http://orzff.cn/tags/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"}]},{"title":"Linux用户权限","slug":"Linux用户权限","date":"2021-04-27T13:53:40.000Z","updated":"2021-05-31T11:58:01.148Z","comments":true,"path":"/e7492e71/","link":"","permalink":"http://orzff.cn/e7492e71/","excerpt":"Linux用户权限","text":"Linux 用户权限用户查看当前用户whoamiwhoami该命令用户查看当前系统帐号的用户名，可通过cat /etc/passwd查看系统用户信息。 由于系统管理员通常需要使用多种身份登录系统，例如通常使用普通用户登录系统，然后再以su命令切换到root身份对传统进行管理，这时就可以使用whoami来查看当前用户身份。 查看登录用户 whowho命令用户查看当前所有登录系统的用户信息 常用选项 选项 含义 -m或am I 只显示运行who的用户名，登录终端和登录时间 -q或--count 只显示用户的登录帐号和登录用户的数量 -u 在登录时间后显示该用户最后一次操作到当前时间的时间间隔 -u或--heading 显示列标题 查看登录用户 ww命令也可以查看登录当前系统的用户信息，与who命令相比，w命令的功能更强大，它不但可以显示当前有哪些用户登录到系统，还可以显示这些用户正在进行的操作，并给出更加详细和科学的统计数据。 w [选项] [用户名] 如果w命令携带用户名，则只显示指定用户的信息，否则显示当前所有登录用户的信息。 常用选项 选项 含义 -h 只显示运行who命令的用户名、登录终端和登录时间 -l 显示详细信息列表，此为预设值 -s 使用短列表，不显示用户登录时间、JCPU和PCPU时间 -u 忽略执行程序的程序，以及程序的PCPU时间 推出登录账户 exit 如果是图形界面，推出当前终端 如果是使用ssh远程登录，推出登录帐号 如果是切换后的登录用户，退场则返回上一个登录帐号 切换用户 su可以通过su命令切换用户，su后面可以加-，su和su -命令不同之处在与，su -切换到对应的用户会将当前的工作目录自动切换到切换后用户主目录。 添加、删除组帐号：groupadd、groupdel groupadd新建组帐号 groupdel删除组帐号 cat /etc/group 查看用户组 创建工作组： groupadd 组名 删除工作组： groupdel 组名 注意： 需要切换到 root用户 修改组 usermodusermod -g 用户组 用户名 修改用户所在组：usermod -g 组名 用户名 添加用户帐号 useradd在Unix/Linux中添加用户帐号可以使用adduser或useradd命令，因为adduser命令是指向useradd命令的一个链接，因此，这两个命令的使用格式完全一样。 useradd [参数] 新建用户帐号 参数 含义 -d &lt;dirname&gt; 指定用户登录系统时的主目录，如果不使用该参数，系统自动在/home目录下建立与用户名同名目录为主目录 -m 自动建立目录 -g 指定组名称 修改文件权限 chmodchmod修改文件权限有两种使用格式：字母法和数字法 字母法：chmod u/g/o/a +/-/= rwx 文件 u/g/o/a 含义 u user表示该文件所有者 g group表示与该文件的所有者属于同一组（group）者，及用户组 o other表示其他以外的人 a all表示这三者皆是 +-= 含义 + 增加权限 - 撤销权限 = 设定权限 rwx 含义 r read表示可读取，对于一个目录，如果没有r权限，那么就意味这不能通过ls查看这个目录的内容 w wriet表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新文件 x excute表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录 数字法： rwx 这些权限可以用数字代替 r: 读取权限，数字代号为 4 w：写入权限，数字代号为 2 x：执行权限，数字代号为 1 chmod 741 file -R （-R 代表递归给目录加上相同的权限） 修改文件所有者 chownchown 用户名 文件或目录名 修改文件所属组 chgrpchgrp 用户组名 文件或目录名","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"用户权限","slug":"用户权限","permalink":"http://orzff.cn/tags/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/"}]},{"title":"Linux 命令","slug":"Linux-命令","date":"2021-04-27T08:24:09.000Z","updated":"2021-05-31T11:58:01.147Z","comments":true,"path":"/9da1ef6b/","link":"","permalink":"http://orzff.cn/9da1ef6b/","excerpt":"Linux 命令","text":"Linux命令格式：命令 选项 参数 通配符 通配符 含义 * 匹配任意多个字符 ? 匹配任意一个字符 [] [和]将字符组扩起来，表示可以匹配字符组中任意一个，-用户表示字符范围 [abc] 匹配a、b、c中任意一个 [a-z] 匹配从a到z范围内任意一个字符 \\ 转义字符，将通配字符转义成普通字符 查看文档命令 --help man 命令 快捷键 快捷键 含义 tab 智能补全，如果没有重复的选项 ，自动补全，如果有重复项，按下两个tab，显示列表 ⬆ ⬇ 历史记录 常用命令 指令 命令 打开终端 ctrl+alt+t 在终端中锁定 ctrl+c 清屏 ctrl+l 查看文件 ls 指令 命令 查看文件 ls 查看隐藏文件 ls -a 查看文件详细信息 ls -l 配合-l以人性化方式显示文件大小 ls -lh 输出重定向 指令 含义 &gt; 输出重定西会覆盖原来的内容 &gt;&gt; 输出重定向则会追加到文件的尾部 man 功能键 功能键 功能 空格 显示手册下一屏 Enter 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 推出man命令 h 列出所有功能键 /word 搜索word字符串 创建目录 mkdirmkdir 目录名 -p 递归创建 通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。 删除文件 rmrm 文件 rmdir 删除文件夹 rmkdir 目录名 目录一定是空的 可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能回恢复。为了放置文件误删，可以在rm后使用-i参数一逐个确认要删除的文件。 参数 含义 -i 已进行交互方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹是必需加此参数 建立链接文件 lnln 源文件 链接文件 硬链接 ln -s 源文件 链接文件 软链接 软链接文件不占磁盘空间，但是删除源文件会影响软链接文件 硬链接文件站磁盘空间，但是删除源文件不会影响硬链接文件 硬链接和复制的区别，无论你修改了哪一个链接之后的文件，另一个会改变，但拷贝不会 文本搜索 grepgrep [-选项] ’搜索内容串‘ 文件名 常见选项 选项 含义 -v 显示不包括匹配文本的所有行（相当与求反） -n 显示匹配行以及行号 -i 忽略大小写 grep后的搜索规则也可以是正则表达式 通配符 含义 ^a 以a为起始的字符搜索文件 a$ 以a为结尾的字符搜索文件 . 匹配任意一个非换行的字符 * 匹配任意字符（大于0的整数） 计算文件的行数与字数 wc wc [-选项] 文件名 选项 含义 -l 统计行数 -w 统计字数，一个字被定义为有空白、跳格或换行的字符分隔的字符串 -c 统计字节数 -m 统计字符数，这个标志不能与-c标识一起使用 文件搜索 find在特定目录下搜索符合条件的文件也可以用来搜索特定用户属主的文件 find 目录 参数 文件名（可以使用通配符） -name 文件名 -size 大小 -perm 权限 常见用法： 命令 含义 find ./ -name test.sh 查找当前目录下所有名为test.sh的文件 find ./ -name '*.sh' 查找当前目录下所有后缀为.sh的文件 find ./ -name \"[A-Z]*\" 查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M 查找在/tmp目录下等于2M的文件 find /tmp -size +2M 查找在/tmp目录下大于2M的文件 find /tmp -size -2M 查找在/tmp目录下小于2M的文件 find ./ -size +4k -size -5M 查找当前目录下大于4k小于5k的文件 find ../ -perm 0777 查找当前目录下权限为777的文件或目录 拷贝 cpcp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS中的copy命令。 常见选项 选项 含义 -a 该选项通常在复制目录时使用，她保留链接、文件属性，并递归的复制目录，简单而言，保持文件与原有属性。 -f 删除已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录或文件，目标文件必须为一个目录名 -v 显示拷贝进度 移动 mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。 常用选项 选项 含义 -f 禁止交互式操作，如有覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件 -v 显示移动进度 获取文件类型 filelinux系统文件类型不是根据文件扩展名分类的，通过file命令可以确认文件具体类型。 归档管理 tar计算机的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。 tar [参数] 打包文件名 文件 归档： tar -cvf 归档文件名.tar 文件1 文件2 目录1 目录2 解归档：tar -xvf 归档文件名.tar 路径 tar命令很特殊，其参数前面可以使用-，也可以不使用 文件压缩解压gzip tar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz gzip [选项] 被压缩文件 压缩： gzip 归档文件名.tar 生成一个文件 归档文件名.tar.gz 文件大小小于归档文件大小[归档文件名.tar] 不存在了 解压缩： gzip -d 归档文件名.tar.gz 生成一个文件 归档文件名.tar 一步归档压缩： tar -czvf 文件名.tar.gz 文件1 文件2 目录1 目录2 一步解归档压缩： tar -xzvf 文件名.tar.gz -C 路径 常用选项 选项 含义 -d 解压 -r 压缩所有子目录 bzip2一步归档压缩： tar -cjvf 文件名.tar.bz2 文件1 文件2 目录1 目录2 一步解归档压缩： tar -xjvf 文件名.tar.bz2 -C 路径 zip,unzip一步归档压缩： zip [-r] 目标文件（没有扩展名） 源文件 zip 文件名 文件1 文件2 目录1 目录2 生成一个文件为： 文件.zip 一步解归档压缩： unzip -d 解压后目录文件 压缩文件 unzip 文件名.zip -C 路径 查看命令位置 whichwhich ls 管道一个命令的输出可以通过管道作为另一个命令的输入。","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux 命令","slug":"Linux-命令","permalink":"http://orzff.cn/tags/Linux-%E5%91%BD%E4%BB%A4/"}]},{"title":"Linux 目录和文件","slug":"Linux-目录和文件","date":"2021-04-27T08:23:54.000Z","updated":"2021-05-31T11:58:01.148Z","comments":true,"path":"/920965dc/","link":"","permalink":"http://orzff.cn/920965dc/","excerpt":"Linux 目录和文件","text":"Linux 目录与文件目录与路径[绝对路径]文件位置： windows: 盘符:\\文件夹\\文件 linux: /home/文件夹/0612/day01/a [相对路径]当前目录所在位置0612 ./day01/a .代表当前目录 .. 上一级文件夹 目录创建规则 长度不超过256 不能包含特殊字符 见名知意 Linux 目录结构 /: 根目录，一般根目录下只存放目录，在linux下有且只有一个根目录。 /bin,/usr/bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。 /boot: 放置linux系统启动是用到的一些文件，如Linux的内核文件 /boot/vmlinuz，系统引导管理器:/boot/grub。 /dev: 放置linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/chrom/mnt。 /etc:系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d/、/etc/X11、/etc/sysconfig、/etc/xinetd.d。 /home:系统默认的用户家目录，新增用户帐号时，用户的家目录都存放在此目录，~表示当前用户的家目录，~edu表示用户edu的家目录。 /lib、/usr/lib、/usr/local/lib:系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。 /lost+fount:系统异常产生错误时，会将一些遗失的片段放置与此目录下。 /mnt、/media:光盘默认挂载点，通常光盘挂载与/mnt/chrom下，也不一定，可以选择任意位置挂载。 /opt:给主机额外安装软件所摆放的目录。 /proc:此目录的数据都在内存中，如系统核心、外部设备、网络状态，由于数据都存放在内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等。 /root:系统管理员root的家目录。 /sbin、/usr/bin、/usr/local/sbin:放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等，与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能查看而不能设置和使用。 /tmp: 一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要的数据不可放置在此目录下。 文件计算机中一切皆文件 在windows中区分文件通过扩展名区分文件，在linux中通过颜色区分也可以通过命令区分 file 文件名 文件分类 普通文件 目录文件 设备文件 字符设备文件 块设备文件 管道文件 链接文件 文件权限读[r]， 写[w]，执行[x] d rwx rwx rwx 目录 文件所属用户 文件所属组 其他用户","categories":[{"name":"Linux 学习笔记","slug":"Linux-学习笔记","permalink":"http://orzff.cn/categories/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux目录文件","slug":"Linux目录文件","permalink":"http://orzff.cn/tags/Linux%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6/"}]},{"title":"vultr+cloudflare","slug":"vultr-cloudflare","date":"2021-03-03T15:42:11.000Z","updated":"2021-05-31T11:58:01.167Z","comments":true,"path":"/4e01c297/","link":"","permalink":"http://orzff.cn/4e01c297/","excerpt":"vultr+cloudflare","text":"申请免费域名+ cloudflare 托管域名：申请免费域名+域名托管 注意freenom 申请到的域名设置DNS只需要设置cloudflare的解析得到的dns，不需要设置80.80.80.80 cloudflare 解析时使用的ip是VPS服务器的ip VPS 搭建服务器搭建 Trojan 服务器搭建Trojan服务器 centos8以上的不需要升级内核，内核升级可能造成服务器无法启动， 搭建 Vless服务器（推荐）搭建 Vless服务器](http://luyiminggonnabeok.cn/2020/10/13/Vless-ws-tls一键脚本教程/)) BBR加速bbr加速","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"飞机","slug":"飞机","permalink":"http://orzff.cn/tags/%E9%A3%9E%E6%9C%BA/"}]},{"title":"Django与mysql相连","slug":"Django与mysql相连","date":"2020-12-27T08:55:14.000Z","updated":"2021-05-31T11:58:01.146Z","comments":true,"path":"/3a7fd0d4/","link":"","permalink":"http://orzff.cn/3a7fd0d4/","excerpt":"Django与mysql相连","text":"Django与mysql相连Django链接数据库在项目根setting.py中更改默认配置 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'test', 'USER': 'root', 'PASSWORD': '****', 'HOST': '****', 'PORT': '3306' } } ENGINE 用于特定的数据库引擎的配置，一般选项如下 django.db.backends.sqlite3 django.db.backends.postgresql django.db.backends.mysql django.db.backends.oracle NAME:要连接的数据库名称的配置USER:配置连接数据库的用户账号PASSWORD:配置连接数据库的登录密码HOST:配置数据库所在的主机IP地址 PORT:配置连接数据库的端口号CHARSET:配置连接数据库交互数据编码格式 创建模型Django项目中定义模型数据，其实就是定义class类型，通过类型创建的对象来封装管理数据，一定要在这里明确关联和对应关系 程序 数据库 class类型 table 表格 attr属性 field字段 object对象 record记录 模型中的属性与数据库中的字段对应 对象中的属性类型定义 表中的字段类型 AutoField() auto_increment 自动增长 BOoleanField() bool 布尔类型 NullNooleanField() bool or null 扩展布尔类型 CharField() varchar 字符串 TextField() text 长文本 IntegerField() int 整数 DecimalField() double 双精度 FloatField() float 单精度 DateField() date 日期 TimeField() time 时间 DateTimeField() datetime 日期时间 FileField() blob 二进制 ImageField() bolb二进制 每个字段定义时，都有自己的一些特殊选项指定 选项 描述 null 如果为True，将NULL空值存储到数据库中，默认False blank 如果为True，表示该字段允许存储空值，默认False db_column 字段名称，如果不指定，直接使用类型属性的名称作为字段名称 db_index 如果设置为True，表示个当前字段添加索引支持 default 给字段默认值 primary_key 是否设置当前字段为主键 unique 如果为True，该字段储存的值必须时唯一的 在大部分项目汇总，还会涉及到多表关联 选项 描述 ForeignKey 一对一关联，该字段定义在多个一方 ManToManyField 多对多关联关系，该字段两方都需要定义 OneToOneField 一对一关联，该字段可以定义在任意一方 项目结构 ├── backend │ ├── __init__.py │ ├── admin.py │ ├── migrations │ │ └── __init__.py │ ├── models.py │ ├── tests.py │ └── views.py ├── manage.py └── ulb_manager ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py 在根目录的setting.py中添加 INSTALLED_APPS = [ ///... 'backend', ] 修改backend/models.py from django.db import models # Create your models here. class User(models.Model): id = models.AutoField(primary_key = True) account = models.CharField(max_length=20) password = models.CharField(max_length=20) def __str__(self): # 表中每条数据显示账号 return u'account: %s' % self.account class Class(models.Model): id = models.AutoField(primary_key = True) name = models.CharField(max_length=20) model中定义两个类，代表两个表User，Class， 创建两个表 python manage.py makemigrations 同步到mysql python manage.py migrate 这时在mysql中可以看到新增加的表 mysql&gt; show tables; +----------------------------+ | Tables_in_test | +----------------------------+ | auth_group | | auth_group_permissions | | auth_permission | | auth_user | | auth_user_groups | | auth_user_user_permissions | | backend_class | | backend_user | | django_admin_log | | django_content_type | | django_migrations | | django_session | | user | +----------------------------+ 后台显示数据库在backend/admin.py中注册模型 from django.contrib import admin from .models import * # Register your models here. admin.site.register(User) admin.site.register(Class) 运行django python manage.py runserver 8888 在http://127.0.0.1:8888/admin/中可以看到后台登录界面 创建超级用户python manage.py createsuperuser 账号和密码都是admin，其他可以随便填 这时可以通过后台登录界面进入后台看到数据库数据 修改 语言和时区在根目录/setting.py中修改 语言和时区 LANGUAGE_CODE = 'zh-Hans' TIME_ZONE = 'Asia/Shanghai' 后台界面可以显示中文，通过增加可以添加数据","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://orzff.cn/tags/Django/"},{"name":"连接MySQL","slug":"连接MySQL","permalink":"http://orzff.cn/tags/%E8%BF%9E%E6%8E%A5MySQL/"}]},{"title":"axios与django通信","slug":"axios与django通信","date":"2020-12-26T15:37:50.000Z","updated":"2021-05-31T11:58:01.156Z","comments":true,"path":"/5218864/","link":"","permalink":"http://orzff.cn/5218864/","excerpt":"axios与django通信","text":"axios实例import axios from 'axios' import qs from 'qs' export function request (config) { const instance = axios.create({ //实例，配置一些基础信息 baseURL: 'http://192.168.0.100:8888/api/', timeout: 5000, withCredentials: true }) instance.interceptors.request.use(config =&gt; { //请求拦截器 console.log(config) if (config.method == \"POST\") { config.data = qs.stringify(config.data) // post的数据要经过处理 } return config }, err =&gt; { console.log(err) }) instance.interceptors.response.use(res =&gt; {//接收拦截器 return res.data }, err =&gt; { console.log(err) }) return instance(config) } 具体get与postimport { request } from './request' export function getBooks () { return request({ url: 'books' }) } export function postLogin (config) { return request({ method: 'post', url: 'books', data: config, headers: { 'Content-Type': 'application/x-www-form-urlencoded' // 发送数据的类型 } }) } 表单数据&lt;template&gt; &lt;div id=\"app\"&gt; &lt;form&gt; &lt;input type=\"text\" placeholder=\"login\" v-model=\"name\" /&gt; &lt;input type=\"text\" placeholder=\"pwd\" v-model=\"pwd\" /&gt; &lt;input type=\"submit\" value=\"登录\" @click=\"submitForm\" /&gt; &lt;/form&gt; &lt;!-- &lt;button @click=\"submitForm\"&gt;submit&lt;/button&gt; --&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { getBooks } from 'network/home' import { postLogin } from 'network/home' export default { el: '#app', data () { return { name: \"1234\", pwd: '1234', } }, created () { getBooks().then(res =&gt; { console.log(res) this.content = res.data }) }, methods: { submitForm (event) { console.log(this.name) let formData = new FormData() formData.append('name', this.name) formData.append('pwd', this.pwd) postLogin(formData).then(res =&gt; { console.log(res) }) } } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; django配置MIDDLEWARE = [ 'django.middleware.csrf.CsrfViewMiddleware', # 注释掉csrf ] APPEND_SLASH=False","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://orzff.cn/tags/Django/"},{"name":"Axios通信","slug":"Axios通信","permalink":"http://orzff.cn/tags/Axios%E9%80%9A%E4%BF%A1/"}]},{"title":"Django + Vue 快速构建项目","slug":"Django-Vue-快速构建项目","date":"2020-12-24T12:14:26.000Z","updated":"2021-05-31T11:58:01.146Z","comments":true,"path":"/b2788495/","link":"","permalink":"http://orzff.cn/b2788495/","excerpt":"Django + Vue 快速构建项目","text":"使用Vue+Django搭建项目参考 构建Django项目命令： django-admin startproject ulb_manager 结构： . ├── manage.py └── ulb_manager ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py 进入项目根目录，创建一个 app 作为项目后端命令： cd ulb_manager python manage.py startapp backend 即：app 名叫做 backend 结构： . ├── backend │ ├── __init__.py │ ├── admin.py │ ├── migrations │ │ └── __init__.py │ ├── models.py │ ├── tests.py │ └── views.py ├── manage.py └── ulb_manager ├── __init__.py ├── settings.py ├── urls.py └── wsgi.py 将Vue打包的dist文件放入url_manager. ├─backend │ ├─migrations │ └─__pycache__ ├─vue-fonter │ └─dist │ └─static │ ├─css │ ├─fonts │ ├─img │ └─js └─ulb_manager └─__pycache__ Vue-CLI3.x在打包时不会生成static文件 使用vue ui，导入Vue项目，在配置/基础配置/ 修改资源目录 为static 这样在进行打包就会生成static文件 使用Django的通用视图 TemplateView找到项目根urls.py(ulb_manager/urls.py)，使用通用视图创建最简单的模板控制器，访问 『/』时直接返回index.html urlpatterns = [ path('admin/', admin.site.urls), path('', TemplateView.as_view(template_name=\"index.html\")), path('api/', include('backend.urls')) ] 配置Django项目的模板搜索路径上一步使用了Django的模板系统，所以需要配置一下模板使Django知道从哪里找到index.html 打开 settings.py (ulb_manager/settings.py)，找到TEMPLATES配置项，修改如下: TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 'DIRS': [], **'DIRS': ['vue-fonter/dist']**, 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 注意这里的vue-fonter是VueJS项目目录，dist则是运行 npm run build构建出的index.html与静态文件夹static 的父级目录 这时启动Django项目，访问/则可以访问index.html，但是还有问题，静态文件都是404错误，下一步我们解决这个问题 配置静态文件搜索路径打开 settings.py (ulb_manager/settings.py)，找到STATICFILES_DIRS 配置项，配置如下: # Add for vuejs STATICFILES_DIRS = [ os.path.join(BASE_DIR, \"vue-fonter/dist/static\"), ] 这样Django不仅可以将/ 映射到index.html，而且还可以顺利找到静态文件 backend 配置在backend中创建urls from django.urls import path from . import views urlpatterns = [ path('books/', view = views.books, name=\"books\") ] 在backend/views.py中 from django.shortcuts import render from django.http.response import JsonResponse # Create your views here. def books(request): books = [ {'id': 1, 'title': \"python\", \"price\": 89} ] return JsonResponse(books, safe=False) 此时访问/我们可以看到使用Django作为后端的VueJS前端,访问/api/books我们可以看到json数据 解决开发时的跨域问题使用corsheaders pip install corsheaders 在setting.py中加入 INSTALLED_APPS = [ //... 'corsheaders', ] MIDDLEWARE = [ //...... 'corsheaders.middleware.CorsMiddleware', # 添加cors，在第三行，位置不能改 'django.middleware.common.CommonMiddleware', ] CORS_ORIGIN_ALLOW_ALL = True # 允许请求携带cookies CORS_ALLOW_CREDENTIALS= True 以上是从网上找的解决方法，但是并没有解决问题， 先看一下同源的定义 同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 vue启动server是的ip是192.168.0.100:8080，django启动服务时的ip是127.0.0.1:8000， 试着修改了一下django的启动ip 在setting.py中加入 ALLOWED_HOSTS = [ '192.168.0.100', '127.0.0.1', '0.0.0.0', 'localhost', ] 然后启动 django ./manage.py runserver 192.168.0.100:8888 然后启动vue npm run serve 这时不在出现跨域问题 成功！ 开发模式利用vscode 写前端vue，pycharm写django后端 ，调试时pycharm打开django服务，vscode 打开vue，","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://orzff.cn/tags/Django/"},{"name":"Vue","slug":"Vue","permalink":"http://orzff.cn/tags/Vue/"}]},{"title":"Django+Vue+Nginx+uWSGI部署","slug":"Django-Vue-Nginx-uWSGI部署","date":"2020-12-24T08:02:06.000Z","updated":"2021-05-31T11:58:01.133Z","comments":true,"path":"/1ae14b31/","link":"","permalink":"http://orzff.cn/1ae14b31/","excerpt":"使用Django+Vue+Nginx+uWSGI部署网页的前端和后台服务器","text":"Django+Vue+Nginx+uWSGI部署参考 准备工作ip:123.56.252.111 vue: dist django: django_server ├── backend │ ├── admin.py │ ├── apps.py │ ├── __init__.py │ ├── migrations │ │ └── __init__.py │ ├── models.py │ ├── __pycache__ │ │ ├── __init__.cpython-39.pyc │ │ ├── urls.cpython-39.pyc │ │ └── views.cpython-39.pyc │ ├── tests.py │ ├── urls.py │ └── views.py ├── db.sqlite3 ├── element-test │ └── dist │ ├── header.ico │ ├── index.html │ └── static │ ├── css │ ├── fonts │ ├── img │ └── js ├── manage.py ├── media ├── mysite │ ├── asgi.py │ ├── __init__.py │ ├── __pycache__ │ │ ├── __init__.cpython-39.pyc │ │ ├── settings.cpython-39.pyc │ │ ├── urls.cpython-39.pyc │ │ └── wsgi.cpython-39.pyc │ ├── settings.py │ ├── urls.py │ └── wsgi.py ├── static │ ├── admin │ ├── css │ ├── fonts │ ├── img │ └── js ├── test.py ├── uwsgi.ini ├── uwsgi.log ├── uwsgi_nginx.sock └── uwsgi.pid 虚拟环境在服务器配置有详细介绍 Django在服务器配置有详细介绍 uWSGI安装uWSGIpip install uwsgi 简单测试一下创建test.py # test.py def application(env, start_response): start_response('200 OK', [('Content-Type','text/html')]) return [b\"Hello World\"] # python3 #return [\"Hello World\"] # python2 运行 uWSGI: uwsgi --http :8000 --wsgi-file test.py 选项的含义： http :8000 使用http 协议，8000端口。 wsgi-file test.py 使用test.py 作为与 uWSGI交互的文件。 访问 123.56.252.111:8000，输出“Hello World”，说明该程序是这么工作的： graph LR; 客户端 --http:8000--&gt; uWSGI uWSGI --&gt; Python 测试Django测试django在创建的django目录，执行 python manage.py runserver 0.0.0.0:8000 先将IP设置下ALLOWHOSTS中 在服务器配置有详细介绍 在浏览器输入123.56.255.111:8000即出现django欢迎界面 测试uWSGIuwsgi --http :8000 --module mysite.wsgi 在浏览器输入123.56.255.111:8000出现Internal Server Error属于正常现象，因为没有资源 graph LR; 客户端 --http:8000--&gt; uWSGI uWSGI --&gt; Djano Nginx安装nginx在服务器配置有详细介绍 启动nginx#centos 7 systemctl start nginx 在浏览器输入123.56.255.111:80出现CenOS或Nginx的欢迎界面 配置nginx开启这三个端口： 80端口 显示Nginx欢迎界面，测试Nginx是否能正常运行 8000端口 Nginx接收请求的端口，自行处理静态请求，动态请求则转发给uWSGI的8001端口处理 8001端口 uWSGI接收动态请求的端口，处理完毕后将处理结果发给Nginx的8000端口 检查一下是否有uwsgi_params文件（后面的配置文件需要用到），它应该在nginx的目录里（/etc/nginx/），如果没有，可以点击这里下载。 创建/etc/nginx/sites-available的目录，在目录里创建support_center_nginx.conf配置文件进行配置： # support_center_nginx.conf # the upstream component nginx needs to connect to upstream django { server 127.0.0.1:8001; # for a web port socket (we'll use this first) } # configuration of the server server { # the port your site will be served on listen 8000; # the domain name it will serve for server_name 123.56.252.111; # substitute your machine's IP address or FQDN charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Django media location /media { alias /root/mysite/media; # your Django project's media files - amend as required } location /static { alias /root/mysite/static; # your Django project's static files - amend as required } # Finally, send all non-media requests to the Django server. location / { uwsgi_pass django; include /etc/nginx/uwsgi_params; # the uwsgi_params file you installed } 创建一个软链接(/etc/nginx/sites-enabled)指向它： ln -s /etc/nginx/sites-available /etc/nginx/sites-enabled 在/etc/nginx/nginx.conf中将该文件夹包含进去，使得Nginx启动时，能够将文件夹中配置的项目运行起来：include /etc/nginx/sites-enabled/*.conf 注意，这个语句添加在http中，server外 http { server { listen 8888; # listen [::]:80 default_server; server_name _; # root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { root /root/mysite/element-test/dist; try_files $uri $uri/ @router; index index.html index.htm; } location @router{ rewrite ^.*$ /index.html last; } error_page 404 /404.html; location = /404.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } include /etc/nginx/sites-enabled/*.conf; } 处理静态文件运行Nginx之前，得先把Django的静态文件集中到一个文件夹中（该文件夹就是STATIC_ROOT的值）：先向settings.py中添加： STATIC_ROOT = '/root/mysite/static' 然后，将静态资源集中： python manage.py collectstatic nginx测试systemctl restart nginx 向media文件夹中放一张图media.jpg用于测试， media的位置在上面support_center_nginx.conf中的location /media的指定位置 在浏览器输入123.56.255.111:8000/media/picture.png出现一张图片 graph LR; 客户端 --http--&gt; Nginx Nginx --uwsgi--&gt; uWSGI uWSGI --&gt; Python 使用.ini对uWSGI进行设置创建uwsgi.ini [uwsgi] # 项目路径 chdir = /root/mysite #django的wsgi文件路径 wsgi-file = /root/mysite/wsgi.py # 使用mmcsite.wsgi模块 module = mysite.wsgi # 虚拟环境的路径 home = /root/Envs/Django # 启用master master = true # 启动五个进程 processes = 10 # 每个进程启动30个线程 threads = 30 # 指定socket监听的地址和端口 socket = 0.0.0.0:8001 # socket权限 chmod-socket = 666 # 结束后清理环境 vacuum = true # 日志文件 daemonize = /root/mysite/uwsgi.log # pid文件 pidfile = /root/mysite/uwsgi.pid # 允许用内嵌的语言启动线程，这将允许你在app程序中产生一个子线程 enable-threads = true 然后，启动 uWSGI uwsgi --ini uwsgi.ini 转发80端口将/etc/nginx/sites-available/support_center_nginx.conf重命名/etc/nginx/sites-available/nginx_backend.conf cd /etc/nginx/sites-available/ mv support_center_nginx.conf nginx_backend.conf` 新建一个文件/etc/nginx/sites-available/nginx_fonter.conf vim nginx_fonter.conf 在文件中加入 server { # 监听端口 listen 8888; #ip server_name 123.56.252.111; # 编码规则 charset utf-8; client_max_body_size 75M; # 主页面内容， # root：指向vue的dist文件 # try_files：使用vue内部的路由转发 # index： location / { root /root/mysite/element-test/dist; try_files $uri $uri/ @router; index index.html index.htm; } location @router { rewrite ^.*$ /index.html last; } error_page 404 /404.html; location = /404.html{ } error_page 500 502 503 504 /50x.html; location = /50x.html{ } } 修改/etc/nginx/nginx.conf http { server { listen 8888; # listen [::]:80 default_server; server_name _; # root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { proxy_set_header Host $host:$server_port; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Connection \"\"; proxy_set_header X-Nginx-Proxy true; proxy_pass http://123.56.252.111:8888/; } location @router{ rewrite ^.*$ /index.html last; } error_page 404 /404.html; location = /404.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } include /etc/nginx/sites-enabled/*.conf; } 简单说下这样做的目的： 客户的所有请求都是通80端口，与默认端口通信是不需要加:80的，nginx从80端口接收到浏览器的请求，转发到8888端口，8888接收到在/etc/nginx/sites-available/fonter.conf文件处理 后端界面客户不会主动访问所以不用转发来隐藏端口， /etc/nginx/sites-available/fonter.conf 和 /etc/nginx/sites-available/nginx_backend.conf，都在 /etc/nginx/sites-available中，通过软连接/etc/nginx/sites-enabled在/etc/nginx/nginx.conf中的include /etc/nginx/sites-enabled/*.conf;导入nginx.conf文件,与主配置文件分离","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://orzff.cn/tags/Django/"},{"name":"Vue","slug":"Vue","permalink":"http://orzff.cn/tags/Vue/"},{"name":"Nginx","slug":"Nginx","permalink":"http://orzff.cn/tags/Nginx/"}]},{"title":"服务器配置","slug":"服务器配置","date":"2020-12-23T12:13:41.000Z","updated":"2021-05-31T11:58:01.201Z","comments":true,"path":"/7dfc688d/","link":"","permalink":"http://orzff.cn/7dfc688d/","excerpt":"服务器配置","text":"centos安装python3参考 centos下安装python3详细教程1.python位置使用whereis python得到python位置 [root@iz2ze3g6pyat2fqpma7zdvz django_test]# whereis python python: /usr/bin/python /usr/bin/python.config /usr/bin/python2.7 /usr/bin/python.bak /usr/bin/python2.7-config /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz 得到python的位置在 /usr/bin目录 [root@iz2ze3g6pyat2fqpma7zdvz ~]# cd /usr/bin [root@iz2ze3g6pyat2fqpma7zdvz bin]# ll python* lrwxrwxrwx 1 root root 32 Dec 22 19:40 python -&gt; /usr/local/python3/bin/python3.9 lrwxrwxrwx 1 root root 9 Dec 22 18:30 python2 -&gt; python2.7 -rwxr-xr-x 1 root root 7144 Nov 17 06:23 python2.7 -rwxr-xr-x 1 root root 1835 Nov 17 06:23 python2.7-config lrwxrwxrwx 1 root root 16 Dec 22 18:30 python2-config -&gt; python2.7-config lrwxrwxrwx 1 root root 32 Dec 23 18:43 python3 -&gt; /usr/local/python3/bin/python3.9 lrwxrwxrwx 1 root root 7 Dec 22 18:30 python.bak -&gt; python2 lrwxrwxrwx 1 root root 39 Dec 22 19:36 python.config -&gt; /usr/local/python3/bin/python3.9-config lrwxrwxrwx 1 root root 14 Dec 22 18:30 python-config.bak -&gt; python2-config python_django: total 20 drwxr-xr-x 2 root root 4096 Dec 23 15:33 bin drwxr-xr-x 2 root root 4096 Dec 23 15:33 include drwxr-xr-x 3 root root 4096 Dec 23 15:33 lib drwxr-xr-x 3 root root 4096 Dec 23 15:33 lib64 -rw-r--r-- 1 root root 201 Dec 23 15:33 pyvenv.cfg 进入/usr/bin目录使用ll python*我们可以得到python的各种版本 -&gt;是软连接，意味这个文件是后面文件的软链接，这个python也可以看成命令 2 python3的依赖yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make 3 安装pipcentos7没有安装pip #运行这个命令添加epel扩展源 yum -y install epel-release #安装pip yum install python-pip 4 用pip安装wgetpip install wget 5 用wget下载python3在官网找到想要的版本链接 wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz 6 编译python3源码包#解压 xz -d Python-3.6.4.tar.xz tar -xf Python-3.6.4.tar #进入解压后的目录，依次执行下面命令进行手动编译 cd Python-3.6.4 ./configure prefix=/usr/local/python3 make &amp;&amp; make install # 如果出现can't decompress data; zlib not available这个错误，则需要安装相关库 #安装依赖zlib、zlib-devel yum install zlib zlib yum install zlib zlib-devel 7 添加软连接#将原来的链接备份 mv /usr/bin/python /usr/bin/python.bak #添加python3的软链接 ln -s /usr/local/python3/bin/python3.6 /usr/bin/python #测试是否安装成功了 python -V 如果本身没有python3的软链接，可以再 ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3 8 更改yum配置因为yum使用python2，所以需要更改一个yum的配置 vi /usr/bin/yum 把#! /usr/bin/python修改为#! /usr/bin/python2 vi /usr/libexec/urlgrabber-ext-down 把#! /usr/bin/python 修改为#! /usr/bin/python2 virtualenv和virtualenvwrapperpython虚拟环境 简单点说python的虚拟环境就是给每个项目一个独立的python配置，各个项目之间的配置不影响， 1 下载virtualenvpip install virtualenv 2 创建新项目virtualenv env 3 使用虚拟环境source env/bin/activate 4 退出虚拟环境deactivate 5 virtualenvwrapper安装virtualenvwrapper 可以对虚拟环境进行集中管理 pip install virtualenvwrapper 6 添加~/.bashrc在~/.bashrc添加 export WORKON_HOME=~/Envs source /usr/local/bin/virtualenvwrapper.sh 读入配置文件 source ~/.bashrc #读入配置文件，立即生效 7 virtualenvwrapper基本使用 创建虚拟环境 mkvirtualenv mkvirtualenv venv 这样会在WORKON_HOME变量指定的目录下新建名为venv的虚拟环境。 指定python版本 --python指定python解释器 mkvirtualenv --python=/usr/local/python3.5.3/bin/python venv 查看当前虚拟环境目录 workon 切换到虚拟环境 workon xxx 退出虚拟环境 deactivate 删除虚拟环境 rmvirtualenv xxx 8 出错处理出现 ModuleNotFoundError: No module named '_ctypes' 安装libffi-devel yum install libffi-devel -y 重装python 使用make &amp;&amp; make install django1 下载使用pip install django 2 创建django项目django-admin startproject xxx 3 启动djangopython manage.py runserver 0.0.0.0:80 4 配置文件进入setting.py文件 在allowHost中添加自己的ip ALLOWED_HOSTS = [ '123.56.252.111', 'localhost', '0.0.0.0:8000', '127.0.0.1' ] 这样在运行后就可以用http://123.56.252.111:8000/来访问 5 报错处理参考 出现 django.core.exceptions.ImproperlyConfigured: SQLite 3.8.3 or later is required (found 3.7.17). 在官网找到想要版本的链接 使用wget下载 #链接最好重新获取，否则可能不是最新版本 wget https://www.sqlite.org/2019/sqlite-autoconf-3300100.tar.gz 解压安装 [root@localhost home]# tar zxvf sqlite-autoconf-3300100.tar.gz [root@localhost home]# cd sqlite-autoconf-3300100/ [root@localhost sqlite-autoconf-3300100]# ./configure [root@localhost sqlite-autoconf-3300100]# make &amp; make install 查看版本 #检查新安装的sqlite3版本 [root@localhost home]# /usr/local/bin/sqlite3 --version 3.30.1 2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b #检查旧的sqlite3版本 [root@localhost home]# /usr/bin/sqlite3 --version 3.7.17 2013-05-20 00:56:22 118a3b35693b134d56ebd780123b7fd6f1497668 # 把旧的sqlite3改个名字 [root@localhost home]# mv /usr/bin/sqlite3 /usr/bin/sqlite3_old # 设置软链接 [root@localhost home]# ln -s /usr/local/bin/sqlite3 /usr/bin/sqlite3 #查看sqlite3版本 [root@localhost home]# sqlite3 --version 3.30.1 2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b 添加到bashrc文件 在~/.bashrc中添加 export LD_LIBRARY_PATH=\"/usr/local/lib\" 检查sqlite3版本 [root@localhost home]# python3 Python 3.6.5 (default, Jul 9 2019, 20:03:55) [GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; import sqlite3 &gt;&gt;&gt; sqlite3.sqlite_version '3.30.1' &gt;&gt;&gt; exit() [root@localhost home]# nginx参考 1 安装添加Nginx 存储库 sudo yum -y install epel-release 安装nginx sudo yum -y install nginx 2 启动启动nginx sudo systemctl start nginx 3 防火墙允许http通信 sudo firewall-cmd --permanent --zone=public --add-service=http 允许https通信 sudo firewall-cmd --permanent --zone=public --add-service=https 重启防火墙 sudo firewall-cmd --reload 4 测试在浏览器输入地址 5 卸载停止nginx service nginx stop // centos 7 sysyemcyl stop nginx 删除自启动 chkconfig nginx off 从源头删除nginx rm -rf /usr/sbin/nginx rm -rf /etc/nginx rm -rf /etc/init.d/nginx 使用yum清理 yum remove nginx 修改root@后面的名字centos7 hostnamectl set-hostname dhl # hostname #查看 vim /etc/hosts # 编辑hosts文件，给127.0.0.1添加hostname 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 dhl 重启shell生效","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://orzff.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"服务器与本地传输文件","slug":"服务器与本地传输文件","date":"2020-12-20T10:18:22.000Z","updated":"2021-05-31T11:58:01.188Z","comments":true,"path":"/7ff886e9/","link":"","permalink":"http://orzff.cn/7ff886e9/","excerpt":"服务器与本地传输文件","text":"SCP首先确保服务器与本地通过ssh能进行链接，确保有scp 传输 远程拷贝文件 scp 本地文件 远程服务器用户名@远程服务器ip地址：指定拷贝到远程服务器路径 scp 远程服务器用户名@远程服务器ip地址：远程服务器文件 指定拷贝到本地电脑的路径 远程拷贝目录 scp -r本地文件 远程服务器用户名@远程服务器ip地址：指定拷贝到远程服务器路径 scp -r 远程服务器用户名@远程服务器ip地址：远程服务器文件 指定拷贝到本地电脑的路径 -r 表示递归拷贝整个目录 传输文件至服务器 scp 1.txt root@123.56.252.111:/root 从服务器拷贝目录 scp -r root@123.56.252.111:/root/select_test C:/Users/64371/Desktop","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://orzff.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"爬取wallpaper图片","slug":"爬取wallpaper图片","date":"2020-12-07T06:21:42.000Z","updated":"2021-05-31T11:58:01.203Z","comments":true,"path":"/2514ad2c/","link":"","permalink":"http://orzff.cn/2514ad2c/","excerpt":"爬取wallpaper图片","text":"1. user_agent_list这里是从网上获得的user_agent列表， 稍加修改就可以了 import random # 返回一个随机的请求头 headers def getheaders(): # 各种PC端 user_agent_list_2 = [ # Opera \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60\", \"Opera/8.0 (Windows NT 5.1; U; en)\", \"Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50\", # Firefox \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0\", \"Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10\", # Safari \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2\", # chrome \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16\", # 360 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36\", \"Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko\", # 淘宝浏览器 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11\", # 猎豹浏览器 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)\", # QQ浏览器 \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\", # sogou浏览器 \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)\", # maxthon浏览器 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Maxthon/4.4.3.4000 Chrome/30.0.1599.101 Safari/537.36\", # UC浏览器 \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36\", ] # 各种移动端 user_agent_list_3 = [ # IPhone \"Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", # IPod \"Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", # IPAD \"Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5\", \"Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", # Android \"Mozilla/5.0 (Linux; U; Android 2.2.1; zh-cn; HTC_Wildfire_A3333 Build/FRG83D) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", \"Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", # QQ浏览器 Android版本 \"MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", # Android Opera Mobile \"Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10\", # Android Pad Moto Xoom \"Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13\", # BlackBerry \"Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+\", # WebOS HP Touchpad \"Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0\", # Nokia N97 \"Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124\", # Windows Phone Mango \"Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)\", # UC浏览器 \"UCWEB7.0.2.37/28/999\", \"NOKIA5700/ UCWEB7.0.2.37/28/999\", # UCOpenwave \"Openwave/ UCWEB7.0.2.37/28/999\", # UC Opera \"Mozilla/4.0 (compatible; MSIE 6.0; ) Opera/UCWEB7.0.2.37/28/999\" ] # 一部分 PC端的 user_agent_list_1 = [ \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\", \"Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\" ] user_agent_list = user_agent_list_1 + user_agent_list_2 + user_agent_list_3; UserAgent = random.choice(user_agent_list) header = {\"User-Agent\": UserAgent} return header 2.免费代理这里只是列举了几个免费代理的网站，从上面爬取ip:port 和类型组装成字典输出即可 import requests import user_agent_list import re import random class SpiderProxy(): def __init__(self): self.url = [\"https://www.kuaidaili.com/free/inha/1/\", \"https://www.7yip.cn/free/?action=china&amp;page=2\", \"https://www.7yip.cn/free/?action=china&amp;page=3\", ] self.header = user_agent_list.getheaders() self.proxy = {} self.proxies_list = [] self.run() def get_proxies_list(self, url): try: response = requests.get(url, headers=self.header, timeout=3) response_data = response.content.decode('utf-8') ip_list = re.findall(r'&lt;td data-title=\"IP\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) port_list = re.findall(r'&lt;td data-title=\"PORT\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) type_list = re.findall(r'&lt;td data-title=\"类型\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) for index in range(len(ip_list)): self.proxies_list.append(\"{\\'%s\\':\\'%s:%s\\'}\" % (type_list[index], ip_list[index], port_list[index])) except Exception as e: print(e) # for tmp_proxy in tmp_list: # proxy = eval(tmp_proxy) # response = requests.get(\"www.baidu.com\", headers=self.header, proxies=proxy) # if response.status_code == 200: # self.proxies_list.append(tmp_proxy) def get_proxy(self): while 1: try: self.proxy = eval(random.choice(self.proxies_list)) response = requests.get(\"http://www.baidu.com\", headers=self.header, proxies=self.proxy, timeout=3) if response.status_code == 200: return except Exception as e: print(\"getProxy ------&gt; ERROR\", e) def run(self): for url in self.url: self.get_proxies_list(url) 3. loopRequests自己封装的循环访问的方法，可以解决部分网络延迟问题 在使用代理方面，每50次访问就更换代理，避免被封IP import requests import spider_proxy import time class LoopRequest(): def __init__(self): self.proxies = spider_proxy.SpiderProxy() self.count = 50 def get(self, url, **args): return self.request('GET', url, **args) def post(self, url, **args): return self.request('POST', url, **args) def get_proxy(self): if self.count &lt;= 0: self.proxies.get_proxy() self.count = 50 self.count -= 1 def request(self, method, url, **args): self.get_proxy() args['headers'] = self.proxies.header args['proxies'] = self.proxies.proxy args['timeout'] = 5 args['verify'] = False loop = 50 while loop: try: print(\"loopRequest: %s 第 %s 次尝试\" % (url, 51-loop)) requests.packages.urllib3.disable_warnings() response = requests.request(method, url, **args) print(\"loopRequest: %s 链接成功\" % url) return response except Exception as e: print(\"loopRequest: \" + e) time.sleep(5) if loop == 0: return \"get error\" loop -= 1 request = LoopRequest() 4. cookie由于wallpaper登录以后可以看到更多图片，所以这里要模仿登录来拿到cookie session在这里并不能起到很好的效果，所以直接使用cookie来模拟登录 详细信息挫这里: wallpaper 模拟登录 | Mug-9’s blog (orzff.cn) import requests import re import loopRequest class SpiderCookies(): def __init__(self): self.get_url = \"https://wallhaven.cc/login\" self.post_url = \"https://wallhaven.cc/auth/login\" self.request = loopRequest.request self.data = {} self._token = \"\" self.cookies = {} self.Is = False self.update() # 1. 请求页面获得_token 和 cookie def get_html(self): response = self.request.get(self.get_url) response_data = response.content.decode('utf-8') self._token = re.findall(r'&lt;meta name=\"csrf-token\" content=\"(.*?)\"&gt;', response_data, re.S) cookies = \"\" for cookie in response.cookies: cookies += cookie.name + \"=\" + cookie.value + \";\" # 用header来携带cookie self.request.proxies.header['Cookie'] = cookies # 2.装填data def combined_data(self): self.data = { '_token': self._token, 'username': '643719884@qq.com', 'password': 'dhl643719884' } # 3. 组装cookie def combined_cookie(self): response = self.request.post(self.post_url, data=self.data) # 这里拿到的cookie是相对比较齐全的cookie，主要用这个cookie来组装 post_cookies = response.request.headers['Cookie'] post_cookies_list = post_cookies.split(\"; \") # 这里cookie只要__cfduid temp_cookie = self.request.proxies.header['Cookie'] temp_cookie_list = temp_cookie.split(\";\") # 组装 self.cookies.update(__cfduid = temp_cookie_list[0].split('=')[1]) for cookie in post_cookies_list: self.cookies[cookie.split('=')[0]] = cookie.split('=')[1] # header pop掉Cookie self.request.proxies.header.pop('Cookie') # 4.登录 def post_html(self): response = self.request.get(self.post_url, cookies=self.cookies) response_data = response.content.decode('utf-8') if response.status_code == 200: print(\"WallPaper: Cookies获取成功\") self.Is = True else: print(\"WallPaper: Cookies获取失败\") def update(self): self.get_html() self.combined_data() self.combined_cookie() self.post_html() 5. spider 图片5.1 先获取页面上所有图片二级页面的url# 1. 获取页面信息,获取每张战片所在页面的url def get_html(self, url): response = self.request.get(url, cookies=self.cookies.cookies) response_data = response.content.decode('utf-8') href_list = re.findall(r'&lt;a class=\"preview\" href=\"(.*?)\" target=\"_blank\" &gt;&lt;/a&gt;', response_data, re.S) return href_list 5.2 对于每张图片页面，获取每张图片的页面使用etree+xpath即可拿到每张图片的url 为防止网络问题，这里进行了5次重复 # 2. 进入页面 获取图片的url def get_img_url(self, url): loop = 5 img_url = [] while loop: response = self.request.get(url) response_data = response.content.decode('utf-8') response_html = etree.HTML(response_data) img_url = response_html.xpath('//*[@id=\"wallpaper\"]/@src') if len(img_url): return img_url loop -= 1 self.error_log.write(url) print(url, \"ERROR\") return img_url 5.3 下载下载到本地E:\\picture\\当天日期 检查本地log看是否已存在相同图片 # 3. 下载 def img_download(self, url): with self.sem: img_name = url.split('/')[-1] if self.file_check(img_name): print(\"---%s 已存在\" % img_name) return picture_mkdir = \"E:\\\\picture\" if not os.path.exists(picture_mkdir): os.mkdir(picture_mkdir) os.chdir(picture_mkdir) data_mkdir = \"%s\\\\%s\" % (picture_mkdir, datetime.date.today()) if not os.path.exists(data_mkdir): os.mkdir(data_mkdir) os.chdir(data_mkdir) response = self.request.get(url) response_data = response.content print(\"---%s 开始写入\" % img_name) threadLock.acquire() with open(\"%s\" % img_name, \"wb\") as f: f.write(response_data) threadLock.release() print(\"---%s 写入完毕 -- count: %s\" % (img_name, self.count)) threadLock.acquire() self.download_log.write(img_name) self.count -= 1 threadLock.release() 5.4 检查本地log检查看是否已存在图片 # 4. 本地log def file_check(self, img_name): threadLock.acquire() self.download_log.seek(0, 0) file_content = self.download_log.read() threadLock.release() if img_name in file_content: return True else: return False 5.5 run计划每次下载100张图片，网页页数从2-100 # 6.run def run(self): loop = 50 while loop: if self.cookies.Is: break else: self.cookies.update() time.sleep(2) loop -= 1 if loop &lt;= 0: self.error_log.write(\"Cookies 获得失败\") return for i in range(2, 100): url = \"%s%s\" % (self.url, i) href_list = self.get_html(url) for html_url in href_list: img_url = self.get_img_url(html_url) if len(img_url) and self.count &gt; 0: threading.Thread(target=self.img_download, args=(img_url[0],)).start() 6. github地址Mug-9/Python-Spider: Spider (github.com)","categories":[{"name":"Spider","slug":"Spider","permalink":"http://orzff.cn/categories/Spider/"},{"name":"小项目","slug":"Spider/小项目","permalink":"http://orzff.cn/categories/Spider/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"爬图片","slug":"爬图片","permalink":"http://orzff.cn/tags/%E7%88%AC%E5%9B%BE%E7%89%87/"}]},{"title":"python 生成requirements.txt","slug":"python-生成requirements-txt","date":"2020-12-06T02:49:16.000Z","updated":"2021-05-31T11:58:01.158Z","comments":true,"path":"/3d982a67/","link":"","permalink":"http://orzff.cn/3d982a67/","excerpt":"python 生成requirements.txt","text":"生成requirements在要生成requirements的目录的控制台输入 pip freeze &gt; requirements.txt 安装requirement要根据requirements安装时，在控制台输入 pip install -r requirements.txt","categories":[{"name":"Python","slug":"Python","permalink":"http://orzff.cn/categories/Python/"}],"tags":[{"name":"requirements","slug":"requirements","permalink":"http://orzff.cn/tags/requirements/"}]},{"title":"gitee和github同步更新","slug":"码云和github同步更新","date":"2020-12-05T16:44:13.000Z","updated":"2021-05-31T11:58:01.223Z","comments":true,"path":"/2d45259f/","link":"","permalink":"http://orzff.cn/2d45259f/","excerpt":"gitee和github同步更新","text":"码云由于众所周知的原因，在github上clone很慢，所以采用码云来加速clone 1 在码云上导入github项目 2 修改configgit clone到本地，在视图中显示隐藏项目，进入.git找到config 3 加上github的链接由于是在gitee上clone的项目，所以在config中只有gitee的链接，在github链接下面加上gitee的链接 注意： 一定是github下面加gitee的链接 成功这样就可以在push的时候同时更新了","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"github","slug":"github","permalink":"http://orzff.cn/tags/github/"},{"name":"gitee","slug":"gitee","permalink":"http://orzff.cn/tags/gitee/"}]},{"title":"win10 terminal 配置","slug":"win10-terminal-配置","date":"2020-12-04T15:29:20.000Z","updated":"2021-05-31T11:58:01.178Z","comments":true,"path":"/e96d644/","link":"","permalink":"http://orzff.cn/e96d644/","excerpt":"win10 terminal 配置","text":"主题配置// This file was initially generated by Windows Terminal 1.4.3243.0 // It should still be usable in newer versions, but newer versions might have additional // settings, help text, or changes that you will not see unless you clear this file // and let us generate a new one for you. // To view the default settings, hold \"alt\" while clicking on the \"Settings\" button. // For documentation on these settings, see: https://aka.ms/terminal-documentation { \"$schema\": \"https://aka.ms/terminal-profiles-schema\", \"defaultProfile\": \"{574e775e-4f2a-5b96-ac1e-a2962a402336}\", // You can add more global application settings here. // To learn more about global settings, visit https://aka.ms/terminal-global-settings // If enabled, selections are automatically copied to your clipboard. \"copyOnSelect\": false, // If enabled, formatted data is also copied to your clipboard \"copyFormatting\": false, \"tabWidthMode\": \"equal\", \"theme\": \"light\", // A profile specifies a command to execute paired with information about how it should look and feel. // Each one of them will appear in the 'New Tab' dropdown, // and can be invoked from the commandline with `wt.exe -p xxx` // To learn more about profiles, visit https://aka.ms/terminal-profile-settings \"profiles\": { \"defaults\": { // Put settings here that you want to apply to all profiles. \"fontFace\": \"CaskaydiaCove NF\", \"fontSize\": 16, \"cursorShape\": \"filledBox\", }, \"list\": [ { \"guid\": \"{574e775e-4f2a-5b96-ac1e-a2962a402336}\", \"hidden\": false, \"name\": \"PowerShell 7\", \"source\": \"Windows.Terminal.PowershellCore\", \"tabTitle\": \"PowerShell 7\", // morec // 背景图片 \"acrylicOpacity\": 0.5, \"backgroundImage\": \"E:/picture/2020-12-18/wallhaven-o3d3w7.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"useAcrylic\": true, \"padding\": \"0, 0, 0, 0\", // 键入时窗口滚动到输入行 \"snapOnInput\": true, // 打开时的目录 \"startingDirectory\": \".\", // tab标题 \"tabTitle\": \"powershell\", // 使用acrylic \"useAcrylic\": false, //主题 \"colorScheme\": \"Solarized Dark Higher Contrast\", }, { \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\", \"hidden\": false, \"name\": \"PowerShell\", \"commandline\": \"powershell.exe\", \"tabTitle\": \"PowerShell\", // morec // 背景图片 \"acrylicOpacity\": 0.25, \"backgroundImage\": \"E:/picture/2020-12-07/wallhaven-y87dxx.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"padding\": \"0, 0, 0, 0\", // 键入时窗口滚动到输入行 \"snapOnInput\": true, // 打开时的目录 \"startingDirectory\": \".\", // tab标题 \"tabTitle\": \"powershell\", // 使用acrylic \"useAcrylic\": false, //主题 \"colorScheme\": \"Cobalt Neon\", }, { // Make changes here to the cmd.exe profile. \"guid\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\", \"name\": \"Command Prompt\", \"commandline\": \"cmd.exe\", \"hidden\": false, // more \"acrylicOpacity\": 0.25, \"backgroundImage\": \"E:/picture/wallhaven-1kjqdw.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"padding\": \"0, 0, 0, 0\", \"snapOnInput\": true, \"startingDirectory\": \"%USERPROFILE%\", \"tabTitle\": \"cmd\", \"useAcrylic\": false, //主题 \"colorScheme\": \"Thanatos Dark\", }, { // 通过terminal连接服务器 \"guid\": \"{B5F0BC97-C32E-67A0-97E1-6112A50DF336}\", \"name\": \"aliyun\", \"commandline\": \"ssh root@123.56.252.111\", \"acrylicOpacity\": 0.4, \"backgroundImage\": \"E:/picture/2020-12-18/wallhaven-6oq5lq.jpg\", \"backgroundImageOpacity\": 0.4, \"backgroundImagerStretchMode\": \"fill\", \"padding\": \"0, 0, 0, 0\", \"snapOnInput\": true, \"startingDirectory\": \"%USERPROFILE%\", \"tabTitle\": \"aliyun\", \"useAcrylic\": false, \"icon\": \"ms-appx:///ProfileIcons/{9acb9455-ca41-5af7-950f-6bca1bc9722f}.png\", // 图标 //主题 \"colorScheme\": \"Thanatos Dark\", }, { \"guid\": \"{db1d57fc-a9c1-4051-9677-f0232f905f60}\", \"hidden\": false, \"name\": \"Tencent Server\", \"commandline\": \"ssh root@81.71.14.51\", \"icon\": \"ms-appdata:///roaming/TencentServer.png\", // morec // 背景图片 \"acrylicOpacity\": 0.5, \"backgroundImage\": \"E:/picture/2020-12-23/wallhaven-o3dvv9.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"useAcrylic\": true, \"padding\": \"0, 0, 0, 0\", // 键入时窗口滚动到输入行 \"snapOnInput\": true, // 打开时的目录 \"startingDirectory\": \".\", // tab标题 \"tabTitle\": \"powershell\", // 使用acrylic \"useAcrylic\": false, //主题 \"colorScheme\": \"Thanatos Dark\", \"cursorColor\" : \"#FFFFFF\", }, { \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\", \"hidden\": false, \"name\": \"Azure Cloud Shell\", \"source\": \"Windows.Terminal.Azure\" }, ] }, // Add custom color schemes to this array. // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes \"schemes\": [ { \"name\": \"Thanatos Dark\", \"background\" : \"#1a2b3c\", \"foreground\" : \"#e09887\", \"selectionBackground\": \"#fef8ec\", \"black\": \"#65737e\", \"blue\": \"#0e9bd1\", \"brightBlack\": \"#acacac\", \"brightBlue\": \"#7899ba\", \"brightCyan\": \"#0099ad\", \"brightGreen\": \"#0de1b1\", \"brightRed\": \"#d47186\", \"brightWhite\": \"#fef8ec\", \"brightYellow\": \"#d8cb32\", \"brightPurple\": \"#ab43aa\", \"purple\": \"#928ba6\", \"cyan\": \"#008486\", \"green\": \"#0099ad\", \"red\": \"#ce4559\", \"white\": \"#fef8ec\", \"yellow\": \"#d8cb32\" }, { \"name\": \"Cobalt Neon\", \"black\": \"#142631\", \"red\": \"#ff2320\", \"green\": \"#3ba5ff\", \"yellow\": \"#e9e75c\", \"blue\": \"#8ff586\", \"purple\": \"#781aa0\", \"cyan\": \"#8ff586\", \"white\": \"#ba46b2\", \"brightBlack\": \"#fff688\", \"brightRed\": \"#d4312e\", \"brightGreen\": \"#8ff586\", \"brightYellow\": \"#e9f06d\", \"brightBlue\": \"#3c7dd2\", \"brightPurple\": \"#8230a7\", \"brightCyan\": \"#6cbc67\", \"brightWhite\": \"#8ff586\", \"background\": \"#142838\", \"foreground\": \"#8ff586\" }, { \"name\": \"Aurora\", \"black\": \"#23262e\", \"red\": \"#f0266f\", \"green\": \"#8fd46d\", \"yellow\": \"#ffe66d\", \"blue\": \"#0321d7\", \"purple\": \"#ee5d43\", \"cyan\": \"#03d6b8\", \"white\": \"#c74ded\", \"brightBlack\": \"#292e38\", \"brightRed\": \"#f92672\", \"brightGreen\": \"#8fd46d\", \"brightYellow\": \"#ffe66d\", \"brightBlue\": \"#03d6b8\", \"brightPurple\": \"#ee5d43\", \"brightCyan\": \"#03d6b8\", \"brightWhite\": \"#c74ded\", \"background\": \"#23262e\", \"foreground\": \"#ffca28\" }, { \"name\": \"FunForrest\", \"black\": \"#000000\", \"red\": \"#d6262b\", \"green\": \"#919c00\", \"yellow\": \"#be8a13\", \"blue\": \"#4699a3\", \"purple\": \"#8d4331\", \"cyan\": \"#da8213\", \"white\": \"#ddc265\", \"brightBlack\": \"#7f6a55\", \"brightRed\": \"#e55a1c\", \"brightGreen\": \"#bfc65a\", \"brightYellow\": \"#ffcb1b\", \"brightBlue\": \"#7cc9cf\", \"brightPurple\": \"#d26349\", \"brightCyan\": \"#e6a96b\", \"brightWhite\": \"#ffeaa3\", \"background\": \"#251200\", \"foreground\": \"#dec165\" }, { \"name\": \"Solarized Dark Higher Contrast\", \"black\": \"#002831\", \"red\": \"#d11c24\", \"green\": \"#6cbe6c\", \"yellow\": \"#a57706\", \"blue\": \"#2176c7\", \"purple\": \"#c61c6f\", \"cyan\": \"#259286\", \"white\": \"#eae3cb\", \"brightBlack\": \"#006488\", \"brightRed\": \"#f5163b\", \"brightGreen\": \"#51ef84\", \"brightYellow\": \"#b27e28\", \"brightBlue\": \"#178ec8\", \"brightPurple\": \"#e24d8e\", \"brightCyan\": \"#00b39e\", \"brightWhite\": \"#fcf4dc\", \"background\": \"#142838\", \"foreground\": \"#9cc2c3\" } ], // Add custom actions and keybindings to this array. // To unbind a key combination from your defaults.json, set the command to \"unbound\". // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings \"actions\": [ // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json. // These two lines additionally bind them to Ctrl+C and Ctrl+V. // To learn more about selection, visit https://aka.ms/terminal-selection { \"command\": {\"action\": \"copy\", \"singleLine\": false }, \"keys\": \"ctrl+c\" }, { \"command\": \"paste\", \"keys\": \"ctrl+v\" }, // Press Ctrl+Shift+F to open the search box { \"command\": \"find\", \"keys\": \"ctrl+shift+f\" }, // Press Alt+Shift+D to open a new pane. // - \"split\": \"auto\" makes this pane open in the direction that provides the most surface area. // - \"splitMode\": \"duplicate\" makes the new pane use the focused pane's profile. // To learn more about panes, visit https://aka.ms/terminal-panes { \"command\": { \"action\": \"splitPane\", \"split\": \"auto\", \"splitMode\": \"duplicate\" }, \"keys\": \"alt+shift+d\" } ] } cmd 连接服务器客户端生成ssh公私钥ssh-keygen 本地ssh公钥追加到服务器将id_rsa.pub的内容复制到tmp.pub cd ~ vi tmp.pub mkdir .ssh &amp;&amp; chmod 700 .ssh touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys cat tmp.pub &gt;&gt; .ssh/authorized_keys rm tmp.pub 重启terminal成功！ 解决终端链接服务器长时间不操作卡死在服务器中执行 vim /etc/ssh/sshd_config ClientAliveInterval 60 // 每隔60S向客户端发送请求消息，并等待客户端响应 ClientAliveCountMax 10 // 客户端超过十次没响应，自动断开（即10分钟） //重启sshd服务 //centos6 service ssh restart //centos7 systemctl restart sshd 进入所在用户的.ssh目录, root用户的目录在：/root/.ssh/创建config文件vim /root/.ssh/config在文件中添加：ServerAliveINterval 60(没写错，就是INterval，我也不知道为什么，)保存退出，重新从终端通过ssh进入服务器后不会因为长时间操作断开。 加入这句之后，ssh客户端会每隔一段时间自动与ssh服务器通信一次，所以长时间操作不会断开。 terminal 添加右键检查常量echo %USERPROFILE% echo %LOCALAPPDATA% 获取图标创建Terminal文件夹 mkdir \"%USERPROFILE%\\AppData\\Local\\Terminal\" 保存这个 图标 添加注册表文件新建一个文件 new.reg Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt] @=\"Windows Terminal here\" \"Icon\"=\"%USERPROFILE%\\\\AppData\\\\Local\\\\Terminal\\\\terminal.ico\" [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command] @=\"C:\\\\Users\\\\[你的电脑用户名！你的电脑用名！]\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe\" @后面的[]改成电脑的用户名 如果第一步USERPROFILE没有东西打印出来，那么这里的USERPROFILE也改成C:\\Users\\你的用户名 第5行时图标保存的地址 执行reg文件，可以发现右键多了一个windows termianl here 当前目录在配置文件中添加或修改 // 打开时的目录 \"startingDirectory\": \".\", 这样也有一个缺点，直接打开termianl时目录为C:\\Windows\\System32目前没有解决方法 PowerShell主题参考 安装oh-my-posh主题在terminal输入 Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser 输入Y同意安装 更新配置文件在terminal输入$PROFILE 得到当前电脑的powershell_profile文件 PS C:\\Windows\\System32&gt; $PROFILE C:\\Users\\64371\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 PS C:\\Windows\\System32&gt; 继续输入 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE 在打开的文件夹中添加 Import-Module posh-git Import-Module oh-my-posh Set-Theme Honukai Set-Theme Honukai是主题设置，其他可选主题 Agnoster、Avit、Darkblood、Fish、Honukai、Paradox、Sorin、tehrob 更新配置 输入你用$PROFILE得到的路径 C:\\Users\\64371\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 有些主题的样式可能会有些小空格，这时因为字体不支持poweline,推荐选择Hack NF字体，支持编程连字和poweline字形 下载链接 我的样式 powershell 5 power shell 7 Centos-terminal 主题参考 查看系统当前shellecho $SHELL 结果 /bin/bash 查看/bin下是否有zsh包 cat /etc/shells ********************************************** 返回的结果是: /bin/sh /bin/bash /sbin/nologin /usr/bin/sh /usr/bin/bash /usr/sbin/nologin PS.默认没有安装zsh 安装zshsudo yum install -y zsh 在/bin下查看 /bin/sh /bin/bash /sbin/nologin /usr/bin/sh /usr/bin/bash /usr/sbin/nologin /bin/zsh 将zsh设置成默认shellchsh -s /bin/zsh 修改zsh为默认shell需要将以前在~/.bashrc中的设置，复制到~/.zshrc中 安装oh-my-zsh需要先装git sudo yum install git 修改host vim /etc/hosts 添加 199.232.28.133 raw.githubusercontent.com 下载 sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 配置主题主题 选择一款主题，修改~/.zshrc vim ~/.zshrc 将ZSH_THEME更改为选择的主题 jonathan 更新配置 source ~/.zshrc 重启 reboot 我的样式 aliyun Centos7 tencent Centos7 管理员在powershell中执行 PowerShell -Command \"Set-ExecutionPolicy RemoteSigned -scope Process; iwr -useb https://raw.githubusercontent.com/gerardog/gsudo/master/installgsudo.ps1 | iex\" 安装过程会询问你是否打算使用sudo作为gsudo的别名，这里可以根据个人需要进行选择。运行结尾显示Done即表明安装完成 安装完成后，在setting.json中添加list { \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\", \"hidden\": false, \"name\": \"PowerShell Administra\", \"commandline\": \"sudo.exe powershell.exe\", \"tabTitle\": \"PowerShell Administra\", // morec // 背景图片 \"acrylicOpacity\": 0.25, \"backgroundImage\": \"E:/picture/2020-12-07/wallhaven-y87dxx.jpg\", \"backgroundImageOpacity\": 0.25, \"backgroundImagerStretchMode\": \"fill\", \"padding\": \"0, 0, 0, 0\", // 键入时窗口滚动到输入行 \"snapOnInput\": true, // 打开时的目录 \"startingDirectory\": \".\", // tab标题 \"tabTitle\": \"powershell\", // 使用acrylic \"useAcrylic\": false, //主题 \"colorScheme\": \"Cobalt Neon\", }, 在普通的powershell中执行sudo，也可以升级成管理员","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"win Terminal","slug":"win-Terminal","permalink":"http://orzff.cn/tags/win-Terminal/"}]},{"title":"利用hexo多个设备更新博客","slug":"利用hexo多个设备更新博客","date":"2020-12-04T14:30:57.000Z","updated":"2021-05-31T11:58:01.179Z","comments":true,"path":"/1351aa80/","link":"","permalink":"http://orzff.cn/1351aa80/","excerpt":"利用hexo多个设备更新博客","text":"多台电脑控制一个hexo博客1.下载Git2.下载Node.jsNode.js 版本不要太高 3.新电脑创建新的ssh密钥在Git-bash中 ssh-keygen -t rsa -C 'your_email@example.com' 在github-&gt;setting-&gt;SSH &amp;&amp; GPG keys-&gt;new ssh key 测试是否成功 ssh -T git@github.com 如果出现 Hi username! You've successfully authenticated, but GitHub does not provide shell access. 3.1 设置用户信息$ git config --global user.name \"用户名\" $ git config --global user.email \"你希望的邮箱名\" 4. 资源配置依赖4.1 更换淘宝镜像npm config set registry https://registry.npm.taobao.org npm i -g express 4.2 安装hexonpm install -g hexo-cli 4.3 利用package.json部署资源{ \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": { \"version\": \"3.9.0\" }, \"dependencies\": { \"acorn\": \"^7.1.1\", \"core-js\": \"^3.2.1\", \"dependencies\": \"0.0.1\", \"eslint\": \"^6.6.0\", \"hexo\": \"^3.9.0\", \"hexo-abbrlink\": \"^2.0.5\", \"hexo-asset-image\": \"0.0.1\", \"hexo-deployer-git\": \"^1.0.0\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-feed\": \"^1.2.2\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-json-content\": \"^4.1.6\", \"hexo-generator-searchdb\": \"^1.0.8\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-less\": \"^0.1.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-kramed\": \"^0.1.4\", \"hexo-renderer-less\": \"^1.0.0\", \"hexo-renderer-mathjax\": \"^0.6.0\", \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-server\": \"^0.3.3\", \"hexo-symbols-count-time\": \"^0.6.3\", \"hexo-wordcount\": \"^6.0.1\", \"peer\": \"^0.2.10\" } } npm install 5.hexo提交hexo clean hexo g hexo d","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://orzff.cn/tags/Hexo/"}]},{"title":"vscode 配置Vue","slug":"vscode-配置Vue","date":"2020-11-29T03:20:30.000Z","updated":"2021-05-31T11:58:01.162Z","comments":true,"path":"/9c6f56ad/","link":"","permalink":"http://orzff.cn/9c6f56ad/","excerpt":"vscode 配置Vue","text":"插件Auto Close Tag自动关闭标签 background-cover可以设置壁纸 BetterComments注释可以变颜色，便于区分 默认五种颜色 Bracket Pair Colorizer 2括号匹配并能标颜色 Code Spell Checker检查错误单词，并给出相近单词 EditorConfig fot VS Code让vscode支持.editorconfig文件 .editorconfig文件可以规范编码风格和设置 在项目根目录建立.editorconfig文件[*.{js,jsx,ts,tsx,vue}] indent_style = space indent_size = 2 trim_trailing_whitespace = true insert_final_newline = true ESLint对文件进行校验，并可在保存时自动修复错误 在vscode配置文件中{ // eslint配置项，保存时自动修复错误 \"editor.codeActionsOnSave\": { \"source.fixAll\": true } } 在项目根目录建立.eslintrc.js文件module.exports = { root: true, env: { node: true, }, extends: ['plugin:vue/essential', '@vue/standard'], parserOptions: { parser: 'babel-eslint', }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', }, } Live Server本地预览界面，右键html文件选择Open with Live Seriver Prettier对js html文件格式化 在项目根目录建立.prettierrc文件{ \"semi\": false, \"singleQuote\": true } 在VScode 配置文件中加入// 保存时自动格式化代码 \"editor.formatOnSave\": true, // 默认使用prettier格式化支持的文件 \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", // 指定 *.vue 文件的格式化工具为vetur，防止和prettier冲突 \"[vue]\": { \"editor.defaultFormatter\": \"octref.vetur\" }, // 指定 *.js 文件的格式化工具为vscode自带，以符合ESLint规范 \"[javascript]\": { \"editor.defaultFormatter\": \"vscode.typescript-language-features\" } Vetur代码高亮，代码片段，Emmet语法支持，语法错误校验检查，格式化代码，代码提醒，对第三方UI框架支持 在vscode配置文件中// 将vetur的js格式化工具指定为vscode自带的 \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", // 移除js语句的分号 \"javascript.format.semicolons\": \"remove\", // 在函数名后面加上括号，类似这种形式 foo () {} \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true Eva ThemeEva 主题 我的配置文件{ \"editor.fontFamily\": \"Cascadia Code\", \"editor.fontSize\": 20, \"editor.fontWeight\": \"300\", \"editor.fontLigatures\": true, \"terminal.integrated.fontSize\": 20, \"terminal.integrated.fontWeight\": \"300\", \"terminal.integrated.cursorStyle\": \"underline\", \"debug.console.fontSize\": 18, \"workbench.iconTheme\": \"material-icon-theme\", \"explorer.confirmDelete\": false, \"files.autoSave\": \"onFocusChange\", // 保存时自动格式化代码 \"editor.formatOnSave\": true, // eslint配置项，保存时自动修复错误 \"editor.codeActionsOnSave\": { \"source.fixAll\": true }, // 让vetur使用vs自带的js格式化工具，以便在函数前面加个空格 \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", \"javascript.format.semicolons\": \"remove\", \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true, // 指定 *.vue 文件的格式化工具为vetur \"[vue]\": { \"editor.defaultFormatter\": \"octref.vetur\" }, // 指定 *.js 文件的格式化工具为vscode自带 \"[javascript]\": { \"editor.defaultFormatter\": \"vscode.typescript-language-features\" }, // 默认使用prettier格式化支持的文件 \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", \"better-comments.multilineComments\": true, \"better-comments.highlightPlainText\": false, \"cSpell.enableFiletypes\": [\"vue\", \"vue-html\"], \"workbench.colorTheme\": \"Eva Dark Italic\", \"explorer.confirmDragAndDrop\": false, \"editor.tabSize\": 2, \"backgroundCover.imagePath\": \"e:\\\\picture\\\\2020-12-11\\\\wallhaven-e7ozz8.png\", \"git.confirmSync\": false, \"git.autofetch\": true, \"backgroundCover.randomImageFolder\": \"e:\\\\picture\\\\2020-12-07\", \"backgroundCover.autoStatus\": false, \"backgroundCover.opacity\": 0.5, \"javascript.updateImportsOnFileMove.enabled\": \"always\", \"git.enableSmartCommit\": true, \"window.zoomLevel\": 1 }","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://orzff.cn/tags/Vue/"},{"name":"VSCode","slug":"VSCode","permalink":"http://orzff.cn/tags/VSCode/"}]},{"title":"记录一下利用tcp使得服务器与android客户端相连","slug":"记录一下利用tcp使得服务器与android客户端相连","date":"2020-10-21T14:11:20.000Z","updated":"2021-05-31T11:58:01.223Z","comments":true,"path":"/b4b2d023/","link":"","permalink":"http://orzff.cn/b4b2d023/","excerpt":"记录一下利用tcp使得服务器与android客户端相连","text":"云服务器租一个简单的服务器， 防火墙首先将我们需要的端口打开 firewall-cmd --zone=public --add-port=6666/tcp --permanent # 开放6666端口 firewall-cmd --reload # 配置立即生效 用firewall-cmd --zone=public --list-ports 查看一下是否开启 有时阿里云服务器的端口也得打开，这个自行百度即可。 seriver.c#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;ctype.h&gt; #include &lt;stdlib.h&gt; #define SERV_PORT 6666 char rbuf[1024]; int main() { int sockfd,clientfd, size, ret, on = 1; struct sockaddr_in saddr, raddr; // 设置地址信息，ip信息 size = sizeof(struct sockaddr_in); bzero(&amp;saddr, size); saddr.sin_family = AF_INET; saddr.sin_port = htons(SERV_PORT); saddr.sin_addr.s_addr = htonl(INADDR_ANY); // 创建UDP套接字 sockfd = socket(AF_INET, SOCK_STREAM, 0); if(sockfd &lt; 0) { perror(\"Socket failed.\"); exit(1); } //设置端口复用 setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)); // 绑定地址信息，IP信息 ret = bind(sockfd, (struct sockaddr*)&amp;saddr, sizeof(struct sockaddr)); if(ret &lt; 0) { perror(\"sbind failed.\"); exit(2); } listen(sockfd, 128); socklen_t val = sizeof(struct sockaddr); puts(\"waiting connect...\"); clientfd = accept(sockfd, (struct sockaddr*)&amp;raddr, &amp;val); puts(\"get!\"); // 循环接受客户端发来的信息 while(1) { puts(\"waiting data....\"); read(clientfd, rbuf, sizeof(rbuf)); printf(\"客户端传来数据: %s\\n\", rbuf); strncpy(rbuf, \"hello world too.\\n\", sizeof(\"hello world too.\\n\")); write(clientfd, rbuf, sizeof(rbuf)); printf(\"发送给客户端数据: %s\", rbuf); bzero(rbuf, 50); } close(sockfd); close(clientfd); return 0; } Android 客户端NDK应为tcp的服务端是用c语言写的，所以为了android能够连接，我使用了ndk，ndk具体的配置可以自行百度。 网络权限因为要进行网络连接，所以我们必须在mainfests文件中申请网络权限。如果没有权限创建socket会直接失败。 在application上面加上一句即可 &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; layout文件&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;Button android:id=\"@+id/send_link\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"发送连接\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.498\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.374\" /&gt; &lt;TextView android:text=\"TextView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/send_link\" android:layout_alignStart=\"@+id/send_link\" android:layout_marginTop=\"69dp\" android:id=\"@+id/textView\" tools:ignore=\"MissingConstraints\" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; MainActivity文件package com.example.test2; import androidx.appcompat.app.AppCompatActivity; import android.annotation.SuppressLint; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.TextView; import android.widget.Toast; public class MainActivity extends AppCompatActivity { // Used to load the 'native-lib' library on application startup. static { System.loadLibrary(\"native-lib\"); } public EditText editText; public static native String linkTest(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Example of a call to a native method Button button = findViewById(R.id.send_link); editText = findViewById(R.id.editText); button.setOnClickListener(new View.OnClickListener() { @SuppressLint(\"WrongConstant\") @Override public void onClick(View v) { new Thread(new Runnable() { //网络连接必须在子线程中 @Override public void run() { String ret = linkTest(); Log.d(\"s\", ret); //Toast.makeText(getApplicationContext(), linkTest(), 1).show(); } }).start(); } }); } } cpp文件#include &lt;jni.h&gt; #include &lt;string&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #include &lt;android/log.h&gt; #define LOG_TAG \"mysocket\" #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__) #define SERV_IP \"123.56.252.111\" #define SERV_PORT 6666 extern \"C\" JNIEXPORT jstring JNICALL Java_com_example_test2_MainActivity_linkTest(JNIEnv *env, jclass clazz) { int cfd; struct sockaddr_in serv_addr; socklen_t serv_addr_len; cfd = socket(AF_INET, SOCK_STREAM, 0); if(cfd &lt; 0) { return env-&gt;NewStringUTF(\"socket failed.\"); } LOGI(\"socket successful\"); memset(&amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(SERV_PORT); inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr); LOGI(\"connecting!\"); int ret = connect(cfd, (sockaddr *)&amp;serv_addr, sizeof(serv_addr)); if(ret &lt; 0) { LOGI(\"connect failed.\"); return env-&gt;NewStringUTF(\"连接失败\"); } LOGI(\"connect successful\"); char buf[1024] = \"hello world\\n\"; write(cfd, buf, sizeof(buf)); bzero(buf, 1024); read(cfd, buf, sizeof(buf)); return env-&gt;NewStringUTF(buf); } 连接我们点击模拟器中的连接按钮，可以在android日志中发现连接成功，并成功相互发送数据","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"连接服务器","slug":"连接服务器","permalink":"http://orzff.cn/tags/%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"android","slug":"android","permalink":"http://orzff.cn/tags/android/"}]},{"title":"windows下远程服务器mysql连接","slug":"远程服务器连接","date":"2020-05-25T08:54:31.000Z","updated":"2021-05-31T11:58:01.224Z","comments":true,"path":"/c700630f/","link":"","permalink":"http://orzff.cn/c700630f/","excerpt":"windows远程服务器mysql连接","text":"云服务器因为项目需要一个数据库，所以就在阿里云哪里用云翼计划买了一个小型服务器，虽然小但是也够用 centos 安装mysql安装mysqlwget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm yum -y install mysql57-community-release-el7-10.noarch.rpm yum -y install mysql-community-server 设置数据库启动mysqlsystemctl start mysqld.service 查看运行状态systemctl status mysqld.service 修改密码先查看原始密码 grep \"password\" /var/log/mysqld.log 利用原始密码进入数据库 mysql -uroot -p 修改密码规则 mysql&gt; set global validate_password_policy=0; mysql&gt; set global validate_password_length=1; 修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; windows mysql安装下载 &amp; 解压链接 配置系统变量找到bin目录的位置：E:\\Config\\mysql\\mysql-5.7.32-winx64\\bin 在环境变量的path中加入路径 安装生成data文件以管理员身份运行cmd 进入E:\\Config\\mysql\\mysql-5.7.32-winx64\\bin中 执行命令：mysqld --initialize-insecure --user=mysql 在E:\\Config\\mysql\\mysql-5.7.32-winx64\\下和bin同级目录生成data目录 安装mysql继续执行 mysqld -install 启动服务net start MySQL 登录mysqlmysql -u root -p 初始数据库没密码，直接回车 修改密码执行 ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; 创建数据库使用ubuntu下的命令就可以自动安装mysql数据库 sudo apt-get install mysql-server apt-get isntall mysql-client sudo apt-get install libmysqlclient-dev 安装成功后输入下面指令 sudo netstat -tap | grep mysq 如果是下图这样 那么就成功安装了，下面就是通过mysql -u root -p就可以登录mysql数据库 注意，在第一次登录mysql时输入的密码即为你的初始密码，不输就是空 远程连接在ubuntu下，修改/etc/mysql/mysql.conf.d/mysqld.cnf文件，将 bind-address = 127.9.0.1语句注释掉或者改成bind-address=0.0.0.0 bind-address = 127.9.0.1 意味着只允许本地登录，而把他改成0.0.0.0就代表允许所有的ip登录 但是这还不够，当我们连接远程数据库时，会新建一个root 用户，但是这个root只允许本地登录，不允许远程登陆，我们可以通过 use mysql select host, user from user; 来验证发现这个root的 host只有一个localhost 这是我们要通过设置来使他允许远程用户登录 在mysql 中输入 # 允许所有root用户登录 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root用户密码' WITH GRANT OPTION; # 允许指定ip的root用户登录 GRANT ALL PRIVILEGES ON *.* TO root@'指定的IP地址' IDENTIFIED BY 'root用户密码' WITH GRANT OPTION; 然后重载授权表 FLUSH PRIVILEGES; 这时我们再来验证一下root的权限 这时就应该可以连接上了 但是 ,如果这时还是连接不上，就可能是防火墙的问题，输入ufw disable把防火墙关闭 如果还不行的话，就有可能是阿里云的问题了，因为我用的是一个轻量级的服务器，所以在防火墙中把端口3306打开即可 结束经过以上步骤mysql的远程连接基本上就可以搞定了 mysql -h IP -u root -p","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"连接MySQL","slug":"连接MySQL","permalink":"http://orzff.cn/tags/%E8%BF%9E%E6%8E%A5MySQL/"}]},{"title":"爬取88ys视频exe版","slug":"爬取88ys视频exe版","date":"2020-03-01T06:57:56.000Z","updated":"2021-05-31T11:58:01.202Z","comments":true,"path":"/581490d4/","link":"","permalink":"http://orzff.cn/581490d4/","excerpt":"爬取88ys视频exe版","text":"爬取88ys视频使用方式点击dist中的main.exe 找到想下载的视频主页面 粘贴到url文本框","categories":[{"name":"Spider","slug":"Spider","permalink":"http://orzff.cn/categories/Spider/"},{"name":"小项目","slug":"Spider/小项目","permalink":"http://orzff.cn/categories/Spider/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"爬视频","slug":"爬视频","permalink":"http://orzff.cn/tags/%E7%88%AC%E8%A7%86%E9%A2%91/"}]},{"title":"wallpaper 模拟登录","slug":"wallpaper 模拟登录","date":"2020-02-11T07:26:29.000Z","updated":"2021-05-31T11:58:01.173Z","comments":true,"path":"/72810b67/","link":"","permalink":"http://orzff.cn/72810b67/","excerpt":"wallpaper 模拟登录","text":"在模拟登录wallhaven是，发现了一些问题，用request.session登录并保存cookie并不奏效 所以决定自己手动保存cookie 先是登录因为登录信息中有_token，所以要先get一下获取网页的_token ，并且用get到的cookie来请求登录 def __init__(self): self.get_url = \"https://wallhaven.cc/login\" self.post_url = \"https://wallhaven.cc/auth/login\" self.proxies = spider_proxy.SpiderProxy() self.data = {} self._token = \"\" self.cookies = {} self.Is = False # 1. 请求页面获得_token 和 cookie def get_html(self): response = requests.get(self.get_url, headers=self.proxies.header, proxies=self.proxies.proxy) response_data = response.content.decode('utf-8') self._token = re.findall(r'&lt;meta name=\"csrf-token\" content=\"(.*?)\"&gt;', response_data, re.S) cookies = \"\" for cookie in response.cookies: cookies += cookie.name + \"=\" + cookie.value + \";\" # 用header来携带cookie self.proxies.header['Cookie'] = cookies # 2.装填data def combined_data(self): self.data = { '_token': self._token, 'username': '643719884@qq.com', 'password': 'dhl643719884' } 这样可以登录，但是在用这个user-agent去请求数据是，不是登录后的状态， 抓包后发线登录以后的cookie和未登录的cookie只有remeber_web的差别 而remeber_web在请求登录的post的返回值里，那么 # login以后的cookie请求 __cfduid=d7e60a37935c5d9c6f53f05ab1064e1681580787848; remember_web_59ba36addc2b2f9401580f014c7f58ea4e30989d=eyJpdiI6ImROQ29VNGRicnZsOW0wQW5BTzZVa1E9PSIsInZhbHVlIjoiTmNQT0h2TE03YW5yaUdhbWZDZnlQYlZzanN3UTV4aUdiMHh1bUl5cjVJMXdQbzIxYnF6bElYcFpmMERPY0ZcL3FnZ21xcU5WdXlvMlBBK21CeEs2K2FWV1pUK05sTmdDdFlHSWl4TlBwUHpuaEprV1dXYmZRbkZzWU1STjV6S3JONWsxNjBsekttbXFqd1BQTzhENlcwNzF0dVRvUit6eURxdHhrN1pZblo4U3lUMys2ekNLdTlXTllBXC82dkI3VUEiLCJtYWMiOiJkYmNiOTZiNDU3M2NjY2M3OGJjZWM4ZTBjZmJlZmIwMTBhMTM5MTcwMTA3ZDc1NjliNDM0ZmM1OWFkY2VhN2YwIn0%3D _pk_ref.1.01b8=%5B%22%22%2C%22%22%2C1581400207%2C%22http%3A%2F%2Flocalhost%3A63342%2FPyCharnPython%2Fday04%2Fawewall.html%3F_ijt%3Dog5l1ar0obspirlv150bfq3d1o%22%5D _pk_id.1.01b8=e6d2c9622d153c11.1580787918.21.1581400207.1581400207. XSRF-TOKEN=eyJpdiI6IjE4NzVZTlQrXC9pWFBmVlFsMUFvVFpBPT0iLCJ2YWx1ZSI6Im91OUROUEFZVHlsNWJ5bjdLa2pyQkV5R0RYZmNMNVN1TkJ5bERSTmFWaGFGRjUyaDI0K09aYzVVTUhZYzhnM0oiLCJtYWMiOiI0MTgzZmMyYzg0YmYyYmE2ZjgxNTEzMDBjYjI1NjFhOGYyMDZhNmJlZjkyYzBlMzhhYTNmNzA0MjBlZDQ3MDZhIn0%3D wallhaven_session=eyJpdiI6IjZQNVJcL3F0bXJhNndKUkc3QUVCTTZ3PT0iLCJ2YWx1ZSI6IjVSNHlRRjl0cU1sNEFMUGdCUkpFU0lOWXpZUjAzc1d4cHo1NnpLYlk2SU9kXC9zMldpekJKQ1NSMTI2aHIrWDJGIiwibWFjIjoiOWI3YjRlZGU0YTZiZWNkYjZmMWI4MGVlOGFhOThmNzdhOGUwZWQ2ODAxZjFjMGU4MzA1NDJiYjMwZDE3YzQ1OSJ9 # 没有login的cookie请求 __cfduid=d7e60a37935c5d9c6f53f05ab1064e1681580787848 _pk_ref.1.01b8=%5B%22%22%2C%22%22%2C1581402095%2C%22http%3A%2F%2Flocalhost%3A63342%2FPyCharnPython%2Fday04%2Fawewall.html%3F_ijt%3Dog5l1ar0obspirlv150bfq3d1o%22%5D _pk_ses.1.01b8=1 _pk_id.1.01b8=e6d2c9622d153c11.1580787918.22.1581402949.1581402095. XSRF-TOKEN=eyJpdiI6InRCSDFCT2dvZTZDeXVjR0w0NzZRNGc9PSIsInZhbHVlIjoiY1dzU1J4cHdENzN4eGVuU0I0NmxcL3NCblgyOWdVWEs2dTZ6QTNadHA4OHhISnZHWTFFamNIZGpibmZJQTRPcWUiLCJtYWMiOiJiNmMwMjhmMGYzYmY0MGViMWU2M2VhNTNjMTI1YTY0NThiYjU0MWFiYjYxMzRmODRkMGE5OWE5NmFlNTVkNTBjIn0%3D wallhaven_session=eyJpdiI6IkJoY1dITVJtQWJ4bzRqamJOVkxKeFE9PSIsInZhbHVlIjoiZjBXZUI3azVRWFAwY2tZeDlHakc1Nm5sSTZFUWVLT2FsT2JFVm5VUXQ0YmszYzVwMk9HcXlaV2R5YXpheG5lMCIsIm1hYyI6IjRjNzk1M2Q4NmE1ZDI4MjAwZDY2NDczNmRlZDVjYmVlN2Y2ZDA0NjYxOTI5NTZkYWM5OWY5MTY5MDQ2YTg4NWUifQ%3D%3D 我们就直接组装一个cookie # 3. 组装cookie def combined_cookie(self): response = requests.post(self.post_url, headers=self.proxies.header, proxies=self.proxies.proxy, data=self.data) # 这里拿到的cookie是相对比较齐全的cookie，主要用这个cookie来组装 post_cookies = response.request.headers['Cookie'] post_cookies_list = post_cookies.split(\"; \") # 这里cookie只要__cfduid temp_cookie = self.proxies.header['Cookie'] temp_cookie_list = temp_cookie.split(\";\") # 组装 self.cookies.update(__cfduid = temp_cookie_list[0].split('=')[1]) for cookie in post_cookies_list: self.cookies[cookie.split('=')[0]] = cookie.split('=')[1] # header pop掉Cookie self.proxies.header.pop('Cookie') # 4.登录 def post_html(self): response = requests.get(self.post_url, headers=self.proxies.header, proxies=self.proxies.proxy, cookies=self.cookies) print(response) if response.status_code == 200: print(\"Cookies获取成功\") self.Is = True else: print(\"Cookies获取失败\") def update(self): self.__init__() self.get_html() self.combined_data() self.combined_cookie() self.post_html() 这样我们就得到了登陆后访问toplist的页面 完整项目地址: Mug-9/Python-Spider: Spider (github.com) session 登录这里不可行,其他地方可行 import requests import sys #登录时需要POST的数据 data = { data } #设置请求头 headers = {'User-agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36'} #登录时表单提交到的地址（用开发者工具可以看到） login_url = 'login_url' #构造Session session = requests.Session() #在session中发送登录请求，此后这个session里就存储了cookie #可以用print(session.cookies.get_dict())查看 resp = session.post(login_url, data) #登录后才能访问的网页 url = 'url' #发送访问请求 resp = session.get(url) print(resp.content.decode('utf-8'))","categories":[{"name":"Spider","slug":"Spider","permalink":"http://orzff.cn/categories/Spider/"}],"tags":[{"name":"模拟登录","slug":"模拟登录","permalink":"http://orzff.cn/tags/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"}]},{"title":"爬虫爬取压缩过的数据","slug":"python-爬取压缩过的数据","date":"2020-02-06T05:16:57.000Z","updated":"2021-05-31T11:58:01.157Z","comments":true,"path":"/757817fb/","link":"","permalink":"http://orzff.cn/757817fb/","excerpt":"python 爬取压缩过的数据","text":"在爬取bilibili的历史记录是，发现出现了UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0x8b in position 1: invalid start byte 错误，后来发现是因为data = response.read().decode(\"utf-8\")这一句的data是压缩后的数据，无法正常解析后来对data进行解码就可以了 import urllib.request import urllib.parse from io import BytesIO import gzip import user_agent_list url = 'https://www.bilibili.com/account/history' random_user_agent = user_agent_list.getheaders() request = urllib.request.Request(url) request.add_header(\"User-Agent\", random_user_agent) response = urllib.request.urlopen(request) data = response.read() buf = BytesIO(data) zip = gzip.GzipFile(fileobj=buf) data = zip.read().decode('utf-8') with open(\"cookies.html\", \"w\", encoding='utf-8') as f: f.write(data)","categories":[{"name":"Spider","slug":"Spider","permalink":"http://orzff.cn/categories/Spider/"}],"tags":[{"name":"爬虫报错处理","slug":"爬虫报错处理","permalink":"http://orzff.cn/tags/%E7%88%AC%E8%99%AB%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"}]},{"title":"爬虫爬取免费代理","slug":"python-爬取免费代理","date":"2020-02-06T02:37:03.000Z","updated":"2021-05-31T11:58:01.157Z","comments":true,"path":"/28d5d8e8/","link":"","permalink":"http://orzff.cn/28d5d8e8/","excerpt":"python 爬取免费代理","text":"使用python爬取网站，可以用handler来隐藏user-agent，和使用高匿的代理ip，下面就是用不同的user-agent来爬取免费代理 首先要有一个user-agent的列表，我把它放在同一目录下然后import导入 import requests import user_agent_list import re import random class SpiderProxy(): def __init__(self): self.url = [\"https://www.kuaidaili.com/free/inha/1/\", \"https://www.7yip.cn/free/?action=china&amp;page=2\", \"https://www.7yip.cn/free/?action=china&amp;page=3\", ] self.header = user_agent_list.getheaders() self.proxy = {} self.proxies_list = [] self.run() def get_proxies_list(self, url): try: response = requests.get(url, headers=self.header, timeout=3) response_data = response.content.decode('utf-8') ip_list = re.findall(r'&lt;td data-title=\"IP\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) port_list = re.findall(r'&lt;td data-title=\"PORT\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) type_list = re.findall(r'&lt;td data-title=\"类型\"&gt;(.*?)&lt;/td&gt;', response_data, re.S) self.proxies_list = [] for index in range(len(ip_list)): self.proxies_list.append(\"{\\'%s\\':\\'%s:%s\\'}\" % (type_list[index], ip_list[index], port_list[index])) except Exception as e: print(e) # for tmp_proxy in tmp_list: # proxy = eval(tmp_proxy) # response = requests.get(\"www.baidu.com\", headers=self.header, proxies=proxy) # if response.status_code == 200: # self.proxies_list.append(tmp_proxy) def get_proxy(self): while 1: self.proxy = eval(random.choice(self.proxies_list)) try: response = requests.get(\"http://www.baidu.com\", headers=self.header, proxies=self.proxy, timeout=3) if response.status_code == 200: return except Exception as e: print(\"getProxy ------&gt; ERROR\", e) def run(self): for url in self.url: self.get_proxies_list(url) 项目地址：Python-Spider/爬取代理 at master · Mug-9/Python-Spider (github.com)","categories":[{"name":"Python","slug":"Python","permalink":"http://orzff.cn/categories/Python/"},{"name":"Spider","slug":"Python/Spider","permalink":"http://orzff.cn/categories/Python/Spider/"}],"tags":[{"name":"爬代理","slug":"爬代理","permalink":"http://orzff.cn/tags/%E7%88%AC%E4%BB%A3%E7%90%86/"}]},{"title":"杭电多校第七场","slug":"杭电多校第七场","date":"2019-10-13T06:12:27.000Z","updated":"2021-05-31T11:58:01.202Z","comments":true,"path":"/8f3d60e0/","link":"","permalink":"http://orzff.cn/8f3d60e0/","excerpt":"杭电多校第七场","text":"J: Just Repeat题意小C和小Q打牌，两个人轮流出牌，小C先出，小C手中有n张牌，小Q有m张牌，两个人知道对方手中有什么牌，如果对手已经出过了某个数字的牌，那么自己就不能再出这种数字的牌，而对方可以一直出，问最后谁先不能出牌。 思路首先对于双方都有的牌，我们肯定是要封对面尽量多的牌同时自己能出的牌也尽量多，我们我们就把这两个条件加一起把牌排一个序贪心拿即可， AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; typedef pair&lt;int, int&gt; pis; int a[maxn], b[maxn]; int n, m, p, cnt, mod; unordered_map&lt;int, int&gt; mp; int num[2][maxn&lt;&lt;1]; vector&lt;int&gt; vec[maxn&lt;&lt;1]; int read(){ int ans=0; char last=' ',ch=getchar(); while(ch&lt;'0' || ch&gt;'9') { last=ch; ch=getchar(); } while(ch&gt;='0' &amp;&amp; ch&lt;='9') { ans=ans*10+ch-'0'; ch=getchar(); } if(last=='-') ans=-ans; return ans; } unsigned long long k1, k2; unsigned long long rng() { unsigned long long k3 = k1, k4 = k2; k1 = k4; k3 ^= k3 &lt;&lt; 23; k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26); return k2 + k4; } int gai(int x) { if(!mp[x]) mp[x] = ++cnt; return mp[x]; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { mp.clear(); for (int i = 1; i &lt;= cnt; i ++) num[0][i] = num[1][i] = 0; cnt = 0; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;p); int sumn = n, summ = m; if(p == 1) { for (int i = 1; i &lt;= n; i ++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= m; i ++) scanf(\"%d\", &amp;b[i]); }else { scanf(\"%lld %lld %d\", &amp;k1, &amp;k2, &amp;mod); for (int i = 1; i &lt;= n; i ++) a[i] = rng() % mod; scanf(\"%lld %lld %d\", &amp;k1, &amp;k2, &amp;mod); for (int i = 1; i &lt;= m; i ++) b[i] = rng() % mod; } for (int i = 1; i &lt;= n; i ++) num[0][gai(a[i])] ++; for (int i = 1; i &lt;= m; i ++) num[1][gai(b[i])] ++; int Max = 0; for (int i = 1; i &lt;= cnt; i ++) { if(num[0][i] &amp;&amp; num[1][i]) { sumn -= num[0][i]; summ -= num[1][i]; int sumc = num[0][i] + num[1][i]; vec[sumc].push_back(num[0][i]); Max = max(Max, sumc); } } int cur = 0; for (int i = Max; i &gt;= 1; i --) { for (int v: vec[i]) { if(!cur) sumn += v; else summ += i - v; cur ^= 1; } vec[i].clear(); } if(sumn &gt; summ) printf(\"Cuber QQ\\n\"); else printf(\"Quber CC\\n\"); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"CodeForces EduRound 74","slug":"CodeForces-EduRound-74","date":"2019-10-10T12:12:20.000Z","updated":"2021-05-31T11:58:01.059Z","comments":true,"path":"/b223976b/","link":"","permalink":"http://orzff.cn/b223976b/","excerpt":"CodeForces EduRound 74","text":"E: Keyboard Purchase题意给你一个有小写字母组成的字符串，让你给每个字母编号，使得$\\sum\\limits_{i=1}^{n}|S_i-S_{i-1}|$的值最小 思路 因为字母种类很小，所以我们可以用类似状压来记录中间值，具体的是$dp[(1&lt;&lt;m)]$来记录当前状态出现的字母种类与还未出现的字母种类的距离。 我们现在先想象一个键盘，$dp[i]$的二进制表示就是键盘前几个的键，那么$dp[i]$的转移就是由$dp[i^(1&lt;&lt;j)]$新加了一位j转移得来： for (int i = 1; i &lt; (1&lt;&lt;m); i ++) { dp[i] = 0x3f3f3f3f; for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) dp[i] = min(dp[i], dp[i^(1&lt;&lt;j)]); } 得到的就是当前状态下的最小花费， 那么这样的话，原来的$dp[i^(1&lt;&lt;j)]$的状态不确定的这一位已经确定，那么其他还尚未却动的键与当前已经确定的键之间的距离要$+1$， for (int i = 1; i &lt; (1&lt;&lt;m); i ++) { dp[i] = 0x3f3f3f3f; for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) dp[i] = min(dp[i], dp[i^(1&lt;&lt;j)]); for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) for (int k = 0; k &lt; m; k ++) if(!((i&gt;&gt;k)&amp;1)) dp[i] += adj[j][k]; } AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; int dp[(1&lt;&lt;21)]; int adj[30][30]; int main() { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); string st; cin &gt;&gt; st; for (int i = 1; i &lt; st.size(); i ++) { adj[st[i]-'a'][st[i-1]-'a'] ++; adj[st[i-1]-'a'][st[i]-'a'] ++; } for (int i = 1; i &lt; (1&lt;&lt;m); i ++) { dp[i] = 0x3f3f3f3f; for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) dp[i] = min(dp[i], dp[i^(1&lt;&lt;j)]); for (int j = 0; (1&lt;&lt;j) &lt;= i; j ++) if((i&gt;&gt;j)&amp;1) for (int k = 0; k &lt; m; k ++) if(!((i&gt;&gt;k)&amp;1)) dp[i] += adj[j][k]; } printf(\"%d\\n\", dp[(1&lt;&lt;m)-1]); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"CodeForces","slug":"CodeForces","permalink":"http://orzff.cn/tags/CodeForces/"}]},{"title":"牛客多校第十场","slug":"牛客多校第十场","date":"2019-09-12T09:20:18.000Z","updated":"2021-05-31T11:58:01.214Z","comments":true,"path":"/b961061/","link":"","permalink":"http://orzff.cn/b961061/","excerpt":"牛客多校第十场","text":"思路一个随机排列的数列，问前缀和大于$a$的时候小于$b$的概率 思路 大意就是枚举最后一次抽的牌的点数，找在剩下的$n-1$个牌中，前$i$个牌的前缀和范围在$[a-x,min(a,b-x)]$的概率 概率是$\\frac{i!(n-i-1)!}{n!}$，这个概率可以预处理出来。 然后就是用可逆背包和滚动数组来求dp AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 510; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; double dp[2][maxn][maxn], p[maxn]; int x[maxn]; int main() { int n, a, b; scanf(\"%d %d %d\", &amp;n, &amp;a, &amp;b); dp[0][0][0] = 1; for (int i = 1; i &lt;= n; i ++) { scanf(\"%d\", &amp;x[i]); memcpy(dp[i&amp;1], dp[(i&amp;1)^1], sizeof(dp[0])); for (int j = 1; j &lt;= n; j ++) for (int k = x[i]; k &lt;= b; k ++) dp[i&amp;1][j][k] += dp[(i&amp;1)^1][j-1][k-x[i]]; } p[1] = 1./n; for (int i = 2; i &lt;= n; i ++) p[i] = p[i-1] * (i-1) / (n-i+1); double ans = 0; for (int i = 1; i &lt;= n; i ++) { for (int j = 1; j &lt;= n; j ++) for (int k = x[i]; k &lt;= b; k ++) dp[n&amp;1][j][k] -= dp[n&amp;1][j-1][k-x[i]]; for (int j = 0; j &lt; n; j ++) for (int k = max(0, a-x[i]+1); k &lt;= a &amp;&amp; k + x[i] &lt;= b; k ++) ans += dp[n&amp;1][j][k] * p[j+1]; for (int j = n; j &gt;= 1; j --) for (int k = b; k &gt;= x[i]; k --) dp[n&amp;1][j][k] += dp[n&amp;1][j-1][k-x[i]]; } printf(\"%.15f\\n\", ans); return 0; } H: Wood Processinghttp://www.orzff.cn/f1b7e3b7/","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"2019ACM-ICPC南昌网络赛","slug":"2019ACM-ICPC南昌网络赛","date":"2019-09-10T06:13:02.000Z","updated":"2021-05-31T11:58:00.951Z","comments":true,"path":"/4e0518cb/","link":"","permalink":"http://orzff.cn/4e0518cb/","excerpt":"2019ACM-ICPC南昌网络赛","text":"H: The Nth Item题意$F(0)=0,F(1)=1$ $F(n)= 3\\times F(n-1)+2\\times F(n-2)(n\\ge 2)$ 求第n项，n个询问，强制在线 思路好像直接1e6进制矩阵快速幂就可以直接过，预先打个1e6的表，但这个好像是卡过，多交几次就会T掉 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e6; const int ll mod = 998244353; struct Matrix{ ll mat[2][2]; Matrix() {memset(mat, 0, sizeof(mat));}; void init() { mat[0][0] = mat[1][1] = 1; } void init(ll a, ll b) { mat[0][0] = 0; mat[0][1] = b; mat[1][0] = 1; mat[1][1] = a; } void operator = (Matrix x) { for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) mat[i][j] = x.mat[i][j]; } }; Matrix operator * (Matrix x, Matrix y) { Matrix t; for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) for (int k = 0; k &lt;= 1; k ++) t.mat[i][j] = (t.mat[i][j] + x.mat[i][k] * y.mat[k][j]) % mod; return t; } Matrix pre[4][2*maxn+10]; ll Ksm(ll b) { Matrix t; t.init(); int cnt = 0; while(b &amp;&amp; cnt &lt; 3) { ++ cnt; ll pt = b % maxn; if(cnt == 3) pt = b; t = t * pre[cnt][pt]; b /= maxn; } Matrix ans; ans.mat[0][0] = 0; ans.mat[0][1] = 1; ans = ans * t; return ans.mat[0][0]; } void init() { Matrix t; t.init(3, 2); pre[1][1] = t; pre[1][0].init(); for (int i = 2; i &lt;= maxn; i ++) pre[1][i] = pre[1][i-1] * pre[1][1]; pre[2][1] = pre[1][maxn]; pre[2][0].init(); for (int i = 2; i &lt;= maxn; i ++) pre[2][i] = pre[2][i-1] * pre[2][1]; pre[3][1] = pre[2][maxn]; pre[3][0].init(); for (int i = 3; i &lt;= 2* maxn; i ++) pre[3][i] = pre[3][i-1] * pre[3][1]; } int main() { init(); ll n, q; scanf(\"%lld %lld\", &amp;n, &amp;q); ll ans = 0; for (int i = 1; i &lt;= n; i ++) { ll a = Ksm(q); q = q ^ (a * a); ans ^= a; } printf(\"%lld\\n\", ans); return 0; } 思路还有一种解法，通过打表得知询问$q$是由循环节的，最后在进行大约$1e6$次后，会有一个长度为$2$的循环节，我们就直接暴力找循环节，时间上好像比上面快一点 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll mod = 998244353; struct Matrix{ ll mat[2][2]; Matrix() {memset(mat, 0, sizeof(mat));}; void init() { mat[0][0] = mat[1][1] = 1; } void init(ll a, ll b) { mat[0][0] = 0; mat[0][1] = b; mat[1][0] = 1; mat[1][1] = a; } void operator = (Matrix x) { for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) mat[i][j] = x.mat[i][j]; } }; Matrix operator * (Matrix x, Matrix y) { Matrix t; for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) for (int k = 0; k &lt;= 1; k ++) t.mat[i][j] = (t.mat[i][j] + x.mat[i][k] * y.mat[k][j]) % mod; return t; } ll Ksm(ll b) { Matrix x; x.init(3, 2); Matrix t; t.init(); while(b) { if(b &amp; 1) t = t * x; x = x * x; b &gt;&gt;= 1; } Matrix ans; ans.mat[0][0] = 0; ans.mat[0][1] = 1; ans = ans * t; return ans.mat[0][0]; } map&lt;ll, int&gt; mp; int main() { ll n, q; scanf(\"%lld %lld\", &amp;n, &amp;q); ll ans = 0, l, r, loop=-1; for (int i = 1; i &lt;= n; i ++) { if(mp[q]) { loop = i-1; l = q; ll a = Ksm(q); r = q ^ (a * a); break; } mp[q] = 1; ll a= Ksm(q); q = q ^ (a * a); ans = ans ^ a; } if(loop!=-1) { ll dis = n - loop; if(dis % 4 == 3) ans = ans ^ Ksm(r); if(dis % 4 == 2) ans = ans ^ Ksm(l) ^ Ksm(r); if(dis % 4 == 1) ans = ans ^ Ksm(l); } printf(\"%lld\\n\", ans); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"南昌","slug":"南昌","permalink":"http://orzff.cn/tags/%E5%8D%97%E6%98%8C/"},{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"网络赛","slug":"网络赛","permalink":"http://orzff.cn/tags/%E7%BD%91%E7%BB%9C%E8%B5%9B/"}]},{"title":"特征方程","slug":"特征方程","date":"2019-09-10T05:08:23.000Z","updated":"2021-05-31T11:58:01.215Z","comments":true,"path":"/ea13e7c5/","link":"","permalink":"http://orzff.cn/ea13e7c5/","excerpt":"特征方程","text":"问题求二阶常系数线性齐次递推数列$f_n=a\\times f_{n-1} + b \\times f_{n-2}$的通项公式 结论先解出特征方程$x^2-a\\times x - b = 0$，两根分别是$x_1,x_2$ 如果$x_1 != x_2$ 则$f_n=A\\times x_1^n+B\\times x_2^n$ 如果$x_1=x_2$ 则$f_n=(A+B\\times n)\\times x_1^n$ （$A,B$可以通过$f_0,f_1$求出） 应用斐波那契数列$f_n=f_{n-1}+f_{n-2}$ 求解$x^2-x-1=0$ $x_1=\\frac{1+\\sqrt{5}}{2},x_2=\\frac{1-\\sqrt{5}}{2}$ $f_0=A\\times x_1^0+B\\times x_2^0=0$ $f_1=A\\times x_1^1+B\\times x_2^1=1$ $A=\\frac{\\sqrt{5}}{5}, B=\\frac{-\\sqrt{5}}{5}$ 所以$f_n=\\frac{\\sqrt{5}}{5} \\times (\\frac{1+\\sqrt{5}}{2})^n+\\frac{-\\sqrt{5}}{5}\\times (\\frac{1+\\sqrt{5}}{2})^n$","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"特征方程","slug":"特征方程","permalink":"http://orzff.cn/tags/%E7%89%B9%E5%BE%81%E6%96%B9%E7%A8%8B/"}]},{"title":"Min_25筛","slug":"Min-25筛","date":"2019-09-02T12:39:13.000Z","updated":"2021-05-31T11:58:01.149Z","comments":true,"path":"/ecec6bcc/","link":"","permalink":"http://orzff.cn/ecec6bcc/","excerpt":"Min_25筛","text":"使用条件在$O(\\frac{n^{\\frac{3}{4}}}{\\log n})$时间复杂度内，来求一类完全积性函数的前缀和 $\\sum\\limits_{i=1}^{n}f(i)$ 要求是$f(p)[p\\in prime]$是一个关于p的简单多项式并且$f(p^e)$可以快速算出 如何求分类我们可以先对$i$按照质数非质数分类 $\\sum\\limits_{i=1}^{n}f(i)=\\sum\\limits_{1\\le p\\le n} f(p) + \\sum\\limits_{i=1 ||i \\notin prime}^nf(i)$ 因为$f(i)$是完全积性函数，所以我们进一步把后面拆分，枚举每一个合数的最小质因子和最小质因子的次幂 $\\sum\\limits_{i=1}^{n}f(i)=\\sum\\limits_{1\\le p\\le n}f(p)+\\sum\\limits_{1\\le p^e\\le n \\&amp; 1\\le p \\le \\sqrt n}f(p^e)(\\sum\\limits_{1\\le i \\le \\lfloor\\frac{n}{p^e}\\rfloor \\&amp; min(i)&gt; p} f(i))$ $min(i)$代表$i$的最小质因子, 上式代表我们把合数的最小质因子以及次幂数提出来,计算那些最小质因子大于$p$的合数的值 $G$函数上式中我们要枚举$[1,n]$的每一个质数，但是n的范围可以很大， 这样就没法用线性筛筛出所有质数 但是我们可以考虑一个$DP$，我们令$g(n,j) = \\sum\\limits_{i=1}^{n}h(i)[i\\in prime || min(i)&gt;p_j]$ 其中$h(i)$是一个在质数处于$f(i)$取值相同的一个完全积性函数 也可以理解成原$f(i)$的所以值都参照$[i\\in prime]$时的取值，把所有自然数都当成质数 $g(n,j)$代表$i$为质数或者$min(i)&gt;p_j$时的$h(i)$的前缀和 然后我们来考虑转移，怎么由$g(n,j-1)$转移到$g(n,j)$ ，因为$j$的增大，那么可满足条件的$h(i)$数量减小， 所以我们通过减掉一些不满足条件的$h(i)$来转移，通过观察可以发现，那些不满足条件的恰好就是最小质因子为 $p_j$的合数,也就是减掉$g(\\frac{n}{p_j},j-1)-g(p_j-1,p_j)$，后面是减掉质数的部分，因为减掉的都是小于$p_j$的质数，这些质数已经在前面的遍历中减过了一次，不必再减 那么$g(n,j)=g(n,j-1)-p_j^k(g(\\frac{n}{p_j},j-1)-g(p_j-1,j-1))$ 注意后面的$g(p_j-1,j-1)$ 其实就是$h(i)$在前$j-1$个质数处的前缀和，因为$p_j\\le \\sqrt n$，所以我们可以用线性筛 筛出来，但是$n$还是很大，我们无法$DP$到$n$ 但是因为$p_j$的范围是$\\sqrt n$，而$g(n)$由所有的$g(\\frac{n}{p_j})$转移而来，所以我们只要计算这$\\sqrt n$ 范围内的$h(i)$即可 我们对下表进行离散化用两个数组来存储 以洛谷P5325为例 $g(x)=x^2,h(x)=x$ void GetW(long long n) { for (long long i = 1, j; i &lt;= n; i = j + 1) { j = n / (n / i); w[++m] = n / i; long long t = w[m] % Mod; g[m] = t * (t + 1) % Mod * ((2LL * t + 1) % Mod) % Mod * inv_6 % Mod; g[m] --; h[m] = t * (t + 1) % Mod * inv_2 % Mod; h[m] --; if(w[m] &lt;= sqr) id1[w[m]] = m; else id2[n/w[m]] = m; } } void GetG(long long n) { for (long long i = 1; i &lt;= tot; i ++) { for (long long j = 1; j &lt;= m &amp;&amp; prim[i] * prim[i] &lt;= w[j]; j ++) { long long d = w[j] / prim[i]; long long id = d &lt;= sqr ? id1[d] : id2[n/d]; g[j] = Sup(g[j], prim[i] * prim[i] % Mod * ((g[id] - sumg[i-1] + Mod) % Mod) % Mod); h[j] = Sup(h[j], prim[i] * ((h[id] - sumh[i-1] + Mod) % Mod) % Mod); } } } 这样我们就求出来了$[1,n]$中所有$h(i)$在质数处的和，$g(n)$ 求和我们设$S(n,j)=\\sum\\limits_{i=1}^{n}f(i)[min(i) \\ge p_j]$ 那么$S(n,j)=g(n)-\\sum\\limits_{i=1}^{j-1}f(p_i)+\\sum\\limits_{p_k^e\\le n\\&amp; k&gt; x}f(p_k^e)(S(\\frac{n}{p_k^e}, k)+[e!=1])$ 这样跟求$g(n)$的$dp$类似,答案就是$S(n,1)+f(1)$ 例题洛谷P5325题意定义$f(x)$, 且$f(p^k)=p^k(p^k-1)$，$p$是一个质数,求$\\sum\\limits_{i=1}^{n}f(i)$,对$1e9+7$取模 思路当$p$为质数时 $f(p)=p(p-1)=p^2-p$ 设$g(x)=x^2,h(x)=x,f(x)=g(x)-h(x)$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1e6 + 5; const int inf = 0x3f3f3f3f; const int Mod = 1e9 + 7; const double eps = 1e-8; typedef pair&lt;int, int&gt; psi; #define inv_2 (Mod+1)/2 #define inv_6 (Mod+1)/6 long long sqr, m, w[maxn], g[maxn], h[maxn]; long long sumg[maxn], sumh[maxn], id1[maxn], id2[maxn]; long long prim[maxn], tot; bool mark[maxn]; long long Add(long long a, long long b) { return (a + b) % Mod; } long long Sup(long long a, long long b) { return (a - b + Mod) % Mod; } long long Pow(long long a, long long b) { long long res = 1; while(b) { if(b &amp; 1) res = res * a % Mod; a = a * a % Mod; b &gt;&gt;= 1; } return res; } void init(long long n) { mark[1] = 1; for (long long i = 2; i &lt;= n; i ++) { if(!mark[i]) { prim[++tot] = i; sumg[tot] = (sumg[tot-1] + i * i) % Mod; sumh[tot] = (sumh[tot-1] + i) % Mod; } for (long long j = 1; j &lt;= tot; j ++) { if(i * prim[j] &gt; n) break; mark[i * prim[j]] = 1; if(i % prim[j] == 0) break; } } } void GetW(long long n) { for (long long i = 1, j; i &lt;= n; i = j + 1) { j = n / (n / i); w[++m] = n / i; long long t = w[m] % Mod; g[m] = t * (t + 1) % Mod * ((2LL * t + 1) % Mod) % Mod * inv_6 % Mod; g[m] --; h[m] = t * (t + 1) % Mod * inv_2 % Mod; h[m] --; if(w[m] &lt;= sqr) id1[w[m]] = m; else id2[n/w[m]] = m; } } void GetG(long long n) { for (long long i = 1; i &lt;= tot; i ++) { for (long long j = 1; j &lt;= m &amp;&amp; prim[i] * prim[i] &lt;= w[j]; j ++) { long long d = w[j] / prim[i]; long long id = d &lt;= sqr ? id1[d] : id2[n/d]; g[j] = Sup(g[j], prim[i] * prim[i] % Mod * ((g[id] - sumg[i-1] + Mod) % Mod) % Mod); h[j] = Sup(h[j], prim[i] * ((h[id] - sumh[i-1] + Mod) % Mod) % Mod); } } } long long S(long long x, long long y, long long n) { if(x &lt;= prim[y-1] || x &lt;= 1) return 0; long long id = x &lt;= sqr ? id1[x] : id2[n/x]; long long res = (g[id] - h[id] + Mod - sumg[y-1] + sumh[y-1] + Mod) % Mod; for (long long i = y; i &lt;= tot &amp;&amp; prim[i] * prim[i] &lt;= x; i ++) { long long t = prim[i]; for (long long j = 1; t &lt;= x; j ++, t = t * prim[i]) { long long p1 = t % Mod; res = Add(res, p1 * (p1 - 1) % Mod * (S(x/t, i+1, n) + (j != 1)) % Mod); } } return res % Mod; } int main(int argc, char *args[]) { long long n; scanf(\"%lld\", &amp;n); sqr = sqrt(n); init(sqr); GetW(n); GetG(n); printf(\"%lld\\n\", (S(n, 1, n) + 1) % Mod); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Min_25筛","slug":"Min-25筛","permalink":"http://orzff.cn/tags/Min-25%E7%AD%9B/"}]},{"title":"牛客多校第四场","slug":"牛客多校第四场","date":"2019-08-26T08:52:42.000Z","updated":"2021-05-31T11:58:01.215Z","comments":true,"path":"/db92c5b8/","link":"","permalink":"http://orzff.cn/db92c5b8/","excerpt":"牛客多校第四场","text":"E.triples ll题意让你用$n$个3的倍数，把$a$或出来,问你有几种方案，对998244353取模 思路在二进制中$1,4,16,\\mod 3余1$, 而 $2,8,32 \\mod 3余2$ 首先如果$a$中为$1$的二进制位在$b$中也都为$1$，那么就称$a$是$b$的子集 我们用$dp[i][j]$来表示二进制位$mod$ $3$ 余$1$的个数为$i$,$mod$ $3$ 余$2$的个数为$j$并且所有是3的倍数的子集个数 我们可以先一个$(logn)^4$求出所有的$dp$值 void Fac() { for (int i = 0; i &lt; maxn; i ++) C[i][0] = 1; for (int i = 1; i &lt; maxn; i ++) for (int j = 1; j &lt;= i; j ++) C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; } void init() { Fac(); for (int x = 0; x &lt; maxn; x ++) for (int y = 0; y &lt; maxn; y ++) for (int i = 0; i &lt;= x; i ++) for (int j = 0; j &lt;= y; j ++) if((i+2*j)%3==0) dp[x][y] = (dp[x][y] + C[x][i] * C[y][j] % mod) % mod; dp[0][0] = 1; } 如果要求或出来的结果是$a$的子集，那么方案数就是$(a的子集的个数)^n$ 但是题目要求或出来的结果是$a$,那我们就要容斥一下了 打个比方，现在$a$的$\\mod2$的个数为$1$，$\\mod1$的个数为$2$ 那么$dp[2][1]$所代表的是$&lt;2,1&gt;$的子集的个数，但有些子集在相或$n$次以后得不到a，这时候就要减掉那些不能或到$a$的子集 $dp[2][1]$就像上图中由 A-E,​A-D,A-C,B-E,B-D,B-C 组成，而能或出来$a$的只有A-E,那么我们就要把其余不满足的减掉，也就是减掉$dp[1][1]+dp[2][0]$,发现减多了，我们要加上$dp[1][0]+dp[0][1]$，后面就跟容斥一样，多写几个样例就会发现当$(num1+num2-i-j)\\mod2$时是减,其他是加。 注意：减的时候减掉的是不符合个数的$n$次幂 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 70; const int inf = 0x3f3f3f3f; const int mod = 998244353; ll C[maxn][maxn], dp[maxn][maxn]; int cnt[2], o; ll Ksm(ll a, ll b) { ll ret = 1; while(b) { if(b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return ret; } void Fac() { for (int i = 0; i &lt; maxn; i ++) C[i][0] = 1; for (int i = 1; i &lt; maxn; i ++) for (int j = 1; j &lt;= i; j ++) C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod; } void init() { Fac(); for (int x = 0; x &lt; maxn; x ++) for (int y = 0; y &lt; maxn; y ++) for (int i = 0; i &lt;= x; i ++) for (int j = 0; j &lt;= y; j ++) if((i+2*j)%3==0) dp[x][y] = (dp[x][y] + C[x][i] * C[y][j] % mod) % mod; dp[0][0] = 1; } int main() { init(); int t; scanf(\"%d\", &amp;t); while(t --) { ll n, a; scanf(\"%lld %lld\", &amp;n, &amp;a); cnt[0] = cnt[1] = o = 0; while(a) { if(a &amp; 1) cnt[o] ++; o ^= 1; a /= 2; } ll ans = 0; for (int i = 0; i &lt;= cnt[0]; i ++) for (int j = 0; j &lt;= cnt[1]; j ++) { ll f = C[cnt[0]][i] * C[cnt[1]][j] % mod * Ksm(dp[i][j], n) % mod; if((cnt[0] + cnt[1] - i - j) &amp; 1) f *= -1; ans = (ans + f + mod) % mod; } printf(\"%lld\\n\", ans); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"斜率优化dp","slug":"斜率优化dp","date":"2019-08-20T08:48:50.000Z","updated":"2021-05-31T11:58:01.180Z","comments":true,"path":"/f1b7e3b7/","link":"","permalink":"http://orzff.cn/f1b7e3b7/","excerpt":"斜率优化dp","text":"具体可以参考这篇博客https://www.cnblogs.com/Judge/p/9551035.html 简介斜率斜率优化$dp$，听名字就知道是用来优化$dp$的 当我们在推导$dp$公式的时候，如果我们推出来的$dp$转移方程类似为： $dp[i] = \\min\\limits_{x=1}^{x&lt;i}$ $or$ $\\max\\limits_{x=1}^{x&lt;i}$ $\\{dp[x] + f(x,i)\\}$ $f(x,i)是一个关于x与i的函数$ 拿去最小值来说 我们考虑两个决策点$k&lt;j&lt;i$并且$j$比$k$要优 我们我们可以列一个不等式 $dp[j]+f(j,i)\\leq dp[k]+f(k,i)$ 展开如果可以把式子化成类似$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$，那么我们如果如果把每个点$(x_i,y_i)$看成一个坐标，那么 就表示$(x_j,y_j)$与$(x_k,y_k)$的斜率$\\leq k_i$, 这样我们可以得到真正有用的点组成了一个凸包的形状 为什么是个凸包？当我们去最小值是，我们有一下这么几个点 我们维护一个下凸壳，那么我们找的最小值的直线一定是沿着下凸壳的边缘 所以说不处于凸壳上的点是没有意义的 另外：最小值维护下凸壳，最大值维护上凸壳 如何使用求斜率一般来说能推出斜率表达式的都可以用斜率优化$dp$ 我们已经把式子化成这么一个形式$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$ ,那么我们求斜率可以这么写 如果斜率单调就用移指针，不单调就二分答案 以HDU 3507为例： ll getUp(ll j) { return dp[j] + sum[j] * sum[j]; } ll getDown(ll j) { return 2 * sum[j]; } double Calc(ll x, ll y) { if(getDown(x) == getDown(y)) return -1e9; //加一下防止除零的情况 return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } 单调队列当我们化成的这个式子的$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$ 的$k_i$是单调的，那么我们可以用单调队列来维护这个凸壳，并且队首是最优解 因为我们维护一个单调的队列，所以当我们在队列里面加点时，根据凸壳的单调性我们可以这么写 while(head &lt; tail &amp;&amp; Calc(i, q[tail]) &lt;= Calc(q[tail], q[tail-1])) tail --; q[++tail] = i; 而如果存在$k&lt;j&lt;i$并且$j$比$k$优，的情况，也就是$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$ 我们在队首把$k$踢出去,因为$k$已经不是最优的 while(head &lt; tail &amp;&amp; Calc(q[head+1], q[head]) &lt;= sum[i]) head ++; 这样我们就可以用单调队列去维护一个单调的凸壳，并且单调队列里面的队首就是最优情况 二分单调栈当我们化成的这个式子的$\\frac{y_j-y_k}{x_j-x_k}\\leq k_i$ 的$k_i$不是单调的，那么我们可以用单调栈来维护这个凸壳 因为凸壳是单调的，所以我们要找的这个$k_i$可以用二分来查找 例题HDU 3507 Print Article题意有一个$C_i$序列，你可以把序列分为几段，每段的权值为$(\\sum\\limits_{i=1}^{k}C_i)^2+M$， 求出最小的权值和 思路很容易想到转移方程$dp[i] = \\min\\limits_{x=1}^{x&lt;i}\\{dp[x] + m + (sum[i] - sum[x])^2\\}$ 我们假设存在一个$k&lt;j&lt;i$并且$j$比$k$要优 那么$dp[j]+m+(sum[i]-sum[j]^2)\\leq dp[k]+m+(sum[i]-sum[k])^2$ 移项并合并同类项后： $\\frac{dp[j]+sum[j] \\times sum[j] - (dp[k]+sum[k]\\times sum[k])}{2(sum[j]-sum[k])}\\le sum[i]]$ 我们设$Y=dp[x]-sum[x],X=2\\times sum[x]$ 那么式子可以化成:$\\frac{Y(j)-Y(k)}{X(j)-X(k)}\\le sum[i]$ 因为是$sum[i]$是递增的，所以我们可以用单调队列维护一个下凸壳 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll maxn = 5e5 + 7; const ll inf = 0x3f3f3f3f; const ll mod = 1e9 + 7; const double eps = 0.0000000001; typedef pair&lt;ll, ll&gt; pis; ll dp[maxn], q[maxn]; ll sum[maxn]; ll head, tail, n, m; ll getDp(ll i, ll j) { return dp[j] + m + (sum[i] - sum[j]) * (sum[i] - sum[j]); } ll getUp(ll j) { return dp[j] + sum[j] * sum[j]; } ll getDown(ll j) { return 2 * sum[j]; } double Calc(ll x, ll y) { if(getDown(x) == getDown(y)) return -1e9; return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } int main() { while(~scanf(\"%lld %lld\", &amp;n, &amp;m)) { for (ll i = 1; i &lt;= n; i ++) scanf(\"%lld\", &amp;sum[i]); sum[0] = dp[0] = 0; for (ll i = 1; i &lt;= n; i ++) sum[i] += sum[i-1]; head = tail = 1; for (ll i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Calc(q[head+1], q[head]) &lt;= 1.0 * sum[i]) head ++; dp[i] = getDp(i, q[head]); while(head &lt; tail &amp;&amp; Calc(i, q[tail]) &lt;= Calc(q[tail], q[tail-1])) tail --; q[++tail] = i; } printf(\"%lld\\n\", dp[n]); } return 0; } 洛谷 P4072 征途题意序列分割，给你n个数字，你把序列分割成m个段，每一段的的方差为$v$ 输出最小的每一段的之和$\\times m^2$ 思路提前声明一下， 下面的$c_i$都是一段路的距离之和，而不是单条路的距离，所以是$m$段而不是$n$段 $s^2=\\frac{(\\frac{\\sum\\limits_{i=1}^{m}c_i}{n}-c_1)^2+(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m}-c_2)^2+…+(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m}-c_n)^2}{m}$ $s^2=\\frac{(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m})^2-2\\times \\frac{\\sum\\limits_{i=1}^{m}c_i}{m}\\times c_1+c_1^2+(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m})^2-2\\times \\frac{\\sum\\limits_{i=1}^{m}c_i}{m}\\times c_2+c_2^2+…+(\\frac{\\sum\\limits_{i=1}^{m}c_i}{m})^2-2\\times \\frac{\\sum\\limits_{i=1}^{m}c_i}{m}\\times c_n+c_n^2}{m}$ $s^2=\\frac{m\\times (\\frac{\\sum\\limits_{i=1}^{m}c_i}{m})^2-2\\times \\frac{(\\sum\\limits_{i=1}^{m}c_i)^2}{m}+(\\sum\\limits_{i=1}^{m}c_i^2)}{m}$ $s^2=\\frac{\\frac{(\\sum\\limits_{i=1}^{m}c_i)^2}{m}-2\\times \\frac{(\\sum\\limits_{i=1}^{m}c_i)^2}{m}+(\\sum\\limits_{i=1}^{m}c_i^2)}{m}$ $s^2=\\frac{-\\frac{(\\sum\\limits_{i=1}^{m}c_i)^2}{m}+(\\sum\\limits_{i=1}^{m}c_i^2)}{m}$ $s^2\\times m^2=-(\\sum\\limits_{i=1}^{n}c_i)^2+m\\times (\\sum\\limits_{i=1}^{n}c_i^2)$ 我们发现前面一项是一个常数，而$s^2\\times m^2$最小是在$\\sum\\limits_{i=1}^{m}c_i^2$最小时 这样我们在进行$dp$转移的时候,我们用$sum[x] = \\sum\\limits_{i=1}^{x}val[i]$ $val[x]$时每一条路的长度 $dp[i] = \\min\\{dp[x] + (sum[i]-sum[x])^2\\}$ 按照以往的套路，存在$k&lt;j&lt;i$并且$j$比$k$要优 $dp[j]+(sum[i]-sum[j])^2\\le dp[k]+(sum[i]+sum[k])^2$ $dp[j]+sum[j]^2-(dp[k]+sum[k]^2)\\le2\\times sum[i]sum[j]-2\\times sum[i]sum[k]$ $\\frac{dp[j]+sum[j]^2-(dp[k]+sum[k]^2)}{2\\times(sum[j]]-sum[k])}\\le sum[i]$ 这样斜率就推出来了，因为$sum[i]$是个递增的值，所以我们可以用单调队列来维护凸壳 然后用一个滚动数组来记录最优值 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; const int inf = 0x3f3f3f3f; const int mod = 1e9+7; ll sum[maxn], g[maxn], val[maxn]; ll q[maxn], dp[maxn]; ll getDp(ll i, int j) { return g[j] + (val[i] - val[j]) * (val[i] - val[j]); } ll getUp(int j) { return g[j] + val[j] * val[j]; } ll getDown(int j) { return 2 * val[j]; } double Calc(int x, int y) { if(getDown(x) == getDown(y)) return -1e9; return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } int main() { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;val[i]); val[i] += val[i-1]; g[i] = val[i] * val[i]; } for (int t = 1; t &lt; m; t ++) { int head, tail; head = tail = 1; for (int i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Calc(q[head+1], q[head]) &lt;= val[i]) head ++; dp[i] = getDp(i, q[head]); while(head &lt; tail &amp;&amp; Calc(i, q[tail]) &lt;= Calc(q[tail], q[tail-1])) tail --; q[++tail] = i; } for (int i = 1; i &lt;= n; i ++) g[i] = dp[i]; } printf(\"%lld\\n\", m * dp[n] - val[n] * val[n]); return 0; } 这道题貌似可以用WQS加斜率dp来写，下次来补一下 洛谷P2365 任务安排题意N个任务排成一个序列，你把任务分组完成，每个任务的费用是完成时间乘一个费用系数 思路我们先设计dp转移方程,因为我们在转移的时候还要考虑前面用了几组,所以我们在转移的时候直接把后面的 费时S加上, dp转移的时候时间和花费用前缀和维护 $dp[i] = min\\{dp[x] + time[i] \\times (cost[i] - cost[x])+S\\times (cost[n] - cost[x])\\}$ 按照以往套路, $dp[j]+time[i]\\times(cost[i]-cost[j])+S\\times(cost[n] - cost[j])\\le dp[k]+time[i]\\times(cost[i]-cost[k])+S\\times(cost[n] - cost[k])$ $dp[j]-dp[k]-S\\times cost[j]+S\\times cost[k]\\le time[i]\\times (cost[j]-cost[k])$ $\\frac{dp[j]-S\\times cost[j]-(dp[k]-S\\times cost[k])}{cost[j]-cost[k]}\\le time[i]$ 然后用斜率$dp$就直接写了 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll maxn = 1e5 + 5; const ll inf = 0x3f3f3f3f; const ll mod = 1e9+7; ll t[maxn], c[maxn]; ll dp[maxn], q[maxn]; ll n, S; ll getDp(ll i, ll j) { return dp[j] + t[i] * (c[i] - c[j]) + S * (c[n] - c[j]); } ll getUp(ll i) { return dp[i]-S*c[i]; } ll getDown(ll i) { return c[i]; } double Clac(int x, int y) { return 1.0 * (getUp(x) - getUp(y))/(getDown(x) - getDown(y)); } int main() { scanf(\"%lld %lld\", &amp;n, &amp;S); for (ll i = 1; i &lt;= n; i ++) { scanf(\"%lld %lld\", &amp;t[i], &amp;c[i]); t[i] += t[i-1]; c[i] += c[i-1]; } ll head, tail; head = tail = 1; for (int i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Clac(q[head+1], q[head]) &lt;= t[i]) head ++; dp[i] = getDp(i, q[head]); while(head &lt; tail &amp;&amp; Clac(i, q[tail]) &lt;= Clac(q[tail], q[tail-1])) tail --; q[++tail] = i; } printf(\"%lld\\n\", dp[n]); return 0; } 洛谷 P4360 锯木厂选址题意从山顶到山底运n棵老树，运一颗树的费用是树的重量乘上距离，为了不浪费决定在山腰上见两个锯木厂，问最小的运输费用 思路我们把树的重量求一个前缀和 $sum[]$，到山底的距离求一个后缀和$dis[]$,所有树运到山底的花费$totsum$ 因为只有两个锯木厂，所以我们可以直接写一下$dp$转移 $dp[i] = min\\{totsum-dis[x]\\times sum[x]-(sum[i]-sum[x])\\times dis[i])\\}$ 套路： $totsum-dis[j]\\times sum[j]-(sum[i]-sum[j])\\times dis[i])\\leq totsum-dis[k]\\times sum[k]-(sum[i]-sum[k])\\times dis[i])$ $-dis[j]\\times sum[j]+dis[k]\\times sum[k]\\le dis[i]\\times (-sum[j]+sum[k])$ $\\frac{dis[j]\\times sum[j]-dis[k]\\times sum[k]}{sum[j]-sum[k]}\\ge dis[i]$ $(因为sum[j]大于sum[k]所以要变号)$ 直接套 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; const ll inf = 0x7ffffffffffll; const int mod = 1e9+7; ll dis[maxn], sum[maxn]; ll dp[maxn], g[maxn]; ll q[maxn], totsum=0; ll getDp(int i, int j) { return totsum - dis[j] * sum[j] - dis[i] * (sum[i] - sum[j]); } ll getUp(int i) { return dis[i] * sum[i]; } ll getDown(int i) { return sum[i]; } double Clac(int x, int y) { return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } int main() { int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld %lld\", &amp;sum[i], &amp;dis[i]); sum[i] += sum[i-1]; totsum += sum[i] * dis[i]; } for (int i = n; i &gt;= 1; i --) dis[i] += dis[i+1]; int head, tail; ll ans = inf; head = tail = 1; for (int i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Clac(q[head+1], q[head]) &gt; dis[i]) head ++; dp[i] = getDp(i, q[head]); while(head &lt; tail &amp;&amp; Clac(i, q[tail]) &gt;= Clac(q[tail], q[tail-1])) tail --; q[++tail] = i; } for (int i = 1; i &lt;= n; i ++) ans = min(ans, dp[i]); printf(\"%lld\\n\", ans); return 0; } 洛谷 P5504 柠檬题意一串贝壳，每个贝壳都有一个值$s_0$你可以选择连续的一段把他变成柠檬，柠檬的个数是$s_0t^2$,$t$是区间柠檬值为$s_0$的个数 思路首先，我们要变的贝壳区间肯定是首尾值相同，然后我们可以对每个相同值得柠檬求一个前缀和 $dp[i] = max\\{dp[x-1] + vali^2\\}$ 套： $dp[j-1]+vali^2\\le dp[k-1]+vali^2$ $\\frac{dp[j-1]-dp[k-1] + val[j]sum[j]^2-val[k]sum[k]^2-2val[i]sum[j]+2val[i]sum[k]}{sum[j]-sum[k]}\\le 2val[i]sum[i]$ 我们发现$2val[i]sum[i]$对于每一类柠檬都是单调的，所以可以直接移指针如果斜率不单调就要在凸壳上二分了 AC代码（移指针）#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll maxn = 1e5 + 5; const ll inf = 0x3f3f3f3f; const ll mod = 1e9+7; ll last[maxn]; ll c[maxn], s[maxn]; vector&lt;ll&gt; q[maxn]; ll top[maxn]; ll dp[maxn]; ll getUp(ll i) { return dp[i-1] - 2 * s[i] * c[i] + c[i] * s[i] * s[i]; } ll getDown(ll i) { return s[i]; } double Calc(ll x, ll y) { return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } int main() { ll n; scanf(\"%lld\", &amp;n); for (ll i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;c[i]); s[i] = s[last[c[i]]] + 1; last[c[i]] = i; } for (ll i = 1; i &lt;= n; i ++) { if(last[c[i]]) q[c[i]].push_back(i); last[c[i]] = 0; } for (ll i = 1; i &lt;= n; i ++) { ll p = c[i]; while(top[p] &gt; 1 &amp;&amp; Calc(q[p][top[p]-1], q[p][top[p]]) &lt;= Calc(q[p][top[p]], i)) { --top[p]; q[p].pop_back(); } ++top[p]; q[p].push_back(i); while(top[p] &gt; 1 &amp;&amp; Calc(q[p][top[p]-1], q[p][top[p]]) &lt;= 2*p*s[i]) { --top[p]; q[p].pop_back(); } dp[i] = dp[q[p][top[p]]-1] + (s[i] - s[q[p][top[p]]]+1) * (s[i]-s[q[p][top[p]]]+1) * p; } printf(\"%lld\\n\", dp[n]); return 0; } AC代码（二分）#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll maxn = 1e5 + 5; const ll inf = 0x3f3f3f3f; const ll mod = 1e9+7; ll last[maxn]; ll c[maxn], s[maxn]; vector&lt;ll&gt; q[maxn]; ll top[maxn]; ll dp[maxn]; ll getUp(ll i) { return dp[i-1] - 2 * s[i] * c[i] + c[i] * s[i] * s[i]; } ll getDown(ll i) { return s[i]; } double Calc(ll x, ll y) { if(getDown(x) == getDown(y)) return -1e9; return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } ll find(ll x) { ll p = c[x]; ll l = 2, r = top[p]; ll ans = 1; while(l &lt;= r) { ll m = (l + r) &gt;&gt; 1; if(Calc(q[p][m], q[p][m-1]) &gt; 2*p*s[x]) { ans = m; l = m + 1; }else r = m - 1; } return ans; } int main() { ll n; scanf(\"%lld\", &amp;n); for (ll i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;c[i]); s[i] = s[last[c[i]]] + 1; last[c[i]] = i; } for (ll i = 1; i &lt;= n; i ++) { if(last[c[i]]) q[c[i]].push_back(i); last[c[i]] = 0; } for (ll i = 1; i &lt;= n; i ++) { ll p = c[i]; while(top[p] &gt; 1 &amp;&amp; Calc(q[p][top[p]-1], q[p][top[p]]) &lt;= Calc(q[p][top[p]], i)) { --top[p]; q[p].pop_back(); } ++top[p]; q[p].push_back(i); int ans = find(i); dp[i] = dp[q[p][ans]-1] + (s[i] - s[q[p][ans]] + 1) * (s[i]-s[q[p][ans]] + 1) * p; } printf(\"%lld\\n\", dp[n]); return 0; } 2019牛客多校第十场 J.Wood Processing题意把n块木板求成高度相同的k块，求浪费的最小 思路可以说是斜率dp的模板题 我们把高度从高到低排序，那么$dp$转移式就是 $dp[i]=max\\{dp[x]+(sum[i]-sum[x])\\times h[i]\\}$ $sum$是宽的前缀和 我们假设$j&gt;k$并且$j$比$k$优 $dp[j]+(sum[i]-sum[j])\\times h[i] &gt;= dp[k]+(sum[i]-sum[k])\\times h[i]$ $\\frac{dp[j]-dp[k]}{sum[j]-sum[k]}\\ge h[i]$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 5005; const int inf = 0x3f3f3f3f; const int mod = 1e9+7; typedef pair&lt;int, int&gt; pis; struct Node{ ll p, h, w; }node[maxn][2]; struct Plan{ ll h, w; }plan[maxn]; int n, k; ll ans = 0; ll dp[maxn], q[maxn], g[maxn]; bool cmp(Plan a, Plan b) { return a.h &gt; b.h; } ll getUp(int j) { return g[j]; } ll getDown(int i) { return plan[i].w; } double Cal(int x, int y) { return 1.0 * (getUp(x) - getUp(y)) / (getDown(x) - getDown(y)); } ll getDp(int x, int i) { return g[x] + (plan[i].w - plan[x].w) * plan[i].h; } void solve() { int head, tail; head = tail = 1; for (int i = 1; i &lt;= n; i ++) { while(head &lt; tail &amp;&amp; Cal(q[head+1], q[head]) &gt;= plan[i].h) head ++; dp[i] = getDp(q[head], i); while(head &lt; tail &amp;&amp; Cal(i, q[tail]) &gt;= Cal(q[tail], q[tail-1])) tail --; q[++tail] = i; } for (int i = 1; i &lt;= n; i ++) g[i] = dp[i]; } int main() { scanf(\"%d %d\", &amp;n, &amp;k); ll sum = 0; for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld %lld\", &amp;plan[i].w, &amp;plan[i].h); sum += plan[i].w * plan[i].h; } sort(plan + 1, plan + 1 + n, cmp); for (int i = 1; i &lt;= n; i ++) plan[i].w += plan[i-1].w; for (int i = 1; i &lt;= k; i ++) solve(); printf(\"%lld\\n\", sum-dp[n]); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斜率优化dp","slug":"斜率优化dp","permalink":"http://orzff.cn/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/"}]},{"title":"全排列与逆序对","slug":"全排列与逆序对","date":"2019-08-17T01:30:43.000Z","updated":"2021-05-31T11:58:01.178Z","comments":true,"path":"/ea46ca8a/","link":"","permalink":"http://orzff.cn/ea46ca8a/","excerpt":"全排列与逆序对","text":"全排列从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m＝n时所有的排列情况叫n的全排列。 逆序列逆序在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。 逆序数一个排列中逆序的总数就称为这个排列的逆序数。 奇偶排列逆序数为偶数的排列称为偶排列；逆序数为奇数的排列称为奇排列 相关问题给排列，求逆序数这个问题比较简单，直接对每个数字求一下逆序数，相加就可以了。 可以用线段树，树状数组等优化 根据逆序数推排列数问题1给定一个n元排列，它的逆序数存在且唯一,那么我们求一下已知一个n元排列的逆序数为m，这样的n元排列有多少？ 我们用$f(n,m)$表示逆序数为m的n元排列的个数 前提知识1对任意n&gt;=2且0&lt;=m&lt;=$C_n^2$时$f(n,m)$&gt;=1；当m&gt;$C_n^2$时,$f(n,m)$=0$f(2,0)=1,f(2,1)=1,f(2,2)=0$ 易证 前提知识2$f(n,m)=f(n,C_n^2-m)$对于一个逆序数为m的n元排列，$a_1,a_2,a_3,…a_n$，那么$a_n,a_{n-1},a_{n-2}…a_1$的逆序数为$C_n^2-m$ 反过来同理 前提知识3$f(n+1,m)=f(n,m)+f(n,m-1)+…+f(n,m-n)$考虑由$a_1,a_2,…a_n$组成的排列，那么我们在其中加上$a_{n+1}（a_{n+1}&gt;\\{a_1,a_2,…a_n\\}）$的话，$a_{n+1}$ 可以放在排列中的任意一个位置 放在末尾对逆序列没有影响，那么$f(n+1,m)+=f(n,m)$，放在首位的话逆序对增加$n$那么$f(n+1,m)+=f(n,m-n)$,以此类推，放在排列中的其他位置就是$f(n+1,m)=f(n,m-i)$ 那么$f(n+1,m)=f(n,m)+f(n,m-1)+f(n,m-2)+…+f(n,m-n)$ 前提知识4$f(n,0)=f(n,C_n^2)=1$前提知识5$f(n,1)=f(n,C_n^2-1)=n-1$$f(n,1)=f(n-1,1)+f(n-1,0)=f(n-1,1)+1$ 前提知识6$f(n,2)=f(n,C_n^2-2)=C_n^2-1(n&gt;2)$由3，4，5可知 $f(n,2)=f(n-1,2)+f(n-1,1)+f(n-1,0)=f(n-1,2)+n-1$ 根据$f(2,2)=0$可证 同理： $f(n,3)=C_n^3-C_n^2-C_n^1(n&gt;3)$ $f(n,4)=C_n^4+2C_n^3-C_n^1(n&gt;4)$ $f(n,5)=C_n^4+3C_n^4+2C_n^3-C_n^2+1(n&gt;5)$ $….$ 问题2给定逆序数，求满足此逆序数的最小排序 前提知识1对于n的全排列，在它完全倒序的时候逆序数最多 前提知识2对于一个形如$1,2,3,…,i-1,i,n,…,i+1$的排列$q$，在数$n$前保证首项为1，且严格以公差为1递增而数n以后排列任意的数列 当数$n$之后是递减的时候$q$的逆序数最多，$t=C_{n-i}^{2}$ 排列$q$是出现逆序对为$t$的最小排列 前提知识3我们把数$n$之后的第$k$小数与数$n$的前一个数(即$i$)交换，然后是数$n$后面保持逆序，这样得到的新排列的逆序对数为 $t=C_{n-i}^2+k$,且这个排列是逆序数$t$的最小排列","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"逆序对","slug":"逆序对","permalink":"http://orzff.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"全排列","slug":"全排列","permalink":"http://orzff.cn/tags/%E5%85%A8%E6%8E%92%E5%88%97/"}]},{"title":"牛客多校第九场","slug":"牛客多校第九场","date":"2019-08-16T09:21:39.000Z","updated":"2021-05-31T11:58:01.212Z","comments":true,"path":"/8ea435a5/","link":"","permalink":"http://orzff.cn/8ea435a5/","excerpt":"牛客多校第九场","text":"A: The Power of Fibonacci题意给你n,m,求$\\sum\\limits_{i=1}^{n}F_i^m \\mod 1e9，F$是斐波那契数列 思路首先斐波那契数列在模意义下是有循环节的，而在$1e9$下的循环节有太大， 所以我们把$1e9$分为两个互质数字的乘积$512*1953125$,而在这两个模下的循环节是可以接受的 然后我们分别算出一个结果用中国剩余定理求出答案就行了 注意快速幂模的时候有模$1e9$不然会T，可能是别的模数取模次数太多造成的超时 做完我傻了 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int Mod = 1000000000; int Ksm(int a, int b, int p) { int res = 1; while(b) { if(b &amp; 1) res = 1ll * res * a % p; a = 1ll * a * a % p; b &gt;&gt;= 1; } return res; } const int maxn = 1e7+5; int mod[2] = {512, 1953125}; int f[maxn], ans[2] = {0, 0}; int ex_gcd(int a, int b, int &amp;x, int &amp;y) { if(!b) { x = 1; y = 0; return a; } int d = ex_gcd(b, a%b, x, y); int t = x; x = y; y = t - a/b*y; return d; } int inv(int a, int p) { int x, y; ex_gcd(a, p, x, y); return (x % p + p) % p; } int main() { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int k = 0; k &lt;= 1; k ++) { int j = 2; f[0] = 0; f[1] = 1; for (; ; j ++) { f[j] = (f[j-1] + f[j-2]) % mod[k]; if(f[j] == 0 &amp;&amp; f[j-1] == 1) break; } for (int i = 0; i &lt; j; i ++) { int nr = n/j; if(n % j &gt;= i) nr ++; ans[k] = (ans[k] + 1ll * Ksm(f[i], m, Mod) * nr) % mod[k]; } } int Inv = inv(mod[0], mod[1]); ll res = 1ll * (ans[1] - ans[0] + Mod) % Mod * mod[0] * Inv + ans[0]; printf(\"%d\\n\", res%Mod); return 0; } B: Quadratic equation题意$x+y\\equiv b\\mod p, x\\cdot y\\equiv c \\mod p$ 求$x,y$ 思路二次剩余基础题，可惜我不会 根据初中知识我们可以化成这样$(x-\\frac{b}{2})^2\\equiv \\frac{b^2-4c}{4} \\mod p$ 下面就是验证$\\frac{b^2-4c}{4}$是否是模$p$下的二次剩余,模板题 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; struct T{ ll p, d; }; ll Ksm(ll a, ll b, ll p) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res; } ll w; //二次域乘法 T Mul_er(T a, T b, ll p) { T ans; ans.p = (a.p * b.p + a.d * b.d % p * w % p) % p; ans.d = (a.p * b.d % p + a.d * b.p % p) % p; return ans; } //二次域快速幂 T Ksm_er(T a, ll b, ll p) { T ans; ans.p = 1; ans.d = 0; while(b) { if(b &amp; 1) ans = Mul_er(ans, a, p); a = Mul_er(a, a, p); b &gt;&gt;= 1; } return ans; } //求勒让德符号 ll Legendre(ll a, ll p) { return Ksm(a, (p-1)&gt;&gt;1, p); } ll Recever(ll a, ll p) { a %= p; if(a &lt; 0) a += p; return a; } ll solve(ll n, ll p) { if(n % p == 0) return 0; if(p == 2) return 1; if(Legendre(n, p) + 1 == p) return -1; ll a = -1, t; while(1) { a = rand() % p; t = a * a - n; w = Recever(t, p); if(Legendre(w, p) + 1 == p) break; } T tmp; tmp.p = a; tmp.d = 1; T ans = Ksm_er(tmp, (p+1)&gt;&gt;1, p); return ans.p; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { ll b, c; scanf(\"%lld %lld\", &amp;b, &amp;c); ll t = ((b * b - 4 * c) % mod + mod) % mod; ll x = solve(t, mod); if(x == -1) { puts(\"-1 -1\"); continue; } x = (x + b) % mod * Ksm(2, mod-2, mod) % mod; ll y = (b - x + mod) % mod; if(x &gt; y) swap(x, y); printf(\"%lld %lld\\n\", x, y); } return 0; } C: Inversions of all permutations题意$\\sum\\limits_{r_i is a permutation of \\{a_i\\}}b^{t(r_i)}\\mod 1e9+7$ 求$b$的序列$a$的全排列的逆序对次幂之和 思路对于一个没有重复数字的序列，其逆序数为 1: 1 2: 1 1 3: 1 2 2 1 4: 1 3 5 6 5 3 1 3:1 2 2 1 代表长度为$3$的序列的逆序数为$0$的有$1$个，逆序数为$1$的有$2$个，逆序数为$3$的有$2$个，逆序数为$3$的有$3$个 我们用$dp$来代表答案，那么长度为$3$的答案就是$dp[3]=b^0+2b^1+2b^2+b^3$ 而$dp$转移是有规律的$dp[i] = dp[i-1]\\times \\sum\\limits_{j=0}^{i-1}b^j$ 而对于有重复数字的序列，其结果就是$\\frac{dp[n]}{\\prod dp[重复次数]}$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; ll dp[maxn], cnt[maxn], pre[maxn]; ll Ksm(ll a, ll b) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } int main() { int n, b; scanf(\"%d %d\", &amp;n, &amp;b); dp[0] = 1; for (int i = 1; i &lt; maxn; i ++) dp[i] = 1ll * dp[i-1] * b % mod; for (int i = 1; i &lt; maxn; i ++) dp[i] = dp[i] + dp[i-1] % mod; pre[1] = 1; for (int i = 2; i &lt; maxn; i ++) pre[i] = 1ll * pre[i-1] * dp[i-1] % mod; ll sum = pre[n]; for (int i = 1; i &lt;= n; i ++) { int x; scanf(\"%d\", &amp;x); cnt[x] ++; } for (int i = 0; i &lt; maxn; i ++) { if(cnt[i] &gt; 1) sum = 1ll * sum * Ksm(pre[cnt[i]], mod-2) % mod; } printf(\"%lld\\n\", sum); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"二次剩余","slug":"二次剩余","date":"2019-08-16T00:35:12.000Z","updated":"2021-05-31T11:58:01.178Z","comments":true,"path":"/98066e3c/","link":"","permalink":"http://orzff.cn/98066e3c/","excerpt":"二次剩余","text":"二次剩余定义对于$P, n$ 如果存在$x$使得 $x^2 \\equiv n \\mod P$ 则称$n$是模$P$意义下的二次剩余 定理对于$x^2\\equiv n(mod p)$ 总共有$\\frac{p-1}{2}$ 个n能使得方程有解 证明考虑所有的$x^2$ ,如果存在两个不同的数字$1&lt; u,v &lt; p$,$u^2\\equiv v^2(\\mod p)$ ,那么显然$(u^2-v^2)\\mod p==0$ 即$(u+v)(u-v)\\mod p == 0$ ，那么就只能是$u+v\\equiv 0(\\mod p)$，两个数字相互对应，所有共有$\\frac{p-1}{2}$个不同的平方 勒让德符号定义 $(\\frac{a}{p})= \\begin{cases} 1, &amp; a在模p意义下是二次剩余\\\\ -1，&amp; a在模p意义下是非二次剩余 \\\\ 0, &amp; a\\equiv 0 (mod p) \\end{cases}$ 定理$(\\frac{a}{p})\\equiv a^{\\frac{p-1}{2}}(\\mod p)$ 证明1.若$a$是模p下的二次剩余，那么存在$x^2\\equiv a (\\mod p)$ ,那么$x^{p-1}\\equiv a^{\\frac{p-1}{2}}\\equiv (\\frac{a}{p})\\equiv 1(\\mod p)$ 根据费马小定理 在$a$是模$p$意义下的二次剩余时$x^{p-1} \\equiv 1(\\mod p)$显然成立 2.若$a$是模$p$意义下的非二次剩余,那么跟上面同理，显然不存在$x^{p-1}\\equiv -1(\\mod p)$ 3.当$a\\equiv 0(\\mod p)$显然满足 开根复数域我们先定义一个数域$\\mathsf{F_p}$定义为$0$到$p-1$这$p$个数在模$p$意义下加减乘除构成的集合 数域$\\mathsf{F_{p^2}}$定义为一个开根的复数域，即如果一个$a^2-n$不能开根$(勒让德符号(\\frac{a}{p})=-1)$ ，那么我们加上一个复数域 就可以开根,(类似$\\sqrt{-1}$我们加上一个复数域就可以开根)，我们另这个不能开根的数字$\\sqrt{a^2-n}$为复数域的”虚数单位元”$(类似\\sqrt{-1})$ 并设它为$w$ ,那么则任意一个复数域的数字都可以表示为$a+bw$($a$是实部，$b$是虚部，$w$是虚数单位元) $\\mathsf{F_{p^2}}$数域满足不同复数域的所有四则运算 定理$w^p\\equiv -w(\\mod p)$ 证明$w^p\\equiv w\\cdot w^{p-1} \\equiv w\\cdot (w^2)^{\\frac{p-1}{2}}\\equiv w\\cdot (a^2-n)^{\\frac{p-1}{2}} \\equiv -w (\\mod p)$ 定理$(a+b)^n\\equiv a^n+b^n(\\mod n)(n \\in P)$ 证明有二项式定理可知: $(a+b)^n\\equiv \\sum\\limits_{i=0}^{n}C_n^ia^ib^{n-i}(\\mod n)$ 因为n是一个质数，所以除了$i=0,i=n$时，其他的$C_n^i$是无法别消除这能模$p$模成$0$ 二次剩余证明我们首先随机出来一个$a$,使得$(\\frac{a^2-n}{p})$为-1，也就是不能开根，然后我们把他定义为复数域的单位根 $w=\\sqrt{a^2-n}$ 那么我们求$x^2\\equiv n(\\mod p)$ $x^2\\equiv n\\equiv a^2-(a^2-n)\\equiv a^2-w^2$ $\\equiv (a-w)(a+w)\\equiv (a^p+w^p)(a+w)(a满足费马小定理 a^{p-1}\\equiv 1(\\mod p))$ $\\equiv (a+w)^p(a+w)\\equiv (a+w)^{p+1}$ $所以x\\equiv (a+w)^{\\frac{p+1}{2}}$ 代码struct T{ long long p, d; }; long long Ksm(long long a, long long b, long long p) { long long res = 1; while(b) { if(b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res; } long long w; //二次域乘法 T Mul_er(T a, T b, long long p) { T ans; ans.p = (a.p * b.p + a.d * b.d % p * w % p) % p; ans.d = (a.p * b.d % p + a.d * b.p % p) % p; return ans; } //二次域快速幂 T Ksm_er(T a, long long b, long long p) { T ans; ans.p = 1; ans.d = 0; while(b) { if(b &amp; 1) ans = Mul_er(ans, a, p); a = Mul_er(a, a, p); b &gt;&gt;= 1; } return ans; } //求勒让德符号 long long Legendre(long long a, long long p) { return Ksm(a, (p-1)&gt;&gt;1, p); } long long Recever(long long a, long long p) { a %= p; if(a &lt; 0) a += p; return a; } long long solve(long long n, long long p) { if(n % p == 0) return 0; if(p == 2) return 1; if(Legendre(n, p) + 1 == p) return -1; long long a = -1, t; while(1) { a = rand() % p; t = a * a - n; w = Recever(t, p); if(Legendre(w, p) + 1 == p) break; } T tmp; tmp.p = a; tmp.d = 1; T ans = Ksm_er(tmp, (p+1)&gt;&gt;1, p); return ans.p; } ll x = solve(n, p); x==-1无解，否则 x和p-x都是合法解","categories":[{"name":"算法","slug":"算法","permalink":"http://orzff.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二次剩余","slug":"二次剩余","permalink":"http://orzff.cn/tags/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"}]},{"title":"牛客多校第八场","slug":"牛客多校第八场","date":"2019-08-15T02:46:22.000Z","updated":"2021-05-31T11:58:01.214Z","comments":true,"path":"/f46914fa/","link":"","permalink":"http://orzff.cn/f46914fa/","excerpt":"牛客多校第八场","text":"J:Just Jump题意给你一个长度为L的路径，你起始点在0号点，每次最少移动d步，而且在$t_i$时刻$p_i$点会遭遇攻击 问你到达L点有多少种方法 思路首先不考虑攻击，到达L点的方法就是一个简单dp $dp[n]=dp[0]+dp[1]+dp[2]+..+dp[n-d]$ 可以用前缀和维护一下，这样dp的复杂度就是O(L) 那么考虑攻击的时候呢，一个明显的思路就是我们已经用dp算出了总的方法数， 那么我们把受到攻击是的路线减去就是不受攻击到达L的方法数 那么当我们在$(t_i,p_i)$受到攻击的方法数是多少呢，我们先把攻击按照位置从小到大排序，时间从小到大排序 首先我们肯定是从$[0,p_i-d]$这些点数转移来的，并且前面的$t_i-1$步每次最少走d步 那么我们在减去$(t_i-1)(d-1)$就变成从最少有1步，那么就是从$[1,p_i-d-(t_i-1)(d-1)]$找$t_i-1$个点，也就是组合数$C_{p_i-t_id+t_i-1}^{t_i-1}$ 但是现在又有了一个问题，就是用$C_{p_i-t_id+t_i-1}^{t_i-1}$ 来计算 我们计算了0—&gt;D的所有路径，但是其中包括了从C到D的路径，而这部分路径因为C的被攻击所以是无效的（C被攻击的时间小于D，C在D之前被攻击），所以我们要减去（C—&gt;D）这部分路径 这样我们就把从0开始$t_i$时刻到达攻击点$p_i$ 的路径数$f[i]$全部算了出来，那么结果就是$dp[L]-=\\sum\\limits_{i=1}^{m}f[i]*dp[L-node[i].p]$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e7; const int mod = 998244353; ll Fac[maxn+5], inv[maxn+5], f[3005]; ll pref[maxn+5], sum[maxn+5]; ll L, d, m; struct Node{ ll t, p; bool friend operator &lt; (Node a, Node b) { if(a.p == b.p) return a.t &lt; b.t; return a.p &lt; b.p; } }node[3005]; ll Ksm(ll a, ll b) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } void init() { Fac[0] = 1; for (int i = 1; i &lt;= maxn; i ++) Fac[i] = (Fac[i-1]*i) % mod; inv[maxn] = Ksm(Fac[maxn], mod-2); for (int i = maxn-1; i &gt;= 0; i --) inv[i] = inv[i+1] * (i+1) % mod; } ll Calc(ll t, ll p) { if(p-t*d+t-1 &lt; t-1) return 0; return Fac[p-t*d+t-1]*inv[t-1]%mod*inv[p-t*d]%mod; } int main() { init(); scanf(\"%lld %lld %lld\", &amp;L, &amp;d, &amp;m); for (int i = 1; i &lt;= m; i ++) scanf(\"%lld %lld\", &amp;node[i].t, &amp;node[i].p); sort(node+1, node+1+m); for (int i = 1; i &lt;= m; i ++) { f[i] = Calc(node[i].t, node[i].p); for (int j = 1; j &lt; i; j ++) if(node[i].t &gt; node[j].t) f[i] = (f[i] - f[j]*Calc(node[i].t-node[j].t, node[i].p-node[j].p)%mod + mod) % mod; } sum[0] = 1; pref[0] = 1; for (int i = 1; i &lt;= L; i ++) { if(i &lt; d) sum[i] = 0; else sum[i] = pref[i-d]; pref[i] = (pref[i-1]+sum[i]) % mod; } ll ans = sum[L]; for (int i = 1; i &lt;= m; i ++) ans = (ans - f[i] * sum[L-node[i].p] % mod + mod) % mod; printf(\"%lld\\n\", ans); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"牛客多校第七场","slug":"牛客多校第七场","date":"2019-08-15T01:12:19.000Z","updated":"2021-05-31T11:58:01.212Z","comments":true,"path":"/68238393/","link":"","permalink":"http://orzff.cn/68238393/","excerpt":"牛客多校第二场","text":"H:Pair题意给你3个数字$A,B,C$,让你计算$1\\leq x\\leq A,1\\leq y\\leq B$,并且$(x$ $and$ $y)&gt;C$或者$(x$ $xor$ $y)&lt;C$ 这样的 $$有多少对 思路很像数位dp，枚举二进制的每一位，4种状态分别是（A临界，B临界，A$and$B临界，A$xor$B临界） 这样直接数位dp可以算出有多少对不满足条件，然后用总数减去 因为$x,y&gt;1$,所有要在数位dp算出的结果中减去x为0时和y为0时的数量 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long ll dp[35][2][2][2][2]; int num_a[35], num_b[35], num_c[35]; void GetNum(ll a, ll b, ll c) { memset(num_a, 0, sizeof(num_a)); memset(num_b, 0, sizeof(num_b)); memset(num_c, 0, sizeof(num_c)); num_a[0] = 0; while(a) { num_a[++num_a[0]] = a % 2; a /= 2; } num_b[0] = 0; while(b) { num_b[++num_b[0]] = b % 2; b /= 2; } num_c[0] = 0; while(c) { num_c[++num_c[0]] = c % 2; c /= 2; } } ll dfs(int pos, int a, int b, int an, int xo) { if(!pos) return 1; if(dp[pos][a][b][an][xo] != -1) return dp[pos][a][b][an][xo]; int ua = a ? num_a[pos] : 1; int ub = b ? num_b[pos] : 1; int uan = an ? num_c[pos] : 1; int uxo = xo ? num_c[pos] : 0; ll ret = 0; for (int i = 0; i &lt;= ua; i ++) for (int j = 0; j &lt;= ub; j ++) if((i&amp;j) &lt;= uan &amp;&amp; (i^j) &gt;= uxo) ret += dfs(pos-1, a&amp;&amp;(i==ua), b&amp;&amp;(j==ub), an&amp;&amp;((i&amp;j)==uan), xo&amp;&amp;((i^j)==uxo)); return dp[pos][a][b][an][xo] = ret; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { ll a, b, c; scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c); GetNum(a, b, c); memset(dp, -1, sizeof(dp)); ll ans = dfs(32, 1, 1, 1, 1) - max(0ll, a-c+1) - max(0ll, b-c+1); cout &lt;&lt; a*b-ans &lt;&lt; endl; } return 0; } I:Chessboard题意给你一个N，M，然后你可以任意构造一个 k * k的矩阵，使得矩阵内每个元素最少是M，且任意不同行不同列的 k 个元素总和不超过N且都相同，问有多少种构造方法。 思路 我们枚举$k$，我们可以把每个元素减去$M$，那么就相当于$N$减去$ k \\times M$,简化问题并且不影响答案 构造两个矩阵$Ai,Bi $对于这两个矩阵，我们可知他们前面的系数和为$T$则满足结果 等价于将$T$ 分成$2\\times k$份($a$，$b$各有$k$个)采用隔板法 （将$T$ 转换成$1$排，每两个$1$之间有一个隔间，那么$k \\times 2 + T$有$k \\times 2 - 1 +T$个​隔间，我们选择$k \\times 2 - 1$个隔间就可以把这些$1$分成$k \\times 2$份 为什么会算重，我们拿$T=3,k=2$来举个例子，比如$a_1=1,a_2=2,b_1=0,b_2=0$ 那这个矩阵就是长这个样子 $\\begin{bmatrix} a_1+b_1 &amp;a_1+b_2 \\\\\\ a_2+b_1 &amp;a_2+b_2 \\end{bmatrix}$ $==&gt;$ $\\begin{bmatrix} 1 &amp; 1\\\\ 2 &amp;2 \\end{bmatrix}$ 跟$\\begin{bmatrix} a_1-1+b_1+1 &amp;a_1-1+b_2+1\\\\ a_2-1+b_1+1 &amp;a_2-1+b_2+1 \\end{bmatrix}$ $==&gt;$ $\\begin{bmatrix} 1 &amp; 1\\\\ 2 &amp;2 \\end{bmatrix}$ 是相同的，也就是当$a_i$全部减1，而$b_i$全部加1时，跟原来的矩阵相同，所以这就重复了,那去重也就是这样去 PS:这篇博客其实是我扒CM大佬的=^= AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; const int inf = 0x3f3f3f3f; const int mod = 998244353; ll fac[maxn], inv[maxn]; ll Ksm(ll a, ll b, ll p) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res; } void Fac() { fac[0] = 1; for (int i = 1; i &lt; maxn; i ++) fac[i] = (fac[i-1] * i) % mod; inv[maxn-1] = Ksm(fac[maxn-1], mod-2, mod); for (int i = maxn-2; i &gt;= 0; i --) inv[i] = inv[i+1] * (i+1) % mod; } ll C(int n, int m) { if(n &lt; 0 || m &lt; 0 || n &lt; m) return 0; return fac[n] * inv[m] % mod * inv[n-m] % mod; } int main() { Fac(); int T; scanf(\"%d\", &amp;T); while(T --) { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); ll ans = 0; for (int k = 1; k * m &lt;= n; k ++) { int tt = n - k*m; for (int t = 0; t &lt;= tt; t ++) { ans += C(t+k+k-1, k+k-1); if(t &gt;= k) ans -= C(t+k-1, k+k-1); ans = (ans % mod + mod) % mod; } } printf(\"%lld\\n\", ans); } return 0; } K:Function题意$csl(p,x)= \\begin{cases} 3e+1 &amp; x=p^e\\&amp; p\\in prime \\&amp; p = a^2+b^2\\\\1 &amp; x=p^e \\&amp; p!= a^2+b^2\\\\0 &amp; others\\end{cases}$ $tl(p,x)=\\max\\limits_{d|x}csl(p,d)$ 求$S=\\sum\\limits_{i=1}^{n}\\prod\\limits_{p} tl(p,i)$ 思路可得知 $tl(p,x)=\\begin{cases}3e+1&amp; x=p^e\\&amp; p\\in prime \\&amp;p=a^2+b^2 \\\\1 &amp; others\\end{cases}$ $f(x)=\\prod\\limits_{d|n}\\begin{cases}3e+1&amp; x=p^e\\&amp; p\\in prime \\&amp;p=a^2+b^2 \\\\1 &amp; others\\end{cases}$ 答案就是$f(i)$的前缀和,即$S=\\sum\\limits_{i=1}^{n}f(i)$ 我们先不考虑$p=a^2+b^2$，考虑$i$为质数时的情况$f(i)=3+1$ $i$为质数次幂的情况$f(p^e)=3e+1$ 这样可以快速算出i为质数和i的质数次幂的情况 可以用$min_25$筛来求这个前缀和 那么现在我们来考虑$p=a^2+b^2$这个限制，因为$min_25$筛由构造一个函数，把所有数字看成质数， 我们可以设$h[i][4]$，来代表i以前由多少数字余数为$0，1，2，3$，通过dp可以得到有多少质数余数为$0，1，2，3$ 因为费马二次定理，我们知道模$4$与$1$的可以分解成$a^2+b^2$，而模$4$余$3$的一定不行，那么质数部分我们就都算出来了，下面的合数部分就用$min_25$筛就好了 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; ll sum[maxn][4], prime[maxn], tot, h[maxn][4]; ll w[maxn], m, id1[maxn], id2[maxn]; ll sqr; bool vis[maxn]; ll f(ll p, ll e) { if(p % 4 == 1) return 3 * e + 1; return 1; } ll init(ll n) { for (int i = 0; i &lt; 4; i ++) sum[0][i] = 0; for (int i = 1; i &lt;= n; i ++) vis[i] = 0; vis[1] = 1; tot = 0; for (int i = 2; i &lt;= n; i ++) { if(!vis[i]) { prime[++tot] = i; for (int j = 0; j &lt; 4; j ++) sum[tot][j] = sum[tot-1][j] + (i % 4 == j); } for (int j = 1; j &lt;= tot; j ++) { if(i * prime[j] &gt; n) break; vis[i*prime[j]] = 1; if(i % prime[j] == 0) break; } } } void getW(ll n) { m = 0;//离散下标 for (ll l = 1, r; l &lt;= n; l = r + 1) { r = n/(n/l); w[++m] = n/l;//把所有数字当成质数 h[m][1] = w[m] / 4 + (w[m] % 4 &gt;= 1) - 1; h[m][2] = w[m] / 4 + (w[m] % 4 &gt;= 2); h[m][3] = w[m] / 4 + (w[m] % 4 &gt;= 3); h[m][4] = w[m] / 4; if(w[m] &lt;= sqr) id1[w[m]] = m; else id2[n/w[m]] = m; } } void getG(ll n) {//dp都质数模4的个数 for (ll i = 1; i &lt;= tot; i ++) { for (ll j = 1; j &lt;= m &amp;&amp; prime[i] * prime[i] &lt;= w[j]; j ++) { ll d = w[j] / prime[i]; ll id = d &lt;= sqr ? id1[d] : id2[n/d]; for (int r = 0; r &lt; 4; r ++) h[j][r*prime[i]%4] = h[j][r*prime[i]%4] - h[id][r] + sum[i-1][r]; } } } ll S(ll x, ll y, ll n) { if(x &lt;= prime[y-1] || x &lt;= 1) return 0; ll id = x &lt;= sqr ? id1[x] : id2[n/x]; ll ans = h[id][3] - sum[y-1][3] + 4 * (h[id][1] - sum[y-1][1]);//模4余1的值为4，余3的值为1 if(y == 1) ans ++; for (ll i = y; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= x; i ++) { ll t = prime[i]; for (int j = 1; t &lt;= x; j ++, t = t * prime[i]) ans = ans + f(prime[i], j) * (S(x/t, i+1, n) + (j != 1)); } return ans; } int main() { int t; scanf(\"%d\", &amp;t); while(t --) { ll n; scanf(\"%lld\", &amp;n); sqr = sqrt(n); init(sqr); getW(n); getG(n); printf(\"%lld\\n\", S(n, 1, n) + 1);//S(n,1,n)+f(1) } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"牛客多校第五场","slug":"牛客多校第五场","date":"2019-08-14T02:35:51.000Z","updated":"2021-05-31T11:58:01.214Z","comments":true,"path":"/b40c00ff/","link":"","permalink":"http://orzff.cn/b40c00ff/","excerpt":"牛客多校第五场","text":"B:generator 1题意给你$x_0,x_1,a,b, x_i=ax_{i-1}+bx_{i-2}$让你求出$x_n$ 思路典型的矩阵快速幂，但是n的范围太大，所以得快速幂得用十进制快速幂 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e6 + 5; ll mod; struct Matrix{ ll mat[2][2]; Matrix() {memset(mat, 0, sizeof(mat));}; void init() { mat[0][0] = mat[1][1] = 1; } void init(ll a, ll b) { mat[0][0] = 0; mat[0][1] = b; mat[1][0] = 1; mat[1][1] = a; } void operator = (Matrix x) { for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) mat[i][j] = x.mat[i][j]; } }; void Print(Matrix x) { for (int i = 0; i &lt;= 1; i ++) { for (int j = 0; j &lt;= 1; j ++) cout &lt;&lt; x.mat[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl; } } Matrix operator * (Matrix x, Matrix y) { Matrix t; for (int i = 0; i &lt;= 1; i ++) for (int j = 0; j &lt;= 1; j ++) for (int k = 0; k &lt;= 1; k ++) t.mat[i][j] = (t.mat[i][j] + x.mat[i][k] * y.mat[k][j]) % mod; return t; } Matrix Ksm(Matrix x, ll b) { //cout &lt;&lt; b &lt;&lt; endl; Matrix t; t.init(); while(b) { if(b &amp; 1) t = t * x; x = x * x; b &gt;&gt;= 1; } //Print(t); return t; } int main() { ll x0, x1, a, b; scanf(\"%lld %lld %lld %lld\", &amp;x0, &amp;x1, &amp;a, &amp;b); char s[maxn]; scanf(\"%s%lld\", s, &amp;mod); int len = strlen(s); reverse(s, s+len); Matrix t, ans; t.init(a, b); ans.mat[0][0] = x0; ans.mat[0][1] = x1; Matrix res; res.init(); for (int i = 0; i &lt; len; i ++) { res = res * Ksm(t, s[i]-'0'); t = Ksm(t, 10); // Print(res); // Print(t); } ans = ans * res; printf(\"%lld\\n\", ans.mat[0][0]); return 0; } C:generator 2题意有这么一个递推式$x_i=(a\\cdot x_{i-1}+b)\\mod p$，让你求$v$在$[1,n-1]$中第一次出现的位置 思路因为递推式模$p$，所以$x$的循环节一定小于$p$， 而$x$又是这种形式$x_n=a(a(a(ax+b)+b)+b)+b$ 所以我们的任务就变成$A^{m} \\equiv v\\mod p$求最小的$m$ ${A^1=x,A^2=(ax+b),A^3=a(ax+b)+b,A^4=a(a(ax+b)+b)+b)+b}$ 而$A^m\\equiv v\\mod p$明显可以用BSGS 但是BSGS的一个使用条件能不能求出$A^{-i*S}$ 但是我们怎么求出$A^{-i*S}$呢 正常的加是乘a加b，那么除就是除a减$\\frac{b}{a}$ 举个例子: $x_0=x,x_1=ax+b,x_2=a(ax+b)+b,x_3=a(a(ax+b)+b)+b$ 我们从$x_3$降到$x_1$,$x_3$先除$a$再减去$\\frac{b}{a}$变成$x_2$，然后再除$a$减去$\\frac{b}{a}$变成$x_1$ 那我们从$A^{2S+j}$降到$A^{S+j}$只需要进行$S$次操作即可 这样我们就可以用BSGS了 跟BSGS的步骤差不多，我们可以把式子化成 $A^{i*S+j}\\equiv v\\mod p$ 我们可以预处理出来$A^S$ ，然后遍历找到一个$A^j\\equiv vA^{-iS}\\mod p$ 也就是说在这个式子中$A^{-i*S}$不是一个值，而是一种操作，把$v$所代表的次数降下$S$ $x_0=1,x_1=2*1+1,x_2=,x_4=15,x_5=31$ 因为我们已经预处理了一个$A^S$,那么在我们遍历$i$的过程中每次降下一个$S$，知道找到或者找不到 用Hash存一下$A^j$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long typedef pair&lt;int, int&gt;pis; const int limit = 1e6; pis d[limit+6]; int vals[limit+6], pos[limit+6]; int Ksm(ll a, int b, int p) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res; } int inv(int a, int p) { return Ksm(a, p-2, p); } void solve() { ll n, x0, a, b, p; int Q; scanf(\"%lld %lld %lld %lld %lld %d\", &amp;n, &amp;x0, &amp;a, &amp;b, &amp;p, &amp;Q); if(!a) { while(Q --) { int v; scanf(\"%d\", &amp;v); if(v == x0) printf(\"0\\n\"); else if(v == b) printf(\"1\\n\"); else printf(\"-1\\n\"); } return ; } d[0] = {x0, 0}; for (int i = 1; i &lt;= limit; i ++) { int val = (a*d[i-1].first+b) % p; d[i] = {val, i}; } sort(d, d+limit+1); int cnt = 0; for (int i = 0; i &lt;= limit; i ++) { vals[cnt] = d[i].first; pos[cnt++] = d[i].second; while(d[i].first == d[i+1].first &amp;&amp; i+1 &lt;= limit) i++; } int inv_a = inv(a, p); int inv_b = (p-b) % p * inv_a % p; ll aa = 1, bb = 0; for (int i = 0; i &lt;= limit; i ++) { aa = aa * inv_a % p; bb = (bb * inv_a + inv_b) % p; } while(Q --) { int v; scanf(\"%d\", &amp;v); int it = lower_bound(vals, vals+cnt, v) - vals; if(it &lt; cnt &amp;&amp; vals[it] == v) { if(pos[it] &lt; n) printf(\"%d\\n\", pos[it]); else printf(\"-1\\n\"); continue; } int m = p/(limit+1) + 3, flag = 0; for (int i = 1; i &lt;= m; i ++) { v = (aa * v + bb) % p; it = lower_bound(vals, vals+cnt, v) - vals; if(it&lt;cnt &amp;&amp; vals[it] == v) { flag = 1; int res = i*(limit+1)+pos[it]; if(res&gt;=n) res = -1; printf(\"%d\\n\", res); break; } } if(!flag) printf(\"-1\\n\"); } } int main() { int T; scanf(\"%d\", &amp;T); while(T --) solve(); return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"牛客多校第二场","slug":"牛客多校第二场","date":"2019-08-11T12:51:17.000Z","updated":"2021-05-31T11:58:01.213Z","comments":true,"path":"/3bd8/","link":"","permalink":"http://orzff.cn/3bd8/","excerpt":"牛客多校第二场","text":"A:Eddy Walker题意给你一个n的点的环，一开始从0号点开始，每次可以前进1或者后退1，问第一次站在m号点的时候已经遍历完所有点的概率，求出前缀概率积 思路一： 暴力打表找规律 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; double p[10]; bool vis[10]; int n; bool Check() { for (int i = 0; i &lt; n; i ++) if(!vis[i]) return false; return true; } void dfs(int idx, double px) { if(px &lt; 1e-10) return ; vis[idx] = 1; if(!Check()) { int nxt = (idx+1)%n; int tmp = vis[nxt]; vis[nxt] = 1; dfs(nxt, px*0.5); vis[nxt] = tmp; nxt = (idx-1+n)%n; tmp = vis[nxt]; vis[nxt] = 1; dfs(nxt, px*0.5); vis[nxt] = tmp; }else p[idx] += px; } int main() { for (n = 1; n &lt;= 7; n ++) { printf(\"n: %d\\n\", n); memset(p, 0, sizeof(p)); memset(vis, 0, sizeof(vis)); dfs(0, 1); for (int i = 0; i &lt; n; i ++) { printf(\"i: %d, p: %lf\\n\", i, p[i]); } } return 0; } 这是打表的结果，可以发现结果与m无关(当m&gt;0时)而且近似为$\\frac{1}{n-1}$ 二：数学分析:因为是最后站在一个非0的位置上，而每个非零的点的最后一次到达的概率是相同的，所以是$\\frac{1}{n-1}$ B:Eddy Walker2题意现在是给你一条链，从0点出发，一个最多走k步，每一步的概率都是$\\frac{1}{k}$ ,问最后走到n的概率 思路根据题意可以写出一个递推式子： $dp[i] = \\frac{1}{k}\\sum\\limits_{i=1}^{k}dp[n-i]$ 如果n很小的话，可以直接用dp来写，但是n的大小是$1e^{9}$，所以我们就得用BM直接套板子线性递推 但是有一个问题，就是n可能为无穷，我们可以这样来写， 我们每次行动的移动记录期望是$\\frac{1}{k}\\sum\\limits_{i=1}^{k}i=\\frac{(k+1)k}{2k}=\\frac{k+1}{2}$ ,也就是每行动一次大概移动$\\frac{k+1}{2}$ ，而我们移动到n的次数可能为m次，那么移动的距离期望就是$\\frac{(k+1)m}{2}$ 而n在其中，在这$\\frac{(k+1)m}{2}$个点中，我们一共会走m个点，那么就是n在这m个点之间的概率$\\frac{1}{m}$ , 期望就是$m$ ,而在整体的概率就是$\\frac{m}{\\frac{(k+1)m}{2}}=\\frac{2}{k+1}$ $dp[i]=\\begin{cases} \\frac{1}{k}\\cdot (dp[i-1]+dp[i-2]+…+dp[i-k]),i&gt;=k\\\\ \\frac{2}{k+1},i=\\infty \\\\\\end{cases}$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const ll mod = 1e9 + 7; #define sz(x) ((int)(x).size()) typedef vector&lt;ll&gt; VI; ll Ksm(ll a, ll b) { ll res = 1; a %= mod; assert(b &gt;= 0); while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } int _, n; namespace Linear_Seq{ const int N = 10010; ll res[N], base[N], _c[N], _md[N]; vector&lt;int&gt; Md; void Mul(ll *a, ll *b, int k) { for (int i = 0; i &lt; k+k; i ++) _c[i] = 0; for (int i = 0; i &lt; k; i ++) if(a[i]) for (int j = 0; j &lt; k; j ++) _c[i+j] = (_c[i+j] + a[i]*b[j]) % mod; for (int i = k + k - 1; i &gt;= k; i --) if(_c[i]) for (int j = 0; j &lt; sz(Md); j ++) _c[i-k+Md[j]] = (_c[i-k+Md[j]] - _c[i] * _md[Md[j]]) % mod; for (int i = 0; i &lt; k; i ++) a[i] = _c[i]; } int solve(ll n, VI a, VI b) { ll ans = 0, pnt = 0; int k = sz(a); assert(sz(a) == sz(b)); for (int i = 0; i &lt; k; i ++) _md[k-1-i] = -a[i]; _md[k] = 1; Md.clear(); for (int i = 0; i &lt; k; i ++) if(_md[i]) Md.push_back(i); for (int i = 0; i &lt; k; i ++) res[i] = base[i] = 0; res[0] = 1; while((1ll&lt;&lt;pnt) &lt;= n) pnt ++; for (int p = pnt; p &gt;= 0; p --) { Mul(res, res, k); if((n&gt;&gt;p) &amp; 1) { for (int i = k-1; i &gt;= 0; i --) res[i+1] = res[i]; res[0] = 0; for (int j = 0; j &lt; sz(Md); j ++) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; } } for (int i = 0; i &lt; k; i ++) ans = (ans + res[i] * b[i]) % mod; if(ans &lt; 0) ans += mod; return ans; } VI BM(VI s) { VI C(1, 1), B(1, 1); int L = 0, m = 1, b = 1; for (int n = 0; n &lt; sz(s); n ++) { ll d = 0; for (int i = 0; i &lt; L + 1; i ++) d = (d + (ll)C[i] * s[n-i]) % mod; if (d == 0) ++m; else if(2 * L &lt;= n) { VI T = C; ll c = mod - d * Ksm(b, mod-2) % mod; while(sz(C) &lt; sz(B) + m) C.push_back(0); for (int i = 0; i &lt; sz(B); i ++) C[i+m] = (C[i+m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m = 1; }else { ll c = mod - d * Ksm(b, mod-2) % mod; while(sz(C) &lt; sz(B) + m) C.push_back(0); for (int i = 0; i &lt; sz(B); i ++) C[i+m] = (C[i+m] + c * B[i]) % mod; ++ m; } } return C; } int Gao(VI a, ll n) { VI c = BM(a); c.erase(c.begin()); for (int i = 0; i &lt; sz(c); i ++) c[i] = (mod-c[i]) % mod; return solve(n, c, VI(a.begin(), a.begin()+sz(c))); } }; using namespace Linear_Seq; void solve() { ll n, k; scanf(\"%lld %lld\", &amp;k, &amp;n); if(n == 0) { printf(\"1\\n\"); return ; }else if(n == -1) { printf(\"%lld\\n\", 2 * Ksm(k+1, mod-2) % mod); return ; } VI dp(3*k, 0), v; dp[0] = 1; v.push_back(1); for (int i = 1; i &lt;= k; i ++) { for (int j = 0; j &lt; i; j ++) dp[i] = (dp[i] + dp[j]) % mod; dp[i] = dp[i] * Ksm(k, mod-2) % mod; v.push_back(dp[i]); } for (int i = k+1; i &lt;= 2 * k; i ++) { for (int j = 1; j &lt;= k; j ++) dp[i] = (dp[i] + dp[i-j]) % mod; dp[i] = dp[i] * Ksm(k, mod-2) % mod; v.push_back(dp[i]); } printf(\"%lld\\n\", Gao(v, n)); } int main() { int T; scanf(\"%d\", &amp;T); while(T --) solve(); return 0; } E:MAZE题意给你一个NxM的地图，0表示可走，1表示不可走， 有$Q$次询问，可能会对某一位置取反，可能问你从$(1,a)$到$(n,b)$有多少走法 思路因为题目 要求不能往回走，所以如果我们从下面开始走，那么我们在横向移动是就不能改变方向，然后向上走 我们先用$dp$来考虑一下做法：设$dp[i][j]$是经由下面$dp[i-1][j]$走过来的走法数，那么从左边或右边走过来的方法数呢，我们可以在最后在加一层，那么$dp[0][j]$就加上了第1层左右到达$dp[1][j]$的方法数 那么$dp[i][j] = sum(dp[i-1][j]+dp[i-1][j-1] + … dp[i-1][j-k])+sum(dp[i-1][j+1]+dp[i-1][j+2]+…+dp[i-1][j+k])$ $dp[i][j]$由$i-1$层，$i$的左边第一个1和$i$的右边第一个1，这么一段区间里的$dp$值转移过来 比如这样一个2X6的地图, $dp[1][3]=dp[2][2]+dp[2][3]+dp[2][4]+d[2][5]$ $dp[1][4]=dp[2][2]+dp[2][3]+dp[2][4]+d[2][5]$ 由于上一层的每个值都是有下面的值组成，那么我们就可以构造出一个矩阵 这样我们就能从第$i$层转移到第$i-1$层了 现在来考虑地图修改的情况 这n个矩阵我们可以用一个线段树来维护，地图修改时用线段树来修改矩阵就行了 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 5e4 + 5; const int mod = 1e9+7; char c[maxn][15]; int dp[maxn][15]; int N, M, Q; struct Maze { int maze[15][15]; Maze() {memset(maze, 0, sizeof(maze));} void init() {for (int i = 0; i &lt; 15; i ++) maze[i][i] = 1;} Maze friend operator * (Maze a, Maze b) { Maze c; for (int i = 0; i &lt; M; i ++) for (int j = 0; j &lt; M; j ++) for (int k = 0; k &lt; M; k ++) c.maze[i][j] = (c.maze[i][j] + 1ll * a.maze[i][k] * b.maze[k][j]) % mod; return c; } }; struct Seg{ Maze w[maxn&lt;&lt;2]; void Build(int rt, int l, int r) { if(l == r) { for (int i = 0; i &lt; M; i ++) { if(c[l][i] == '0') { for (int j = i; j &gt;= 0; j --) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; for (int j = i; j &lt; M; j ++) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; } } return ; } int m = (l + r) &gt;&gt; 1; Build(rt*2, l, m); Build(rt*2+1, m+1, r); w[rt] = w[rt*2] * w[rt*2+1]; } void Updata(int rt, int l, int r, int pos) { if(l == r) { for (int i = 0; i &lt; M; i ++) for (int j = 0; j &lt; M; j ++) w[rt].maze[i][j] = 0; for (int i = 0; i &lt; M; i ++) { if(c[l][i] == '0') { for (int j = i; j &gt;= 0; j --) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; for (int j = i; j &lt; M; j ++) if(c[l-1][j] == '1') break; else w[rt].maze[j][i] = 1; } } return ; } int m = (l + r) &gt;&gt; 1; if(pos &lt;= m) Updata(rt*2, l, m, pos); else Updata(rt*2+1, m+1, r, pos); w[rt] = w[rt*2] * w[rt*2+1]; } void Updata(int pos) { Updata(1, 1, N, pos); } }seg; int main() { scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;Q); for (int i = 0; i &lt; N; i ++) scanf(\"%s\", c[i]); for (int i = 0; i &lt; M; i ++) c[N][i] = '0'; seg.Build(1, 1, N); //seg.Print(1, 1, N); while(Q --) { int op, a, b; scanf(\"%d %d %d\", &amp;op, &amp;a, &amp;b); if(op == 1) { if(c[a-1][b-1] == '0') c[a-1][b-1] = '1'; else c[a-1][b-1] = '0'; if(a &gt; 1) seg.Updata(a-1); seg.Updata(a); } else { Maze ans = seg.w[1]; Maze t1; t1.maze[0][a-1] = 1; t1 = t1 * ans; printf(\"%d\\n\", t1.maze[0][b-1]); } } return 0; } F:Partition problen题意给你2N个人，每对人如果不在同一队的话，有一个竞争值，你要把这些人分为人数相等的两个队，使得竞争值最大 思路直接暴力 AC代码//队友代码： #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; vector&lt;int&gt; a, b; int c[30][30]; int n; ll ans = 0; void dfs(int idx, ll cur) { if(idx == 2 * n + 1) { ans = max(ans, cur); return ; } ll sum = 0; if(a.size() &lt; n) { a.push_back(idx); sum = 0; for (int &amp;v: b) sum += c[idx][v]; dfs(idx+1, cur+sum); a.pop_back(); } if(b.size() &lt; n) { b.push_back(idx); sum = 0; for (int &amp;v: a) sum += c[idx][v]; dfs(idx + 1, cur + sum); b.pop_back(); } } int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= 2*n; i ++) for (int j = 1; j &lt;= 2*n; j ++) scanf(\"%d\", &amp;c[i][j]); dfs(1, 0); printf(\"%lld\\n\", ans); return 0; } H:Second Large Rectangle题意给你一个NXM的矩阵，只有01组成，求第二大的全为1的子矩阵 思路单调栈求最大子矩阵，在过程中就也求出了第二大的子矩阵，然后第一大的宽减一，高减一，和第二大的比较输出最大的 单调栈求最大子矩阵的方法： 逐层遍历，对于每一层求出一个h[]，h表示以此层为底1的高度 比如： 这样一个矩阵,h为： 这样对于每一层就变成一个求最大矩阵的形式， 对于每一层用单调栈求出最大矩阵，注意要记得去重，像上图中的第二层，第二列，第三列，第四列求出的是同一个矩阵，不去重的话无法跟第二大的比较，去重很简单，就记录一下，左边界和上边界即可， AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e3+5; const int inf = 0x3f3f3f3f; typedef pair&lt;int, int&gt; pis; struct Pis{ int res, x, h; bool friend operator &lt; (Pis a, Pis b) { return a.res &gt; b.res; } }; char c[maxn][maxn]; int maz[maxn][maxn], h[maxn]; int pre[maxn], suf[maxn]; stack&lt;pis&gt; sta; int n, m; map&lt;pis, int&gt; mp; vector&lt;Pis&gt; ans; void getPS() { while(!sta.empty()) sta.pop(); sta.push(pis{-inf, 0}); for (int j = 1; j &lt;= m; j ++) { while(h[j] &lt;= sta.top().first) sta.pop(); pre[j] = sta.top().second+1; sta.push(pis{h[j], j}); } while(!sta.empty()) sta.pop(); sta.push(pis{-inf, m+1}); for (int j = m; j &gt;= 1; j --) { while(h[j] &lt;= sta.top().first) sta.pop(); suf[j] = sta.top().second-1; sta.push(pis{h[j], j}); } } void getH(int i) { for (int j = 1; j &lt;= m; j ++) if(maz[i][j]) h[j] += 1; else h[j] = 0; } int main() { scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) scanf(\"%s\", c[i]+1); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) maz[i][j] = c[i][j] - '0'; for (int i = 1; i &lt;= n; i ++) { getH(i); getPS(); mp.clear(); for (int i = 1; i &lt;= m; i ++) { if(!mp[pis{pre[i], h[i]}]) { mp[pis{pre[i], h[i]}] = 1; int sum = (suf[i]-pre[i]+1) * h[i]; ans.push_back(Pis{sum, pre[i], h[i]}); } } } sort(ans.begin(), ans.end()); if(ans.size() &lt;= 1) printf(\"0\\n\"); else { int tx = ans[0].res/ans[0].h, ty = ans[0].h; printf(\"%d\\n\", max(ans[1].res, max(tx*(ty-1), (tx-1)*ty))); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"牛客多校第一场","slug":"牛客多校第一场","date":"2019-08-11T12:50:58.000Z","updated":"2021-05-31T11:58:01.203Z","comments":true,"path":"/aba2/","link":"","permalink":"http://orzff.cn/aba2/","excerpt":"牛客多校第一场","text":"A. Equivalent Prefixes题意两个序列相等的条件是RMQ(u,l,r) = RMQ(u,l,r)，($1\\leq l \\leq r\\leq m$) ,RMQ(u,l,r)代表序列u，的任意区间(l,r）的最小值的序号，求一个最大的P，使得$\\lbrace a_1, a_2,…a_p \\rbrace$和$\\lbrace b_1,b_2,…b_p \\rbrace$相等 思路我们假设$last_a[i]= max\\lbrace j|j&lt;i \\&amp;\\&amp; a_j&lt;a_i\\rbrace$ ,也就是$a_i$左边序号最大的小于$a_i$的数字的位置， 我们用单调栈去求这个last，求得以后 那么我们求序列[1,r]的RMQ，就是找到last[r],last[last[r]],last[last[last[r]],的值 如果两个序列的last数组相同，那么就证明$RMQ(a,l,r)=RMQ(b,l,r)$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; int a[maxn], b[maxn]; int lasta[maxn], lastb[maxn]; stack&lt;pis&gt; sta; int main() { int n; while(~scanf(\"%d\", &amp;n)) { for (int i = 1; i &lt;= n; i ++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n; i ++) scanf(\"%d\", &amp;b[i]); while(!sta.empty()) sta.pop(); sta.push(pis{0, 0}); for (int i = 1; i &lt;= n; i ++) { while(sta.top().first &gt; a[i]) sta.pop(); lasta[i] = sta.top().second; sta.push((pis{a[i], i})); } while(!sta.empty()) sta.pop(); sta.push(pis{0, 0}); for (int i = 1; i &lt;= n; i ++) { while(sta.top().first &gt; b[i]) sta.pop(); lastb[i] = sta.top().second; sta.push((pis{b[i], i})); } int cnt = 0; for (int i = 1; i &lt;= n; i ++) { if(lasta[i] == lastb[i]) cnt ++; else break; } cout &lt;&lt; cnt &lt;&lt; endl; } return 0; } B.Integration题意已知$\\int_0^{\\infty}\\frac{1}{1+x^2}dx=\\frac{\\pi}{2}$ 求：$\\frac{1}{\\pi}\\int_0^{\\infty}\\frac{1}{\\prod\\limits_{i=1}^{n}(a_i^2+x^2)}dx$ 思路我们先算$\\frac{1}{\\prod\\limits_{i=1}^{n}(a_i^2+x^2)}$$=\\frac{1}{a_1^2+x^2} \\frac{1}{a_2^2+x^2}\\frac{1}{\\prod\\limits_{i=3}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{a_1^2+x^2}-\\frac{1}{a_2^2+x^2})\\frac{1}{\\prod\\limits_{i=3}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{a_1^2+x^2}-\\frac{1}{a_2^2+x^2})\\frac{1}{a_3^2+x^2}\\frac{1}{\\prod\\limits_{i=4}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{a_1^2+x^2}\\frac{1}{a_3^2+x^2}-\\frac{1}{a_2^2+x^2}\\frac{1}{a_3^2+x^2})\\frac{1}{\\prod\\limits_{i=4}^{n}a_i^2+x^2}\\\\=\\frac{1}{(a_2^2-a_1^2)}(\\frac{1}{(a_1^2-a_3^2)}(\\frac{1}{a_3^2+x^2}-\\frac{1}{a_1^2+x^2})-\\frac{1}{(a_3^2-a_2^2)}(\\frac{1}{a_2^2+x^2}-\\frac{1}{a_3^2+x^2}))\\frac{1}{\\prod\\limits_{i=4}^{n}a_i^2+x^2}\\\\=(\\frac{1}{a_2^2-a_1^2}\\frac{1}{a_3^2-a_1^2})\\frac{1}{a_1^2+x^2}+(\\frac{1}{a_1^2-a_2^2}\\frac{1}{a_3^2-a_2^2})\\frac{1}{a_2^2+x^2}+(\\frac{1}{a_1^2-a_3^2}\\frac{1}{a_2^2-a_3^2})\\frac{1}{a_3^2+x^2}\\\\=…\\\\=\\sum\\limits_{i=1}^{n}\\frac{1}{\\prod\\limits_{j=1,j!=i}^{n}(a_j^2-a_i^2)}\\frac{1}{a_i^2+x^2}$我们设$c_i=\\prod\\limits_{j=1,j!=i}^{n}(a_j^2-a_i^2)$$原式=\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\frac{1}{a_i^2+x^2}$那么$\\frac{1}{\\pi}\\int_0^{\\infty}\\frac{1}{\\prod\\limits_{i=1}^{n}(a_i^2+x^2)}dx\\\\=\\frac{1}{\\pi}\\int_0^{\\infty}\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\frac{1}{a_i^2+x^2}\\\\=\\frac{1}{\\pi}\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\int_0^{\\infty}\\frac{1}{a_i^2+x^2}\\\\=\\frac{1}{\\pi}\\sum\\limits_{i=1}^{n}\\frac{1}{c_i}\\frac{\\pi}{2a_i}\\\\=\\sum\\limits_{i=1}^{n}\\frac{1}{2c_ia_i}$ AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; ll a[maxn], b[maxn]; int n; ll ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) { if(!b) { x = 1; y = 0; return a; } ll d = ex_gcd(b, a % b, x, y); ll t = x; x = y; y = t - a / b * y; return d; } ll getInv(ll a, ll p) { ll x, y; ex_gcd(a, p, x, y); x = ((x % p) + p) % p; return x; } ll solve(ll x, int idx) { ll res = x; for (int i = 1; i &lt;= n; i ++) { if(i == idx) continue; res *= (b[i] - b[idx] + mod) % mod; res %= mod; } return getInv(res, mod); } int main() { while(~scanf(\"%d\", &amp;n)) { for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;a[i]); b[i] = a[i] * a[i] % mod; } ll ans = 0; for (int i = 1; i &lt;= n; i ++) ans = (ans + solve(a[i], i)) % mod; printf(\"%lld\\n\", ans * getInv(2, mod) % mod); } return 0; } C:Euclidean Distance题意给你一些点$(\\frac{a_1}{m},\\frac{a_2}{m},…,\\frac{a_n}{m})$,让你找一些$p_i$,使得$\\sum\\limits_{i=1}^{n}(p_i-a_i)^2$最小,$p_i$满足$\\sum\\limits_{i=1}^{n}p_i=1,p_i&gt;=0$ 思路听说题解是用拉格朗日乘子法，但我也不会，我看到有别人用的是贪心因为所有的$a_i$都是除以m的，所以我们把$a_i$和$p_i$都乘以m，那么我们就变成了用m步使得面积最小（负数的面积不能变小只能变大） 那么贪心的做法就是把大的尽量的变小，因为是排过序的，所以前面的要比后面的大。每次都试着把前i-1块变得跟第i块平齐，如果不能就把前(i-1)块全部减小$\\frac{k}{i-1}$,保持前面的平齐 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 5e5 + 5; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; ll a[maxn]; bool cmp(ll a, ll b) { return a &gt; b; } ll gcd(ll a, ll b) { return !b ? a : gcd(b, a % b); } int main() { ll n, m; while(~scanf(\"%lld %lld\", &amp;n, &amp;m)) { for (int i = 1; i &lt;= n; i ++) scanf(\"%lld\", &amp;a[i]); sort(a + 1, a + n + 1, cmp); ll k = m; for (int i = 2; i &lt;= n; i ++) { if(k &gt; (a[i-1] - a[i]) * (i-1)) { k -= 1ll * (a[i-1] - a[i]) * (i-1); }else { for (int j = 1; j &lt;= i-1; j ++) a[j] = 1ll* (i-1) * a[i-1] - k; for (int j = i; j &lt;= n; j ++) a[j] = 1ll * a[j] * (i-1); m = 1ll * m * (i-1); k = 0; break; } } if(k) { for (int i = 1; i &lt;= n; i ++) a[i] = 1ll * (a[n] * n) - k; m = 1ll * m * n; } ll ans = 0; for (int i = 1; i &lt;= n; i ++) ans = (ans + 1ll * a[i] * a[i]); m = 1ll * m * m; ll k1 = gcd(ans, m); ans /= k1; m /= k1; if(m == 1) printf(\"%lld\\n\", ans); else printf(\"%lld/%lld\\n\", ans, m); } return 0; } E:ABBA题意给你n个AB和m个BA，问你能构造出多少个长度为(n+m)*2并且能组成n个AB和B个BA的串 思路如果我们把A看做-1，B看成1，那么构成串的前缀和应该在[-n,m]，如果不在就是不合法的串然后我们在用dp[i][j]来表示构成串的前i+j位中有i个A,j个B，那么我们考虑dp[i][j]—&gt;(dp[i+1][j],dp[i][j+1])转移是只需要判断(dp[i+1][j],dp[i][j+1])是否合法即可 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 2e3 + 5; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; ll dp[maxn][maxn]; int main() { int n, m; while(scanf(\"%d %d\", &amp;n, &amp;m) != EOF) { for (int i = 0; i &lt;= n + m; i ++) for (int j = 0; j &lt;= n + m; j ++) dp[i][j] = 0; dp[0][0] = 1; for (int i = 0; i &lt;= n+m; i ++) { for (int j = max(0, i-n); j &lt;= min(n+m, i+m); j ++) { if(i) dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod; if(j) dp[i][j] = (dp[i][j] + dp[i][j-1]) % mod; } } printf(\"%lld\\n\", dp[n+m][n+m]); } return 0; } H:XOR题意给你一堆数，让你找他们子集xor和位0的的子集的大小之和 思路明显的线性集问题,首先我们要知道一堆数字组成线性集， 可以范围线性集外的数字和线性集内的数字，线性集内的数字可以xor出线性集外的所有子集 因为是问子集大小的和，所以我们可以转化成求每个数字的贡献 分为两种：我们设数字总数为$n$,线性集大小为$r$ 1.线性集外数字的贡献： 因为线性集内的数字能把线性集外的所有子集xor出来。 我们枚举线性集外的每一个数字$x$，那么如果线性集内的数字能把$x$xor出来那么，$x$对应的 线性集外的子集大小就为$2^{n-r-1}$,即这个数字的贡献就为$2^{n-r-1}$ 2.线性集内的数字的贡献： 对剩下的n-1个数字做一次线性集，看是否能把$x$xor出来，能xor出来贡献就为$2^{n-r-1}$，不能就为0 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 7; const int inf = 0x3f3f3f3f; const int mod = 1e9 + 7; typedef pair&lt;int, int&gt; pis; ll a[maxn]; bool vis[maxn]; vector&lt;int&gt; vec; struct LB{ ll b[65], cnt = 0; bool flag; void init() { memset(b, 0, sizeof(b)); flag = false; cnt = 0; } void ins(ll x) { for (int i = 62; i &gt;= 0; i --) if(x &gt;&gt; i) { if(!b[i]) { b[i] = x; cnt ++; return ; } x ^= b[i]; } flag = true; } bool Fin(ll x) { if(x == 0 &amp;&amp; flag) return true; for (int i = 62; i &gt;= 0; i --) { if(x &gt;&gt; i) { x ^= b[i]; } } return x == 0; } }A, B, C; ll Ksm(ll a, ll b) { ll res = 1; while(b) { if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } int main() { int n; while(~scanf(\"%d\", &amp;n)) { A.init(); B.init(); vec.clear(); for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld\", &amp;a[i]); if(!A.Fin(a[i])) { A.ins(a[i]); vec.push_back(i); }else B.ins(a[i]); } ll r = A.cnt; if(n == r) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } ll base = Ksm(2, n-r-1); ll sum = base * (n-r) % mod; for (auto &amp;it: vec) { ll x = a[it]; for (int i = 0; i &lt;= 62; i ++) C.b[i] = B.b[i]; C.flag = B.flag; for (auto &amp;it2: vec) if(it != it2) C.ins(a[it2]); if(C.Fin(x)) sum = (sum + base) % mod; } printf(\"%lld\\n\", sum); } return 0; } I:Points Division题意给你n个点，把点划分成A,B两部分，规定$i\\in A$ and $j\\in B$ and $x_j \\leq x_i$ and $y_i\\leq y_j$ 求最后$\\sum\\limits_{i\\in A}a_i+\\sum\\limits_{j\\in B}b_j$ 的最大值 思路我们发现$A$位于左上角，$B$位于右上角，$AB$边界时一条不下降的折线,所以我们可以沿着这条折线进行$dp$， 我们规定折线上的点全是$B$上的点。 首先我们先把纵坐标离散化，然后用$dp[i]$来表示当高度为i时最大值为多少 然后我们来求每一个点对结果的贡献， 对于一个点$i$,有两种情况: ​ 一：这个点不在折线上，那么大于$y_i$并且在折线上面的点$j$，$i$相当于位于$B$，那么$i$对于$j$的贡献就是$b_i$,对于那些小于$y_i$并且在折线上面的点$k$，$i$相当于位于$A$，那么$i$对$k$的贡献就是$a_i$, ​ 二：这个点在折线上，$dp[i]$就由从$1到i-1$的点的最大值+$b_i$ 也就是$dp[i] = \\max\\limits_{1\\leq j &lt; i} dp[j] + b_i$ 大体思路就是这样，因为我们要对区间操作，所以要用一个线段树来维护一下 注意因为我们默认折线上的点全是属于$B$的点，这就导致不会有$A=P$ and $B=\\emptyset$的情况，但是我们在点中加入一个$(0,0)$的点，因为$1\\leq x_i, y_i\\leq 10^9$那么所有的点都位于$(0,0)$上面，对$(0,0)$的贡献就是$B=\\emptyset$的值 AC代码#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int maxn = 1e5 + 5; struct Node{ ll x, y, a, b; bool friend operator &lt; (Node a, Node b) { if(a.x == b.x) return a.y &gt; b.y; return a.x &lt; b.x; } }node[maxn]; ll ty[maxn]; struct Seg{ ll dp[maxn&lt;&lt;2], lazy[maxn&lt;&lt;2]; void Build(int rt, int l, int r) { if (l == r) { dp[rt] = 0; lazy[rt] = 0; return ; } lazy[rt] = 0; dp[rt] = 0; int m = (l + r) &gt;&gt; 1; Build(rt&lt;&lt;1, l, m); Build(rt&lt;&lt;1|1, m+1, r); } void down(int rt) { lazy[rt&lt;&lt;1] += lazy[rt]; lazy[rt&lt;&lt;1|1] += lazy[rt]; dp[rt&lt;&lt;1] += lazy[rt]; dp[rt&lt;&lt;1|1] += lazy[rt]; lazy[rt] = 0; } void Updata(int rt, int l, int r, int L, int R, ll v) { //区间更新 if(l &gt;= L &amp;&amp; r &lt;= R) { dp[rt] += v; lazy[rt] += v; return ; } if(lazy[rt]) down(rt); int m = (l + r) &gt;&gt; 1; if(L &lt;= m) Updata(rt&lt;&lt;1, l, m, L, R, v); if(R &gt; m) Updata(rt&lt;&lt;1|1, m+1, r, L, R, v); dp[rt] = max(dp[rt&lt;&lt;1], dp[rt&lt;&lt;1|1]); } void Updata(int rt, int l, int r, int w, ll v) { //单点更新 if(l == r) { dp[rt] = max(dp[rt], v); return ; } if(lazy[rt]) down(rt); int m = (l + r) &gt;&gt; 1; if(w &lt;= m) Updata(rt&lt;&lt;1, l, m, w, v); else Updata(rt&lt;&lt;1|1, m+1, r, w, v); dp[rt] = max(dp[rt&lt;&lt;1], dp[rt&lt;&lt;1|1]); } ll Query(int rt, int l, int r, int L, int R) { if(l &gt;= L &amp;&amp; r &lt;= R) return dp[rt]; ll Max = 0; int m = (l + r) &gt;&gt; 1; if(L &lt;= m) Max = max(Max, Query(rt&lt;&lt;1, l, m, L, R)); if(R &gt; m) Max = max(Max, Query(rt&lt;&lt;1|1, m+1, r, L, R)); return Max; } }seg; int main() { int n; while(~scanf(\"%d\", &amp;n)) { int cnt = 0; ty[cnt++] = 0; node[0] = Node{0, 0, 0, 0}; for (int i = 1; i &lt;= n; i ++) { scanf(\"%lld %lld %lld %lld\", &amp;node[i].x, &amp;node[i].y, &amp;node[i].a, &amp;node[i].b); ty[cnt++] = node[i].y; } sort(ty, ty + cnt); cnt = unique(ty, ty+cnt) - ty; for (int i = 0; i &lt;= n; i ++) node[i].y = lower_bound(ty, ty + cnt, node[i].y) - ty + 1; sort(node, node + 1 + n); seg.Build(1, 1, cnt); for (int i = 0; i &lt;= n; i ++) { if(node[i].y &lt; cnt) seg.Updata(1, 1, cnt, node[i].y+1, cnt, node[i].b); //[node.y+1~cnt]+a seg.Updata(1, 1, cnt, node[i].y, seg.Query(1, 1, cnt, 1, node[i].y)+node[i].b);//dp[i] = max if(node[i].y &gt; 1) seg.Updata(1, 1, cnt, 1, node[i].y-1, node[i].a);//[1~node.y] + b } printf(\"%lld\\n\", seg.dp[1]); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://orzff.cn/categories/ACM/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://orzff.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"多校","slug":"多校","permalink":"http://orzff.cn/tags/%E5%A4%9A%E6%A0%A1/"}]},{"title":"My First Blog","slug":"2019-08-11-My-First-Blog","date":"2019-08-11T06:57:09.000Z","updated":"2021-05-31T11:58:00.939Z","comments":true,"path":"/81cc/","link":"","permalink":"http://orzff.cn/81cc/","excerpt":"My First Blog","text":"这是我的第一篇博客，主要写一些Hexo的配置 Hexo + Github 搭建博客：跟着这篇博客走即可 Hexo 主题配置Hexo目录下的_config.yml称为站点配置文件 Hexo/themes/next/目录下的_config.yml称为主题配置文件 next主题下载next主题 git clone https://github.com/theme-next/hexo-theme-next themes/next 在站点配置文件 _config.yml # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 在主题配置文件_config.yml中可以选择四种scheme，我选择的是Gemini # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 基本信息配置配置站点配置文件_config.yml title: 标题 subtitle: 副标题 description: 描述 author: 作者 language: 语言（简体中文是zh-Hans） timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 菜单信息配置：配置主题配置文件_config.yml menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat # Enable/Disable menu icons. menu_icons: enable: true 设置标签，分类页面在Git-Bash中输入： hexo new page \"tags\" hexo new page \"categories\" hexo new page \"about\" 这时在Hexo/source/下出现一个tags/index.md和categories/index.md 这时你修改index.md的属性，新加type属性 tags的index --- title: 标签 data: 2019-08-10 00:11:16 type: \"tags\" comments: false --- categories的index --- title: 分类 date: 2019-08-10 00:08:44 type: \"categories\" comments: false --- about的index --- title: 这是我的自我介绍 layout: about comments: false --- comments: false是关闭评论功能 搜索功能在Hexo的根目录下执行 npm install hexo-generator-searchdb --save 站点配置文件_config.yml search: # 本地搜索插件 path: search.xml field: post format: html limit: 10000 在主题配置文件_config.yml中 local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 头像设置把你要作为头像的图片放到：Hexo/themes/next/source/images 然后更改主题配置文件_config.yml中的 Sidebar Avaatar avatar: /images/header.jpg 网站缩略图图标把你要作为缩略图的图片放到：Hexo/themes/next/source/images 然后打开主题配置文件_config.yml,找到 favicon，修改成这样 favicon: small: /images/header.jpg medium: /images/header.jpg apple_touch_icon: /images/header.jpg safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 修改链接文本样式打开Hexo/themes/next/source/css/_common/components/post.styl，添加 .post-body p a { color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; } } 添加评论系统注册登录来必力, 安装City，获得安装代码中的data-uid=\"xxx\" 配置主题配置文件_config.yml,添加LiveRe Uid: livere_uid: #你的LiveRe UID 添加访问计数next已经集成了busuanzi计数，编辑Hexo/themes/next/layout/_third-party/analytics/busuanzi-counter.swig 将 &lt;script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 改为 &lt;script async src=\"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 主题配置文件_config.yml # Show PV/UV of the website/page with busuanzi. # Get more information on http://ibruce.info/2015/04/04/busuanzi/ busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true total_visitors: true total_visitors_icon: user total_view: true total_views_icon: eye post_views: false post_view_icon: eye site_uv_header: &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt; 访客数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=\"fa fa-eye\"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=\"fa fa-file-o\"&gt;&lt;/i&gt; 阅读数 page_pv_footer: 次 文章版权信息编辑主题配置文件_config.yml，修改 post_copyright: enable: true 打赏编辑主题配置文件_config.yml,修改 # Reward reward_comment: 求打赏文本 wechatpay: /images/wechatpay.png # 微信收款二维码 图片路径 alipay: /images/alipay.png # 支付宝收款二维码 图片路径 #bitcoin: /images/bitcoin.png # 比特币 添加更新时间编辑主题配置文件_config.yml,修改 post_meta: item_text: true created_at: true # 创建时间 updated_at: true # 更新时间 # Only show 'updated' if different from 'created'. updated_diff: false # 只使用更新时间 # If true, post's time format will be hexo config's date_format + ' ' + time_format. date_time_merge: false categories: true 修改文章底部的标签编辑Hexo/themes/next/layout/_macro/post.swig 找到rel=\"tag\"&gt;# 将#改为&lt;i class=\"fa fa-tag\"&gt;&lt;/i&gt; 文章底部添加”本文结束”编辑Hexo/themes/next/laayout/_macro/post.swig，在文章结束的地方加上 {% if not is_index %} &lt;div style=\"text-align:center;color: #ccc;font-size:14px;\"&gt; ---------Thanks for your attention--------- &lt;/div&gt; {% endif %} 在页脚添加运行时间编辑themes/next/layout/_partials/footer.swig 在所示位置加上代码： {### 运行时间 ####} &lt;span id=\"sitetime\"&gt;&lt;/span&gt; &lt;script language=javascript&gt; function siteTime(){ window.setTimeout(\"siteTime()\", 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) year - 作为date对象的年份，为4位年份值 month - 0-11之间的整数，做为date对象的月份 day - 1-31之间的整数，做为date对象的天数 hours - 0(午夜24点)-23之间的整数，做为date对象的小时数 minutes - 0-59之间的整数，做为date对象的分钟数 seconds - 0-59之间的整数，做为date对象的秒数 microseconds - 0-999之间的整数，做为date对象的毫秒数 */ var t1 = Date.UTC(2018,02,13,15,00,00); //北京时间2018-2-13 00:00:00 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(\"sitetime\").innerHTML=\" 已运行\"+diffYears+\" 年 \"+diffDays+\" 天 \"+diffHours+\" 小时 \"+diffMinutes+\" 分钟 \"+diffSeconds+\" 秒\"; }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/ siteTime(); &lt;/script&gt; Latex公式更换Hexo的Markdown渲染引擎 npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save 然后打开node_modules/kramed/lib/rules/inline.js 替换11行的escape变量 // escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/ 改变20行的em变量 // em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/ next集成了Mathjax，编辑主题配置文件_config.yml # MathJax Support mathjax: enable: true per_page: true engine: mathjax cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML # Han Support docs: https://hanzi.pro/ han: false 在写文章时要在文章的配置中加上mathjax: true 短链接在根目录执行 npm install hexo-abbrlink --save 配置站点配置文件_config.yml,修改 # abbrlink config abbrlink: alg: crc16 #support crc16(default) and crc32 rep: hex #support dec(default) and hex # 更改 permalink 值 permalink: /:abbrlink/ 文章封面图片在根目录执行 npm install --save hexo-less 在写文章时手动设置文章摘要&lt;!-- less --&gt;为分界线 social修改主题配置文件_config.yml social: #GitHub: https://github.com/yourname || github #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #E-Mail: mailto:yourname@gmail.com || envelope #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype social_icons: enable: true GitHub: github Twitter: twitter 微博: weibo 友链修改主题配置文件_config.yml # Blog rolls links_icon: link links_title: Friend Links links_layout: block #links_layout: inline links: github: http://github.com/ 字数统计和阅读时长在根目录执行 npm install hexo-symbols-count-time --save 修改站点配置文件_config.yml symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 修改主题配置文件_config.yml # Post wordcount display settings # Dependencies: https://github.com/theme-next/hexo-symbols-count-time symbols_count_time: separated_meta: true #文章中的显示是否显示文字（本文字数|阅读时长） item_text_post: true #网页底部的显示是否显示文字（站点总字数|站点阅读时长） item_text_total: false # Average Word Length (chars count in word) awl: 4 # Words Per Minute wpm: 275 隐藏网页底部信息修改主题配置文件_config.yml footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: user counter: true # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target=\"_blank\" href=\"https://pages.github.com\"&gt;GitHub Pages&lt;/a&gt; # --------------------------------------------------------------- # SEO Settings # --------------------------------------------------------------- # Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog. # See: https://support.google.com/webmasters/answer/139066 # Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com ) canonical: true # Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization. seo: false # If true, will add site-subtitle to index page, added in main hexo config. # subtitle: Subtitle index_with_subtitle: false 设置RSS在根目录执行 npm install hexo-generator-feed --save 修改站点配置文件_config.yml,在Extensions下添加 # RSS订阅 feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' 修改主题配置文件 _config.yml修改rss为 rss: /atom.xml 修改字体在GItHub上下载后，解压后将所有Web文件夹下的所有内容放入Hexo/theme/next/source/fonts 然后修改Hexo/themes/next/source/css/_custom/custom.styl //字体 @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Light.eot'); src: url('/fonts/ComicNeue-Light.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Light.woff2') format('woff2'), url('/fonts/ComicNeue-Light.woff') format('woff'), url('/fonts/ComicNeue-Light.ttf') format('truetype'); font-weight: 300; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Light-Oblique.eot'); src: url('/fonts/ComicNeue-Light-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Light-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Light-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Light-Oblique.ttf') format('truetype'); font-weight: 300; font-style: oblique; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Regular.eot'); src: url('/fonts/ComicNeue-Regular.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Regular.woff2') format('woff2'), url('/fonts/ComicNeue-Regular.woff') format('woff'), url('/fonts/ComicNeue-Regular.ttf') format('truetype'); font-weight: 400; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Regular-Oblique.eot'); src: url('/fonts/ComicNeue-Regular-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Regular-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Regular-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Regular-Oblique.ttf') format('truetype'); font-weight: 400; font-style: oblique; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Bold.eot'); src: url('/fonts/ComicNeue-Bold.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Bold.woff2') format('woff2'), url('/fonts/ComicNeue-Bold.woff') format('woff'), url('/fonts/ComicNeue-Bold.ttf') format('truetype'); font-weight: 700; } @font-face { font-family: 'Comic Neue'; src: url('/fonts/ComicNeue-Bold-Oblique.eot'); src: url('/fonts/ComicNeue-Bold-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Bold-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Bold-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Bold-Oblique.ttf') format('truetype'); font-weight: 700; font-style: oblique; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Light.eot'); src: url('/fonts/ComicNeue-Angular-Light.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Light.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Light.woff') format('woff'), url('/fonts/ComicNeue-Angular-Light.ttf') format('truetype'); font-weight: 300; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Light-Oblique.eot'); src: url('/fonts/ComicNeue-Angular-Light-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Light-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Light-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Angular-Light-Oblique.ttf') format('truetype'); font-weight: 300; font-style: oblique; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Regular.eot'); src: url('/fonts/ComicNeue-Angular-Regular.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Regular.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Regular.woff') format('woff'), url('/fonts/ComicNeue-Angular-Regular.ttf') format('truetype'); font-weight: 400; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Regular-Oblique.eot'); src: url('/fonts/ComicNeue-Angular-Regular-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Regular-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Regular-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Angular-Regular-Oblique.ttf') format('truetype'); font-weight: 400; font-style: oblique; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Bold.eot'); src: url('/fonts/ComicNeue-Angular-Bold.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Bold.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Bold.woff') format('woff'), url('/fonts/ComicNeue-Angular-Bold.ttf') format('truetype'); font-weight: 700; } @font-face { font-family: 'Comic Neue Angular'; src: url('/fonts/ComicNeue-Angular-Bold-Oblique.eot'); src: url('/fonts/ComicNeue-Angular-Bold-Oblique.eot?#iefix') format('embedded-opentype'), url('/fonts/ComicNeue-Angular-Bold-Oblique.woff2') format('woff2'), url('/fonts/ComicNeue-Angular-Bold-Oblique.woff') format('woff'), url('/fonts/ComicNeue-Angular-Bold-Oblique.ttf') format('truetype'); font-weight: 700; font-style: oblique; } 修改主题配置文件 _config.yml修改font为 font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: 'Comic Neue' size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: 'Comic Neue' size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: 'Comic Neue' # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: 'Comic Neue' size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: 'Comic Neue' size: 刚开始的字体是默认14px，在代码部分会很小，所以可以在themes/next/source/css/_variables/base.styl 修改 font size和code font 为18px就很好 设置新建文件配置进入Hexo/scaffolds修改post.md --- title: {{ title }} date: {{ date }} mathjax: true categories: tags: --- 新建带日期的博文修改站点配置文件-config.yml # Writing new_post_name: :year-:month-:day-:title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: true # 同时生成一个文件夹 relative_link: false future: true highlight: # Hexo自带代码高亮插件 enable: true line_number: true auto_detect: false tab_replace: 背景图片把背景图片存放到Hexo/themes/next/source/images 再在Hexo/themes/next/source/css/_custom/custom/styl修改一下 body { background:url(/images/music.png);} 参考博客： https://www.jianshu.com/p/3a05351a37dc https://www.cnblogs.com/liziczh/p/9318656.html https://xian6ge.netlify.com/posts/82ce1911/ https://www.jianshu.com/p/805bd0b65d98https://www.jianshu.com/p/805bd0b65d98 https://www.jianshu.com/p/3a01cc514ce7?utm_source=oschina-app https://leflacon.github.io/7167e0bc/","categories":[{"name":"配置","slug":"配置","permalink":"http://orzff.cn/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://orzff.cn/tags/Hexo/"}]}]}